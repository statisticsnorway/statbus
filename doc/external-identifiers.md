# External Identifiers in STATBUS

External identifiers are codes assigned to statistical units by external systems (e.g., tax authorities, statistical offices, administrative systems). STATBUS supports two fundamental shapes of identifiers using a **SUM type design**: regular identifiers for simple cases, and hierarchical identifiers for complex administrative structures.

## Overview

STATBUS uses a modern SUM type pattern to handle both simple and complex identifier scenarios in a unified, type-safe manner. This design eliminates the complexity of multi-table grouping while providing powerful hierarchical query capabilities through PostgreSQL's ltree extension.

### Core Design Principles

1. **SUM Type Pattern**: Each identifier is exactly one of two shapes
2. **Single Row Storage**: One database row per identifier (simple or complex)
3. **TypeScript Compatibility**: Discriminated union types for type safety
4. **Hierarchical Queries**: Native ltree support for tree operations
5. **Import Simplicity**: Unified processing for both identifier shapes

### Database Schema

The system consists of two main tables:

- **`external_ident_type`** - Defines identifier types with shape specification
- **`external_ident`** - Stores actual identifier values using SUM type structure

## Two Identifier Shapes

### 1. Regular Identifiers

Simple, atomic identifiers that are globally unique per type.

**Examples:**
- Tax identifiers: `"NO123456789"`
- Statistical codes: `"ENT_2024_001"`
- Registration numbers: `"REG-ABC-123"`

**Database Storage:**
```sql
-- Type definition
INSERT INTO external_ident_type (code, name, shape, description)
VALUES ('tax_ident', 'Tax Identifier', 'regular', 'National tax authority identifier');

-- Identifier value
INSERT INTO external_ident (type_id, legal_unit_id, ident, edit_by_user_id, edit_at)
VALUES (1, 123, 'NO123456789', 1, now());
```

**TypeScript Type:**
```typescript
type RegularIdent = {
  shape: 'regular';
  ident: string;
  labels: null;
  idents: null;
};
```

### 2. Hierarchical Identifiers

Multi-component identifiers stored as ltree paths with semantic labels.

**Examples:**
- Administrative codes: `'NORTH.KAMPALA.001'` with labels `'region.district.unit'`
- Geographical hierarchies: `'EUROPE.NORWAY.OSLO'` with labels `'continent.country.city'`
- Organizational structures: `'ADMIN.FINANCE.DEPT001'` with labels `'division.section.unit'`

**Database Storage:**
```sql
-- Type definition
INSERT INTO external_ident_type (code, name, shape, labels, description)
VALUES ('admin_statistical', 'Administrative Statistical Code', 'hierarchical', 
        'region.district.unit', 'Multi-level administrative identifier');

-- Identifier value
INSERT INTO external_ident (type_id, legal_unit_id, idents, edit_by_user_id, edit_at)
VALUES (2, 124, 'NORTH.KAMPALA.001'::ltree, 1, now());
```

**TypeScript Type:**
```typescript
type HierarchicalIdent = {
  shape: 'hierarchical';
  ident: null;
  labels: string; // ltree as string: 'region.district.unit'
  idents: string; // ltree as string: 'NORTH.KAMPALA.001'
};
```

## Database Schema Details

### external_ident_type Table

```sql
CREATE TYPE external_ident_shape AS ENUM ('regular', 'hierarchical');

CREATE TABLE external_ident_type (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    code VARCHAR(128) UNIQUE NOT NULL,
    name VARCHAR(50),
    shape external_ident_shape NOT NULL DEFAULT 'regular',
    labels LTREE, -- Schema for hierarchical types (e.g., 'region.district.unit')
    description text,
    priority integer UNIQUE,
    enabled boolean NOT NULL DEFAULT true,

    -- Constraint: hierarchical types must have labels, regular types must not
    CONSTRAINT shape_labels_consistency CHECK (
        (shape = 'regular' AND labels IS NULL) OR
        (shape = 'hierarchical' AND labels IS NOT NULL)
    )
);
```

### external_ident Table

```sql
CREATE TABLE external_ident (
    id integer GENERATED BY DEFAULT AS IDENTITY,
    type_id INTEGER NOT NULL REFERENCES external_ident_type(id),
    shape external_ident_shape NOT NULL, -- Denormalized from type for performance
    
    -- SUM type: exactly one branch must be used
    ident VARCHAR(50),      -- For shape='regular': simple identifier
    idents LTREE,           -- For shape='hierarchical': e.g., 'NORTH.KAMPALA.001'
    labels LTREE,           -- For shape='hierarchical': e.g., 'region.district.unit'
    
    -- Entity associations
    establishment_id INTEGER,
    legal_unit_id INTEGER,
    enterprise_id INTEGER,
    enterprise_group_id INTEGER,
    
    -- Audit fields
    edit_by_user_id integer NOT NULL,
    edit_at timestamp with time zone NOT NULL DEFAULT statement_timestamp(),
    
    -- SUM type constraint: exactly one branch populated
    CONSTRAINT shape_data_consistency CHECK (
        (shape = 'regular' AND ident IS NOT NULL AND idents IS NULL AND labels IS NULL) OR
        (shape = 'hierarchical' AND ident IS NULL AND idents IS NOT NULL AND labels IS NOT NULL)
    ),
    
    -- Hierarchical depth validation
    CONSTRAINT hierarchical_depth_valid CHECK (
        shape != 'hierarchical' OR nlevel(idents) = nlevel(labels)
    )
);
```

### Indexes

```sql
-- Regular identifiers: unique per type
CREATE UNIQUE INDEX external_ident_regular_uniqueness 
ON external_ident (type_id, ident) 
WHERE shape = 'regular';

-- Hierarchical identifiers: unique per type
CREATE UNIQUE INDEX external_ident_hierarchical_uniqueness 
ON external_ident (type_id, idents) 
WHERE shape = 'hierarchical';

-- GiST index for hierarchical queries (ancestor/descendant, pattern matching)
CREATE INDEX external_ident_hierarchical_gist 
ON external_ident USING GIST (idents) 
WHERE shape = 'hierarchical';
```

### Automatic Validation

The system includes triggers that automatically:

1. **Derive shape and labels** from the identifier type
2. **Validate SUM type consistency** - ensures only appropriate fields are populated
3. **Enforce depth matching** for hierarchical identifiers

## ltree Features and Capabilities

PostgreSQL's ltree extension provides powerful hierarchical query capabilities for hierarchical identifiers:

### Path Operations

```sql
-- Extract path components
SELECT 
    idents,                               -- 'NORTH.KAMPALA.001'
    subltree(idents, 0, 1) AS region,    -- 'NORTH'
    subltree(idents, 1, 1) AS district,  -- 'KAMPALA' 
    subltree(idents, 2, 1) AS unit,      -- '001'
    nlevel(idents) AS depth              -- 3
FROM external_ident 
WHERE shape = 'hierarchical';
```

### Pattern Matching with lquery

```sql
-- Find all units in NORTH region
SELECT idents, lu.name 
FROM external_ident ei
JOIN legal_unit lu ON lu.id = ei.legal_unit_id
WHERE ei.idents ~ 'NORTH.*'::lquery;

-- Find all units in NORTH.KAMPALA district
SELECT idents, lu.name
FROM external_ident ei  
JOIN legal_unit lu ON lu.id = ei.legal_unit_id
WHERE ei.idents ~ 'NORTH.KAMPALA.*'::lquery;

-- Multiple pattern matching
SELECT idents, lu.name
FROM external_ident ei
JOIN legal_unit lu ON lu.id = ei.legal_unit_id  
WHERE ei.idents ~ 'NORTH.KAMPALA.* | SOUTH.MBALE.*'::lquery;
```

### Ancestor/Descendant Queries

```sql
-- Find all descendants of NORTH region
SELECT child.idents, lu.name
FROM external_ident parent
JOIN external_ident child ON child.idents <@ parent.idents
JOIN legal_unit lu ON lu.id = child.legal_unit_id
WHERE parent.idents = 'NORTH'::ltree;

-- Find all ancestors of a specific unit
SELECT ancestor.idents
FROM external_ident ancestor  
JOIN external_ident unit ON unit.idents @> ancestor.idents
WHERE unit.idents = 'NORTH.KAMPALA.001'::ltree;
```

### GiST Index Benefits

The GiST index enables efficient:
- Ancestor/descendant lookups: `@>`, `<@`
- Pattern matching: `~`, `?`
- Proximity searches: `#`
- Range queries on hierarchical data

## TypeScript Integration

The SUM type design maps directly to TypeScript discriminated unions:

### Type Definitions

```typescript
// Generated from database schema
type ExternalIdent = 
  | { 
      shape: 'regular'; 
      ident: string; 
      labels: null; 
      idents: null; 
    }
  | { 
      shape: 'hierarchical'; 
      ident: null; 
      labels: string; // ltree as string
      idents: string; // ltree as string  
    };

// Usage in components
function renderIdentifier(ident: ExternalIdent) {
  switch (ident.shape) {
    case 'regular':
      return `Regular: ${ident.ident}`;
    case 'hierarchical':
      return `Hierarchical: ${ident.idents} (${ident.labels})`;
  }
}
```

### REST API Responses

PostgREST returns consistent JSON structure:

```json
{
  "id": 1,
  "type_id": 2, 
  "shape": "hierarchical",
  "ident": null,
  "idents": "NORTH.KAMPALA.001",
  "labels": "region.district.unit",
  "legal_unit_id": 123
}
```

## Import System

The import system handles both identifier shapes through a unified processing pipeline:

### Regular Identifier Import

Standard column mapping:
```sql
-- CSV Column: tax_ident_raw -> external_ident_type.code = 'tax_ident'
-- Value: "NO123456789" -> external_ident.ident = 'NO123456789'
```

### Hierarchical Identifier Import

Two approaches for hierarchical identifiers:

#### 1. Single Column (Recommended)

Import pre-formatted ltree strings:
```sql
-- CSV Column: admin_statistical_raw -> external_ident_type.code = 'admin_statistical'  
-- Value: "NORTH.KAMPALA.001" -> external_ident.idents = 'NORTH.KAMPALA.001'::ltree
```

#### 2. Multiple Column Mapping (Future Feature)

The `hierarchical_column_mapping` table supports combining multiple source columns:

```sql
CREATE TABLE import.hierarchical_column_mapping (
    definition_id INTEGER REFERENCES import.definition(id),
    type_id INTEGER REFERENCES external_ident_type(id),
    source_column_names TEXT[] NOT NULL -- ['admin_region', 'admin_district', 'admin_unit']
);

-- Maps: admin_region='NORTH', admin_district='KAMPALA', admin_unit='001'
-- To: idents='NORTH.KAMPALA.001'::ltree
```

### Import Validation

The import system automatically validates:

1. **Shape consistency** - correct fields populated for identifier type
2. **Depth matching** - hierarchical identifiers match expected depth
3. **Character restrictions** - ltree format compliance (A-Z, a-z, 0-9, _ only)
4. **Uniqueness** - no duplicate identifiers within type
5. **Cross-type conflicts** - identifier doesn't conflict across types

## Usage Examples

### Basic Operations

```sql
-- Create regular identifier type
INSERT INTO external_ident_type (code, name, shape, description)
VALUES ('tax_ident', 'Tax Identifier', 'regular', 'National tax ID');

-- Create hierarchical identifier type  
INSERT INTO external_ident_type (code, name, shape, labels, description)
VALUES ('geo_admin', 'Geographic Administrative Code', 'hierarchical',
        'country.region.municipality', 'Administrative geographic hierarchy');

-- Insert regular identifier
INSERT INTO external_ident (legal_unit_id, type_id, ident, edit_by_user_id, edit_at)
VALUES (123, 
        (SELECT id FROM external_ident_type WHERE code = 'tax_ident'),
        'NO987654321', 1, now());

-- Insert hierarchical identifier
INSERT INTO external_ident (legal_unit_id, type_id, idents, edit_by_user_id, edit_at)  
VALUES (124,
        (SELECT id FROM external_ident_type WHERE code = 'geo_admin'),
        'NORWAY.VESTLAND.BERGEN'::ltree, 1, now());
```

### Query Examples

```sql
-- Find legal unit by regular identifier
SELECT lu.name
FROM external_ident ei
JOIN legal_unit lu ON lu.id = ei.legal_unit_id
JOIN external_ident_type eit ON eit.id = ei.type_id
WHERE eit.code = 'tax_ident' 
  AND ei.ident = 'NO987654321';

-- Find all legal units in Vestland region
SELECT lu.name, ei.idents AS full_path
FROM external_ident ei
JOIN legal_unit lu ON lu.id = ei.legal_unit_id
JOIN external_ident_type eit ON eit.id = ei.type_id
WHERE eit.code = 'geo_admin'
  AND ei.idents ~ 'NORWAY.VESTLAND.*'::lquery;

-- Get all identifiers for a legal unit
SELECT 
    eit.code AS type_code,
    eit.shape,
    CASE 
        WHEN ei.shape = 'regular' THEN ei.ident
        WHEN ei.shape = 'hierarchical' THEN ei.idents::text
    END AS identifier_value
FROM external_ident ei
JOIN external_ident_type eit ON eit.id = ei.type_id
WHERE ei.legal_unit_id = 123
ORDER BY eit.priority;
```

### Hierarchical Analysis

```sql
-- Count units by region
SELECT 
    subltree(ei.idents, 1, 1) AS region,
    COUNT(*) AS unit_count
FROM external_ident ei
JOIN external_ident_type eit ON eit.id = ei.type_id
WHERE eit.code = 'geo_admin'
GROUP BY subltree(ei.idents, 1, 1)
ORDER BY unit_count DESC;

-- Find administrative hierarchy levels
SELECT 
    nlevel(ei.idents) AS depth,
    ei.labels AS schema,
    COUNT(*) AS identifier_count,
    array_agg(DISTINCT subltree(ei.idents, 0, 1)) AS top_level_values
FROM external_ident ei  
JOIN external_ident_type eit ON eit.id = ei.type_id
WHERE eit.shape = 'hierarchical'
GROUP BY nlevel(ei.idents), ei.labels;
```

## Migration from Grouped Identifiers

The new hierarchical system replaces the previous grouped identifier approach:

### Key Changes

1. **Eliminated Complexity**: 
   - Removed `external_ident_type_group` table
   - Removed 300+ lines of complex trigger code
   - No more multi-row coordination

2. **SUM Type Benefits**:
   - One row per identifier (simple or complex)
   - TypeScript-friendly discriminated unions
   - Consistent REST API structure

3. **ltree Advantages**:
   - Native hierarchical queries
   - GiST indexing for performance
   - Standard PostgreSQL extension

### Migration Strategy

For systems upgrading from grouped identifiers:

1. **Export existing grouped data** to temporary tables
2. **Transform groups to ltree format**: combine array elements with dots
3. **Create hierarchical identifier types** with appropriate labels
4. **Import transformed data** as single ltree values
5. **Update application code** to use discriminated unions

### Example Transformation

```sql
-- Old grouped format (multiple rows)
-- type: region_ident, ident: 'NORTH'
-- type: city_ident, ident: 'KAMPALA'  
-- type: seq_ident, ident: '001'

-- New hierarchical format (single row)  
-- type: admin_statistical, idents: 'NORTH.KAMPALA.001'::ltree
-- labels: 'region.district.unit'::ltree
```

## Best Practices

### 1. Type Design

- **Choose appropriate shape**: Use `regular` for simple IDs, `hierarchical` for multi-component
- **Design stable labels**: Label schemas should be long-term stable
- **Use descriptive codes**: Type codes should clearly indicate purpose

### 2. Hierarchical Design

- **Logical hierarchy**: Ensure ltree levels represent meaningful relationships
- **Consistent depth**: All identifiers of a type should have same depth
- **Character restrictions**: Use only A-Z, a-z, 0-9, _ in ltree components
- **Case sensitivity**: ltree is case-sensitive, establish conventions

### 3. Query Optimization

- **Leverage GiST indexes**: Use `~`, `@>`, `<@` operators for hierarchical queries
- **Avoid regex on ltree**: Use lquery patterns instead of regular expressions
- **Filter by type first**: Always include type_id in WHERE clauses

### 4. Import Planning

- **Validate source data**: Ensure hierarchical data follows ltree format rules
- **Test import mapping**: Verify column mappings before production imports
- **Handle missing levels**: Decide on policy for incomplete hierarchical data

## Error Handling

Common validation scenarios:

### Regular Identifier Errors

```sql
-- Error: Using idents field for regular type
INSERT INTO external_ident (type_id, legal_unit_id, idents, ...)
-- ERROR: Regular identifier type "tax_ident" cannot use idents field, use ident instead
```

### Hierarchical Identifier Errors

```sql
-- Error: Depth mismatch
INSERT INTO external_ident (type_id, legal_unit_id, idents, ...)
VALUES (hier_type_id, 123, 'NORTH.KAMPALA'::ltree, ...);
-- ERROR: Hierarchical depth 2 does not match expected depth 3 for type schema 'region.district.unit'

-- Error: Invalid ltree characters  
INSERT INTO external_ident (type_id, legal_unit_id, idents, ...)
VALUES (hier_type_id, 123, 'NORTH-REGION.KAMPALA.001'::ltree, ...);
-- ERROR: Invalid ltree format - use only A-Z, a-z, 0-9, _ characters
```

### SUM Type Errors

```sql
-- Error: Multiple fields populated
INSERT INTO external_ident (type_id, legal_unit_id, ident, idents, ...)
VALUES (regular_type_id, 123, 'TAX123', 'NORTH.KAMPALA.001'::ltree, ...);
-- ERROR: SUM type constraint violation - only one branch can be populated
```

## Performance Considerations

### Index Usage

- **Regular identifiers**: Standard B-tree indexes provide O(log n) lookups
- **Hierarchical identifiers**: GiST indexes enable efficient tree operations
- **Type filtering**: Always filter by type_id for optimal query plans

### Query Patterns

```sql
-- Efficient: Uses type index + hierarchical GiST
SELECT * FROM external_ident 
WHERE type_id = 123 AND idents ~ 'NORTH.*'::lquery;

-- Less efficient: Full table scan on shape
SELECT * FROM external_ident 
WHERE shape = 'hierarchical' AND idents ~ 'NORTH.*'::lquery;
```

### Storage Overhead

- **ltree storage**: ~4 bytes per level + content
- **Index overhead**: GiST indexes require more space than B-tree
- **Denormalization**: Shape/labels fields trade space for query performance

## Conclusion

The hierarchical external identifier system provides a modern, efficient approach to handling both simple and complex identifier scenarios. By leveraging PostgreSQL's ltree extension and a SUM type design pattern, it offers:

- **Type Safety**: Discriminated unions in TypeScript
- **Query Power**: Native hierarchical operations with ltree
- **Simplicity**: One row per identifier, regardless of complexity
- **Performance**: Optimized indexes for both access patterns
- **Flexibility**: Support for any hierarchical depth or structure

This design eliminates the complexity of grouped identifiers while providing more powerful querying capabilities and better integration with modern application architectures.