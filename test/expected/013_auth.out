-- Test file for authentication system
BEGIN;
SET client_min_messages TO NOTICE; -- To see the RAISE NOTICE in the DO block
-- Set up test environment settings once for the entire transaction
-- Set JWT secret and other settings for testing
SET LOCAL "app.settings.jwt_secret" TO 'test-jwt-secret-for-testing-only';
SET LOCAL "app.settings.jwt_exp" TO '3600';
SET LOCAL "app.settings.refresh_jwt_exp" TO '86400';
SET LOCAL "app.settings.deployment_slot_code" TO 'test';
\i test/setup.sql
-- While the datestyle is set for the database, the pg_regress tool sets the MDY format
-- to ensure consistent date formatting, so we must manually override this
SET datestyle TO 'ISO, DMY';
\if :{?DEBUG}
SET client_min_messages TO debug1;
\else
SET client_min_messages TO NOTICE;
\endif
-- Create temporary function to execute queries as system user
CREATE OR REPLACE FUNCTION test.sudo_exec(
    sql text,
    OUT results jsonb
) RETURNS jsonb
SECURITY DEFINER LANGUAGE plpgsql AS $sudo_exec$
DECLARE
    result_rows jsonb;
BEGIN
    -- Check if the SQL starts with common DDL keywords
    IF sql ~* '^\s*(CREATE|DROP|ALTER|TRUNCATE|GRANT|REVOKE|ANALYZE)' THEN
        -- For DDL statements, execute directly
        EXECUTE sql;
        results := '[]'::jsonb;
    ELSE
        -- For DML/queries, wrap in a SELECT to capture results
        EXECUTE format('
            SELECT COALESCE(
                jsonb_agg(row_to_json(t)),
                ''[]''::jsonb
            )
            FROM (%s) t',
            sql
        ) INTO result_rows;
        results := result_rows;
    END IF;
END;
$sudo_exec$;
-- Grant execute to public since this is for testing
GRANT EXECUTE ON FUNCTION test.sudo_exec(text) TO PUBLIC;
\echo Add users for testing purposes
Add users for testing purposes
SELECT * FROM public.user_create('test.admin@statbus.org', 'admin_user'::statbus_role, 'Admin#123!');
         email          |  password  
------------------------+------------
 test.admin@statbus.org | Admin#123!
(1 row)

SELECT * FROM public.user_create('test.regular@statbus.org', 'regular_user'::statbus_role, 'Regular#123!');
          email           |   password   
--------------------------+--------------
 test.regular@statbus.org | Regular#123!
(1 row)

SELECT * FROM public.user_create('test.restricted@statbus.org', 'restricted_user'::statbus_role, 'Restricted#123!');
            email            |    password     
-----------------------------+-----------------
 test.restricted@statbus.org | Restricted#123!
(1 row)

-- Create additional test users not covered by setup.sql, using the @statbus.org domain for consistency.
SELECT * FROM public.user_create('test.external@statbus.org', 'external_user'::statbus_role, 'External#123!');
           email           |   password    
---------------------------+---------------
 test.external@statbus.org | External#123!
(1 row)

SELECT * FROM public.user_create('test.unconfirmed@statbus.org', 'regular_user'::statbus_role, 'Unconfirmed#123!');
            email             |     password     
------------------------------+------------------
 test.unconfirmed@statbus.org | Unconfirmed#123!
(1 row)

-- Ensure the unconfirmed user is actually unconfirmed as public.user_create confirms them by default.
UPDATE auth.user SET email_confirmed_at = NULL WHERE email = 'test.unconfirmed@statbus.org';
-- Test 0: Inet Parsing Verification
\echo '=== Test 0: Inet Parsing Verification ==='
=== Test 0: Inet Parsing Verification ===
DO $$
DECLARE
    test_ip inet;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior (Pattern A)
        RAISE NOTICE 'Test 0.1: Valid IPv4';
        test_ip := inet('192.168.1.1');
        ASSERT test_ip = '192.168.1.1'::inet, 'Test 0.1 Failed: IPv4 parsing error';
        RAISE NOTICE 'Test 0.1: PASSED';

        RAISE NOTICE 'Test 0.2: Valid IPv6';
        test_ip := inet('2001:db8::a');
        ASSERT test_ip = '2001:db8::a'::inet, 'Test 0.2 Failed: IPv6 parsing error';
        RAISE NOTICE 'Test 0.2: PASSED';

        -- Test 0.3 and 0.4 removed as inet() does not parse ports,
        -- and X-Forwarded-For is not expected to contain ports.

        RAISE NOTICE 'Test 0.5: NULL input';
        test_ip := inet(NULL);
        ASSERT test_ip IS NULL, 'Test 0.5 Failed: inet(NULL) should be NULL';
        RAISE NOTICE 'Test 0.5: PASSED';

        RAISE NOTICE 'Test 0.6: Invalid IP string (expect exception)';
        BEGIN
            test_ip := inet('invalid-ip-string');
            RAISE EXCEPTION 'Test 0.6 Failed: inet() did not raise error for invalid IP';
        EXCEPTION WHEN invalid_text_representation THEN
            RAISE NOTICE 'Test 0.6: PASSED (Caught expected invalid_text_representation for "invalid-ip-string")';
        END;

        RAISE NOTICE 'Test 0.7: Empty string input (expect exception)';
        BEGIN
            test_ip := inet('');
            RAISE EXCEPTION 'Test 0.7 Failed: inet() did not raise error for empty string';
        EXCEPTION WHEN invalid_text_representation THEN
            RAISE NOTICE 'Test 0.7: PASSED (Caught expected invalid_text_representation for empty string)';
        END;

        RAISE NOTICE 'Test 0 (Inet Parsing Verification) - Overall PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 0 (Inet Parsing Verification) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 0 (Inet Parsing Verification) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 0.1: Valid IPv4
NOTICE:  Test 0.1: PASSED
NOTICE:  Test 0.2: Valid IPv6
NOTICE:  Test 0.2: PASSED
NOTICE:  Test 0.5: NULL input
NOTICE:  Test 0.5: PASSED
NOTICE:  Test 0.6: Invalid IP string (expect exception)
NOTICE:  Test 0.6: PASSED (Caught expected invalid_text_representation for "invalid-ip-string")
NOTICE:  Test 0.7: Empty string input (expect exception)
NOTICE:  Test 0.7: PASSED (Caught expected invalid_text_representation for empty string)
NOTICE:  Test 0 (Inet Parsing Verification) - Overall PASSED
-- Test 1: Shared IP Extraction Function Test (auth.get_request_ip)
\echo '=== Test 1: Shared IP Extraction Function Test ==='
=== Test 1: Shared IP Extraction Function Test ===
DO $$
DECLARE
    extracted_ip inet;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior (Pattern A)
        RAISE NOTICE 'Test 1.1: Valid IPv4 in x-forwarded-for';
        PERFORM set_config('request.headers', '{"x-forwarded-for": "1.2.3.4"}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip = '1.2.3.4'::inet, 'Test 1.1 Failed';
        RAISE NOTICE 'Test 1.1: PASSED';

        RAISE NOTICE 'Test 1.2: Valid IPv6 in x-forwarded-for';
        PERFORM set_config('request.headers', '{"x-forwarded-for": "2001:db8::c"}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip = '2001:db8::c'::inet, 'Test 1.2 Failed';
        RAISE NOTICE 'Test 1.2: PASSED';

        RAISE NOTICE 'Test 1.3: Valid IPv6 in x-forwarded-for (no port)';
        PERFORM set_config('request.headers', '{"x-forwarded-for": "2001:db8::d"}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip = '2001:db8::d'::inet, 'Test 1.3 Failed';
        RAISE NOTICE 'Test 1.3: PASSED';

        RAISE NOTICE 'Test 1.4: Multiple IPs in x-forwarded-for (takes first)';
        PERFORM set_config('request.headers', '{"x-forwarded-for": "1.2.3.4, 5.6.7.8"}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip = '1.2.3.4'::inet, 'Test 1.4 Failed';
        RAISE NOTICE 'Test 1.4: PASSED';

        RAISE NOTICE 'Test 1.5: IPv4 with port in x-forwarded-for';
        PERFORM set_config('request.headers', '{"x-forwarded-for": "1.2.3.4:8080"}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip = '1.2.3.4'::inet, 'Test 1.5 Failed: IPv4 with port not stripped correctly';
        RAISE NOTICE 'Test 1.5: PASSED';

        RAISE NOTICE 'Test 1.6: IPv6 with brackets and port in x-forwarded-for';
        PERFORM set_config('request.headers', '{"x-forwarded-for": "[2001:db8::a]:8080"}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip = '2001:db8::a'::inet, 'Test 1.6 Failed: IPv6 with brackets and port not stripped correctly';
        RAISE NOTICE 'Test 1.6: PASSED';

        RAISE NOTICE 'Test 1.7: Non-standard IPv6 without brackets but with port in x-forwarded-for (robustness test)';
        PERFORM set_config('request.headers', '{"x-forwarded-for": "2001:db8::b:8080"}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip = '2001:db8::b'::inet, 'Test 1.7 Failed: Non-standard IPv6 (no brackets) with port not stripped correctly by robust parser';
        RAISE NOTICE 'Test 1.7: PASSED';

        RAISE NOTICE 'Test 1.8: x-forwarded-for missing (empty JSON headers)';
        PERFORM set_config('request.headers', '{}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip IS NULL, 'Test 1.8 Failed';
        RAISE NOTICE 'Test 1.8: PASSED';

        RAISE NOTICE 'Test 1.9: x-forwarded-for missing (other headers present)';
        PERFORM set_config('request.headers', '{"user-agent": "test"}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip IS NULL, 'Test 1.9 Failed';
        RAISE NOTICE 'Test 1.9: PASSED';
        
        RAISE NOTICE 'Test 1.10: x-forwarded-for is empty string';
        PERFORM set_config('request.headers', '{"x-forwarded-for": ""}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip IS NULL, 'Test 1.10 Failed';
        RAISE NOTICE 'Test 1.10: PASSED';

        RAISE NOTICE 'Test 1.11: x-forwarded-for is JSON null';
        PERFORM set_config('request.headers', '{"x-forwarded-for": null}', true);
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip IS NULL, 'Test 1.11 Failed';
        RAISE NOTICE 'Test 1.11: PASSED';

        RAISE NOTICE 'Test 1.12: request.headers GUC not set (is NULL)';
        PERFORM set_config('request.headers', NULL, true); -- Simulate GUC not being set
        extracted_ip := auth.get_request_ip();
        ASSERT extracted_ip IS NULL, 'Test 1.12 Failed';
        RAISE NOTICE 'Test 1.12: PASSED';

        RAISE NOTICE 'Test 1.13: request.headers is invalid JSON (expect exception)';
        BEGIN
            PERFORM set_config('request.headers', 'invalid json string', true);
            extracted_ip := auth.get_request_ip();
            RAISE EXCEPTION 'Test 1.13 Failed: auth.get_request_ip() did not raise error for invalid JSON headers';
        EXCEPTION WHEN invalid_text_representation THEN -- Error from ::json cast
            RAISE NOTICE 'Test 1.13: PASSED (Caught expected invalid_text_representation for JSON)';
        END;
        
        RAISE NOTICE 'Test 1.14: x-forwarded-for contains invalid IP string (expect exception)';
        BEGIN
            PERFORM set_config('request.headers', '{"x-forwarded-for": "invalid-ip"}', true);
            extracted_ip := auth.get_request_ip();
            RAISE EXCEPTION 'Test 1.14 Failed: auth.get_request_ip() did not raise error for invalid IP in xff';
        EXCEPTION WHEN invalid_text_representation THEN -- Error from inet() conversion
            RAISE NOTICE 'Test 1.14: PASSED (Caught expected invalid_text_representation for inet)';
        END;

        RAISE NOTICE 'Test 1 (Shared IP Extraction Function Test) - Overall PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 1 (Shared IP Extraction Function Test) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 1 (Shared IP Extraction Function Test) - FAILED: %', SQLERRM;
    END;
    -- Reset headers GUC to a sensible default after tests
    PERFORM set_config('request.headers', '{}', true);
END;
$$;
NOTICE:  Test 1.1: Valid IPv4 in x-forwarded-for
NOTICE:  Test 1.1: PASSED
NOTICE:  Test 1.2: Valid IPv6 in x-forwarded-for
NOTICE:  Test 1.2: PASSED
NOTICE:  Test 1.3: Valid IPv6 in x-forwarded-for (no port)
NOTICE:  Test 1.3: PASSED
NOTICE:  Test 1.4: Multiple IPs in x-forwarded-for (takes first)
NOTICE:  Test 1.4: PASSED
NOTICE:  Test 1.5: IPv4 with port in x-forwarded-for
    
-- Helper function to extract and verify JWT claims using pgjwt
CREATE OR REPLACE FUNCTION test.verify_jwt_claims(token text, expected_claims jsonb)
RETURNS boolean AS $$
DECLARE
    verification record;
    payload jsonb;
    claim_key text;
    claim_value jsonb;
BEGIN
    -- Use pgjwt's verify function to decode the token
    -- We're not verifying the signature here, just extracting the payload
    SELECT * INTO verification FROM verify(token, 'test-jwt-secret-for-testing-only', 'HS256');
    
    -- Convert payload to jsonb
    payload := verification.payload::jsonb;
    
    -- Check each expected claim
    FOR claim_key, claim_value IN SELECT * FROM jsonb_each(expected_claims)
    LOOP
        IF payload->claim_key IS DISTINCT FROM claim_value THEN
            RAISE NOTICE 'Claim % mismatch: expected %, got %', 
                claim_key, claim_value, payload->claim_key;
            RETURN false;
        END IF;
    END LOOP;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;
-- Helper function to extract cookies from response headers
CREATE OR REPLACE FUNCTION test.extract_cookies()
RETURNS TABLE(cookie_name text, cookie_value text, expires_at timestamptz) AS $$
DECLARE
    headers jsonb;
    header_obj jsonb;
    cookie_str text;
    cookie_parts text[];
    cookie_attrs text[];
    attr text;
    expires_str text;
    i integer;
BEGIN
    -- Get response headers
    headers := nullif(current_setting('response.headers', true), '')::jsonb;
    
    -- Process each header
    IF headers IS NOT NULL THEN
        FOR header_obj IN SELECT * FROM jsonb_array_elements(headers)
        LOOP
            IF header_obj ? 'Set-Cookie' THEN
                cookie_str := header_obj->>'Set-Cookie';
                
                -- Extract cookie name and value
                cookie_parts := regexp_split_to_array(split_part(cookie_str, ';', 1), '=');
                IF array_length(cookie_parts, 1) >= 2 THEN
                    cookie_name := cookie_parts[1];
                    cookie_value := cookie_parts[2];
                    
                    -- Extract expiration date if present
                    expires_at := NULL;
                    cookie_attrs := string_to_array(substring(cookie_str from position(';' in cookie_str) + 1), ';');
                    
                    IF cookie_attrs IS NOT NULL THEN
                        FOREACH attr IN ARRAY cookie_attrs
                        LOOP
                            attr := trim(attr);
                            IF position('Expires=' in attr) = 1 THEN
                                expires_str := substring(attr from 9); -- 'Expires=' is 8 chars + 1
                                
                                -- Try to convert to timestamptz
                                BEGIN
                                    -- HTTP date format is like: "Thu, 01 Jan 1970 00:00:00 GMT"
                                    -- Convert to timestamptz
                                    expires_at := to_timestamp(expires_str, 'Dy, DD Mon YYYY HH24:MI:SS GMT');
                                EXCEPTION WHEN OTHERS THEN
                                    -- If conversion fails, leave as NULL
                                    RAISE DEBUG 'Could not convert expires date: %', expires_str;
                                END;
                                
                                EXIT;
                            END IF;
                        END LOOP;
                    END IF;
                    
                    RETURN NEXT;
                END IF;
            END IF;
        END LOOP;
    END IF;
    
    RETURN;
END;
$$ LANGUAGE plpgsql;
-- Helper function to perform login with specific headers and verify results
CREATE OR REPLACE FUNCTION test.perform_login_and_verify(
    p_email text,
    p_password text,
    p_scenario_name text,
    p_request_headers jsonb,
    p_expected_ip inet,
    p_expected_secure_flag boolean,
    p_expected_user_agent text
) RETURNS void AS $$
DECLARE
    login_result jsonb;
    access_token text;
    refresh_jwt text;
    has_access_cookie boolean := false;
    has_refresh_cookie boolean := false;
    response_headers jsonb;
    header_obj jsonb;
    session_record record;
    cookie_value_text text;
    refresh_jwt_payload jsonb;
    session_jti uuid;
BEGIN
    RAISE DEBUG 'Running login scenario: % with headers %', p_scenario_name, p_request_headers;

    -- Set up headers
    PERFORM set_config('request.headers', p_request_headers::text, true);
    -- Clear previous response headers
    PERFORM set_config('response.headers', '[]'::text, true);

    -- Perform login
    SELECT to_json(source.*) INTO login_result FROM public.login(p_email, p_password) AS source;
    
    RAISE DEBUG 'Login result for scenario "%": %', p_scenario_name, login_result;
    response_headers := nullif(current_setting('response.headers', true), '')::jsonb;
    RAISE DEBUG 'Response headers for scenario "%": %', p_scenario_name, response_headers;

    ASSERT login_result IS NOT NULL AND login_result ? 'access_jwt', 
        format('Login should succeed and return access_jwt for scenario %L', p_scenario_name);
    access_token := login_result->>'access_jwt';
    refresh_jwt := login_result->>'refresh_jwt';

    -- Verify cookies were set and check Secure flag
    ASSERT response_headers IS NOT NULL AND jsonb_array_length(response_headers) > 0,
        format('Response headers should contain Set-Cookie directives for scenario %L', p_scenario_name);

    FOR header_obj IN SELECT * FROM jsonb_array_elements(response_headers) LOOP
        IF header_obj ? 'Set-Cookie' THEN
            cookie_value_text := header_obj->>'Set-Cookie';
            IF cookie_value_text LIKE 'statbus=%' THEN
                has_access_cookie := true;
                IF p_expected_secure_flag THEN
                    ASSERT cookie_value_text LIKE '%Secure%', 
                        format('Access cookie should have Secure flag for scenario %L with headers %L', p_scenario_name, p_request_headers::text);
                ELSE
                    ASSERT cookie_value_text NOT LIKE '%Secure%', 
                        format('Access cookie should NOT have Secure flag for scenario %L with headers %L', p_scenario_name, p_request_headers::text);
                END IF;
            END IF;
            IF cookie_value_text LIKE 'statbus-refresh=%' THEN
                has_refresh_cookie := true;
                IF p_expected_secure_flag THEN
                    ASSERT cookie_value_text LIKE '%Secure%', 
                        format('Refresh cookie should have Secure flag for scenario %L with headers %L', p_scenario_name, p_request_headers::text);
                ELSE
                    ASSERT cookie_value_text NOT LIKE '%Secure%', 
                        format('Refresh cookie should NOT have Secure flag for scenario %L with headers %L', p_scenario_name, p_request_headers::text);
                END IF;
            END IF;
        END IF;
    END LOOP;
    
    ASSERT has_access_cookie, format('Access cookie was not set for scenario %L', p_scenario_name);
    ASSERT has_refresh_cookie, format('Refresh cookie was not set for scenario %L', p_scenario_name);

    -- Verify session was created in database with correct IP and User Agent
    -- Decode the refresh JWT from the login result to get the session JTI
    SELECT payload::jsonb INTO refresh_jwt_payload 
    FROM verify(refresh_jwt, 'test-jwt-secret-for-testing-only', 'HS256');
    
    session_jti := (refresh_jwt_payload->>'jti')::uuid;

    RAISE DEBUG 'Extracted session JTI % for scenario %L from refresh token', session_jti, p_scenario_name;

    SELECT rs.ip_address, rs.user_agent INTO session_record
    FROM auth.refresh_session rs
    WHERE rs.jti = session_jti;

    ASSERT FOUND, format('Session with JTI %L not found for scenario %L', session_jti, p_scenario_name);

    IF p_expected_ip IS NOT NULL THEN
        ASSERT session_record.ip_address = p_expected_ip, 
            format('Session IP address mismatch for scenario %L. Expected: %s, Got: %s', p_scenario_name, p_expected_ip, session_record.ip_address);
    ELSE
        ASSERT session_record.ip_address IS NULL,
            format('Session IP address should be NULL for scenario %L. Got: %s', p_scenario_name, session_record.ip_address);
    END IF;
    
    IF p_expected_user_agent IS NOT NULL THEN
         ASSERT session_record.user_agent = p_expected_user_agent, 
            format('Session User Agent mismatch for scenario %L. Expected: %L, Got: %L', p_scenario_name, p_expected_user_agent, session_record.user_agent);
    ELSE
        ASSERT session_record.user_agent IS NULL,
            format('Session User Agent should be NULL for scenario %L. Got: %L', p_scenario_name, session_record.user_agent);
    END IF;
    RAISE DEBUG 'Login scenario %L passed all checks.', p_scenario_name; -- Changed %s to %L for RAISE DEBUG as well for consistency, though it's less critical here.
END;
$$ LANGUAGE plpgsql;
-- Test 2: User Login Success
\echo '=== Test 2: User Login Success ==='
=== Test 2: User Login Success ===
DO $$
DECLARE
    login_result jsonb;
    expected_claims jsonb;
    access_token text;
    refresh_jwt text;
    cookies record;
    has_access_cookie boolean := false;
    has_refresh_cookie boolean := false;
    auth_status_result jsonb;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Original Test 1 logic starts here
        -- Set up headers to simulate a browser
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );

    -- Perform login
    SELECT to_json(source.*) INTO login_result FROM public.login('test.regular@statbus.org', 'Regular#123!') AS source;
    
    -- Debug the login result
    RAISE DEBUG 'Login result: %', login_result;
    
    -- Debug the returned headers from the login function
    RAISE DEBUG 'Response headers after login: %', nullif(current_setting('response.headers', true), '')::jsonb;
    
    -- Verify login result contains expected fields
    ASSERT login_result ? 'access_jwt', 'Login result should contain access_jwt';
    ASSERT login_result ? 'refresh_jwt', 'Login result should contain refresh_jwt';
    ASSERT login_result ? 'uid', 'Login result should contain uid';
    ASSERT login_result ? 'role', 'Login result should contain role';
    ASSERT login_result ? 'statbus_role', 'Login result should contain statbus_role';
    ASSERT login_result ? 'email', 'Login result should contain email';
    
    -- Verify token claims
    access_token := login_result->>'access_jwt';
    expected_claims := jsonb_build_object(
        'role', 'test.regular@statbus.org',
        'statbus_role', 'regular_user',
        'email', 'test.regular@statbus.org',
        'type', 'access'
    );
    
    ASSERT test.verify_jwt_claims(access_token, expected_claims), 
        'Access token claims do not match expected values';
    
    -- Verify refresh token claims
    refresh_jwt := login_result->>'refresh_jwt';
    expected_claims := jsonb_build_object(
        'role', 'test.regular@statbus.org',
        'statbus_role', 'regular_user',
        'email', 'test.regular@statbus.org',
        'type', 'refresh'
    );
    
    ASSERT test.verify_jwt_claims(refresh_jwt, expected_claims), 
        'Refresh token claims do not match expected values';
    
    -- Verify cookies were set
    FOR cookies IN SELECT * FROM test.extract_cookies()
    LOOP
        IF cookies.cookie_name = 'statbus' THEN
            has_access_cookie := true;
            ASSERT cookies.cookie_value = access_token, 'Access cookie value does not match token';
        ELSIF cookies.cookie_name = 'statbus-refresh' THEN
            has_refresh_cookie := true;
            ASSERT cookies.cookie_value = refresh_jwt, 'Refresh cookie value does not match token';
        END IF;
    END LOOP;
    
    ASSERT has_access_cookie, 'Access cookie was not set';
    ASSERT has_refresh_cookie, 'Refresh cookie was not set';

    -- Verify Secure flag in cookies
    DECLARE
        response_headers jsonb;
        header_obj jsonb;
        access_cookie_secure boolean := false;
        refresh_cookie_secure boolean := false;
    BEGIN
        response_headers := nullif(current_setting('response.headers', true), '')::jsonb;
        FOR header_obj IN SELECT * FROM jsonb_array_elements(response_headers) LOOP
            IF header_obj ? 'Set-Cookie' THEN
                IF header_obj->>'Set-Cookie' LIKE 'statbus=%' AND header_obj->>'Set-Cookie' LIKE '%Secure%' THEN
                    access_cookie_secure := true;
                END IF;
                IF header_obj->>'Set-Cookie' LIKE 'statbus-refresh=%' AND header_obj->>'Set-Cookie' LIKE '%Secure%' THEN
                    refresh_cookie_secure := true;
                END IF;
            END IF;
        END LOOP;
        ASSERT access_cookie_secure, 'Access cookie should have Secure flag when x-forwarded-proto is https';
        ASSERT refresh_cookie_secure, 'Refresh cookie should have Secure flag when x-forwarded-proto is https';
    END;
    
    -- Verify session was created in database with correct IP and User Agent
    DECLARE
        session_record record;
    BEGIN
        SELECT rs.ip_address, rs.user_agent INTO session_record
        FROM auth.refresh_session rs
        JOIN auth.user u ON rs.user_id = u.id
        WHERE u.email = 'test.regular@statbus.org'
        ORDER BY rs.created_at DESC LIMIT 1;

        ASSERT session_record.ip_address = '127.0.0.1'::inet, 'Session IP address mismatch';
        ASSERT session_record.user_agent = 'Test User Agent', 'Session User Agent mismatch';
    END;
    
    -- Verify last_sign_in_at was updated
    ASSERT (
        SELECT last_sign_in_at > now() - interval '1 minute'
        FROM auth.user
        WHERE email = 'test.regular@statbus.org'
    ), 'last_sign_in_at was not updated';
    
    -- Now test auth_status using the cookies from the first login
    -- Set up cookies to simulate browser cookies
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus', access_token,
            'statbus-refresh', refresh_jwt
        )::text, 
        true
    );
    -- Headers for auth_status (already set from initial login)
    PERFORM set_config('request.jwt.claims', '', true); -- Reset JWT claims to ensure we're using cookies
    
    SELECT to_json(source.*) INTO auth_status_result FROM public.auth_status() AS source;
    RAISE DEBUG 'Auth status result (after initial login): %', auth_status_result;
    ASSERT auth_status_result->>'is_authenticated' = 'true', 'Auth status should show authenticated';
    ASSERT auth_status_result->>'email' = 'test.regular@statbus.org', 'Auth status should have correct email';

    RAISE NOTICE '--- Test 2.1: Initial Login and Auth Status Verification - PASSED ---';

    RAISE NOTICE '--- Test 2.2: Header Variations for Login ---';
    -- Scenario 1: HTTPS proxy (standard)
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'HTTPS Proxy',
        jsonb_build_object(
            'x-forwarded-for', '10.0.0.1',
            'user-agent', 'HTTPS Agent',
            'x-forwarded-proto', 'https'
        ),
        '10.0.0.1'::inet, true, 'HTTPS Agent'
    );

    -- Scenario 2: HTTP proxy
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'HTTP Proxy',
        jsonb_build_object(
            'x-forwarded-for', '10.0.0.2',
            'user-agent', 'HTTP Agent',
            'x-forwarded-proto', 'http'
        ),
        '10.0.0.2'::inet, false, 'HTTP Agent'
    );

    -- Scenario 3: Naked request (no proxy headers)
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'Naked Request',
        jsonb_build_object('user-agent', 'Naked Agent'),
        NULL::inet, false, 'Naked Agent' -- IP is NULL as x-forwarded-for is missing
    );
    
    -- Scenario 4: Naked request (no headers at all)
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'Naked Request No Headers',
        jsonb_build_object(), -- Empty headers
        NULL::inet, false, NULL -- IP and UA are NULL
    );

    -- Scenario 5: Multiple IPs in x-forwarded-for (HTTPS)
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'Multiple IPs HTTPS',
        jsonb_build_object(
            'x-forwarded-for', '10.0.0.3, 192.168.0.1',
            'user-agent', 'Multi-IP Agent',
            'x-forwarded-proto', 'https'
        ),
        '10.0.0.3'::inet, true, 'Multi-IP Agent' -- Should take the first IP
    );

    -- Scenario 6: IPv6 in x-forwarded-for (HTTPS)
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'IPv6 HTTPS',
        jsonb_build_object(
            'x-forwarded-for', '2001:db8::a', -- Removed brackets
            'user-agent', 'IPv6 Agent',
            'x-forwarded-proto', 'https'
        ),
        '2001:db8::a'::inet, true, 'IPv6 Agent'
    );

    -- Scenario 7: IP in x-forwarded-for (HTTPS, no port)
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'IP with Port HTTPS', -- Scenario name can remain, implies testing IP handling
        jsonb_build_object(
            'x-forwarded-for', '10.0.0.4', -- No port
            'user-agent', 'IP-Port Agent',
            'x-forwarded-proto', 'https'
        ),
        '10.0.0.4'::inet, true, 'IP-Port Agent'
    );

    -- Scenario 8: IPv6 with port in x-forwarded-for (HTTPS)
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'IPv6 with Port HTTPS', -- Scenario name can remain
        jsonb_build_object(
            'x-forwarded-for', '2001:db8::b', -- No port, no brackets needed
            'user-agent', 'IPv6-Port Agent',
            'x-forwarded-proto', 'https'
        ),
        '2001:db8::b'::inet, true, 'IPv6-Port Agent'
    );
    
    -- Scenario 9: x-forwarded-proto: HTTPS (uppercase) - current code is case-sensitive for 'https'
    PERFORM test.perform_login_and_verify(
        'test.regular@statbus.org', 'Regular#123!',
        'Uppercase HTTPS Proto',
        jsonb_build_object(
            'x-forwarded-for', '10.0.0.5',
            'user-agent', 'Case Agent',
            'x-forwarded-proto', 'HTTPS' -- Uppercase
        ),
        '10.0.0.5'::inet, true, 'Case Agent' -- Expect Secure: true after case-insensitive fix
    );

        RAISE NOTICE 'Test 2: User Login Success (including header variations) - PASSED';
        -- End of original Test 2 logic
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 2 (User Login Success) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 2 (User Login Success) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  --- Test 2.1: Initial Login and Auth Status Verification - PASSED ---
NOTICE:  --- Test 2.2: Header Variations for Login ---
NOTICE:  Test 2: User Login Success (including header variations) - PASSED
-- Test 3: User Login Failure - Wrong Password
\echo '=== Test 3: User Login Failure - Wrong Password ==='
=== Test 3: User Login Failure - Wrong Password ===
DO $$
DECLARE
    login_result jsonb;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Original Test 3 logic starts here
        -- Set up headers to simulate a browser
    PERFORM set_config('request.headers', 
        json_build_object(
        'x-forwarded-for', '127.0.0.1',
        'user-agent', 'Test User Agent',
        'x-forwarded-proto', 'https' -- Simulate HTTPS
    )::text, 
    true
);

    -- Attempt login with wrong password
    SELECT to_json(source.*) INTO login_result FROM public.login('test.regular@statbus.org', 'wrongpassword') AS source;
    
    -- Debug the login result
    RAISE DEBUG 'Login result (should be null): %', login_result;
    
    -- Verify login failed (result should be null or not contain uid)
    ASSERT (login_result IS NULL OR login_result ->> 'uid' IS NULL), 'Login with wrong password should return null or not contain uid';
    
        RAISE NOTICE 'Test 3: User Login Failure - Wrong Password - PASSED';
        -- End of original Test 3 logic
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 3 (User Login Failure - Wrong Password) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 3 (User Login Failure - Wrong Password) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 3: User Login Failure - Wrong Password - PASSED
-- Test 4: User Login Failure - Unconfirmed Email
\echo '=== Test 4: User Login Failure - Unconfirmed Email ==='
=== Test 4: User Login Failure - Unconfirmed Email ===
DO $$
DECLARE
    login_result jsonb;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Set up headers to simulate a browser
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );

    -- Attempt login with unconfirmed email
    SELECT to_json(source.*) INTO login_result FROM public.login('test.unconfirmed@statbus.org', 'Unconfirmed#123!') AS source;
    
    -- Debug the login result
    RAISE DEBUG 'Login result (should be null): %', login_result;
    
    -- Verify login failed (result should be null or not contain uid)
    ASSERT (login_result IS NULL OR login_result ->> 'uid' IS NULL), 'Login with unconfirmed email should return null or not contain uid';
    
        RAISE NOTICE 'Test 4: User Login Failure - Unconfirmed Email - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 4 (User Login Failure - Unconfirmed Email) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 4 (User Login Failure - Unconfirmed Email) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 4: User Login Failure - Unconfirmed Email - PASSED
-- Test 5: Token Refresh
\echo '=== Test 5: Token Refresh ==='
=== Test 5: Token Refresh ===
DO $$
DECLARE
    login_result jsonb;
    refresh_result jsonb;
    refresh_jwt text;
    access_jwt text;
    refresh_session_before record;
    refresh_session_after record;
    auth_status_before jsonb;
    auth_status_after jsonb;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Reset context for the test
    PERFORM set_config('request.cookies', '{}', true); -- Login doesn't use request cookies
    PERFORM set_config('request.jwt.claims', '', true); -- Clear any JWT claims from previous tests
    PERFORM set_config('response.headers', '[]', true); -- Clear response headers before login
    
    -- Set up request headers for login
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1', -- Initial IP
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );

    -- First login
    SELECT to_json(source.*) INTO login_result FROM public.login('test.admin@statbus.org', 'Admin#123!') AS source;
    RAISE DEBUG 'Login result: %', login_result;
    
    -- Debug the returned headers from the login function
    RAISE DEBUG 'Response headers after login: %', nullif(current_setting('response.headers', true), '')::jsonb;
    
    -- Extract and verify response headers for Secure, HttpOnly, SameSite
    DECLARE
        response_headers jsonb;
        header_obj jsonb;
        access_cookie_found boolean := false;
        refresh_cookie_found boolean := false;
        access_cookie_attrs_valid boolean := false;
        refresh_cookie_attrs_valid boolean := false;
    BEGIN
        response_headers := nullif(current_setting('response.headers', true), '')::jsonb;
        
        FOR header_obj IN SELECT * FROM jsonb_array_elements(response_headers) LOOP
            IF header_obj ? 'Set-Cookie' THEN
                IF header_obj->>'Set-Cookie' LIKE 'statbus=%' THEN
                    access_cookie_found := true;
                    IF header_obj->>'Set-Cookie' LIKE '%HttpOnly%' AND 
                       header_obj->>'Set-Cookie' LIKE '%SameSite=Strict%' AND
                       header_obj->>'Set-Cookie' LIKE '%Secure%' THEN
                        access_cookie_attrs_valid := true;
                    END IF;
                ELSIF header_obj->>'Set-Cookie' LIKE 'statbus-refresh=%' THEN
                    refresh_cookie_found := true;
                    IF header_obj->>'Set-Cookie' LIKE '%HttpOnly%' AND 
                       header_obj->>'Set-Cookie' LIKE '%SameSite=Strict%' AND
                       header_obj->>'Set-Cookie' LIKE '%Secure%' THEN
                        refresh_cookie_attrs_valid := true;
                    END IF;
                END IF;
            END IF;
        END LOOP;
        
        ASSERT access_cookie_found, 'Access cookie not found in login response headers';
        ASSERT refresh_cookie_found, 'Refresh cookie not found in login response headers';
        ASSERT access_cookie_attrs_valid, 'Access cookie missing required security attributes (HttpOnly, SameSite, Secure)';
        ASSERT refresh_cookie_attrs_valid, 'Refresh cookie missing required security attributes (HttpOnly, SameSite, Secure)';
        
        RAISE DEBUG 'Login cookie validation passed: Access and refresh cookies have required security attributes.';
    END;
        
    -- Assert login result contains expected fields
    ASSERT login_result->>'role' = 'test.admin@statbus.org', 'Role should match email';
    ASSERT login_result->>'email' = 'test.admin@statbus.org', 'Email should be returned correctly';
    ASSERT login_result->>'access_jwt' IS NOT NULL, 'Access token should be present';
    ASSERT login_result->>'statbus_role' = 'admin_user', 'Statbus role should be admin_user';
    
    -- Decode the access token and display it
    DECLARE
        access_jwt_str text;
        access_jwt_payload jsonb;
        token_verification record;
    BEGIN
        access_jwt_str := login_result->>'access_jwt';
        SELECT * INTO token_verification FROM verify(access_jwt_str, 'test-jwt-secret-for-testing-only', 'HS256');
        access_jwt_payload := token_verification.payload::jsonb;
        RAISE DEBUG 'Decoded access token: %', access_jwt_payload;
        
        -- Verify deterministic keys in the access token payload
        ASSERT access_jwt_payload->>'role' = 'test.admin@statbus.org', 'Role in token should match email';
        ASSERT access_jwt_payload->>'email' = 'test.admin@statbus.org', 'Email in token should be correct';
        ASSERT access_jwt_payload->>'type' = 'access', 'Token type should be access';
        ASSERT access_jwt_payload->>'statbus_role' = 'admin_user', 'Statbus role should be admin_user';
        
        -- Verify dynamic values are present and not null
        ASSERT access_jwt_payload->>'exp' IS NOT NULL, 'Expiration time should be present';
        ASSERT access_jwt_payload->>'iat' IS NOT NULL, 'Issued at time should be present';
        ASSERT access_jwt_payload->>'jti' IS NOT NULL, 'JWT ID should be present';
        ASSERT access_jwt_payload->>'sub' IS NOT NULL, 'Subject should be present';
        ASSERT access_jwt_payload->>'uid' IS NOT NULL, 'User ID (uid) should be present';
    END;
    
    -- Decode the refresh token and display it
    DECLARE
        refresh_jwt_str text;
        refresh_jwt_payload jsonb;
        refresh_token_verification record;
    BEGIN
        refresh_jwt_str := login_result->>'refresh_jwt';
        SELECT * INTO refresh_token_verification FROM verify(refresh_jwt_str, 'test-jwt-secret-for-testing-only', 'HS256');
        refresh_jwt_payload := refresh_token_verification.payload::jsonb;
        RAISE DEBUG 'Decoded refresh token: %', refresh_jwt_payload;
        
        -- Verify deterministic keys in the refresh token payload
        ASSERT refresh_jwt_payload->>'role' = 'test.admin@statbus.org', 'Role in refresh token should match email';
        ASSERT refresh_jwt_payload->>'email' = 'test.admin@statbus.org', 'Email in refresh token should be correct';
        ASSERT refresh_jwt_payload->>'type' = 'refresh', 'Token type should be refresh';
        ASSERT refresh_jwt_payload->>'statbus_role' = 'admin_user', 'Statbus role should be admin_user';
        
        -- Verify dynamic values are present and not null
        ASSERT refresh_jwt_payload->>'exp' IS NOT NULL, 'Expiration time should be present';
        ASSERT refresh_jwt_payload->>'iat' IS NOT NULL, 'Issued at time should be present';
        ASSERT refresh_jwt_payload->>'jti' IS NOT NULL, 'JWT ID should be present';
        ASSERT refresh_jwt_payload->>'sub' IS NOT NULL, 'Subject should be present';
        ASSERT refresh_jwt_payload->>'version' IS NOT NULL, 'Version should be present';
    END;
        
    access_jwt := login_result->>'access_jwt';
    refresh_jwt := login_result->>'refresh_jwt';
    
    -- Store session info before refresh
    SELECT rs.*, u.id AS user_id, u.sub AS user_sub INTO refresh_session_before
    FROM auth.refresh_session rs
    JOIN auth.user u ON rs.user_id = u.id
    WHERE u.email = 'test.admin@statbus.org'
    ORDER BY rs.created_at DESC
    LIMIT 1;
    
    -- Debug the refresh session before refresh
    RAISE DEBUG 'Refresh session before refresh: %', row_to_json(refresh_session_before);

    -- Verify initial session IP and User Agent
    ASSERT refresh_session_before.ip_address = '127.0.0.1'::inet, 'Initial session IP address mismatch';
    ASSERT refresh_session_before.user_agent = 'Test User Agent', 'Initial session User Agent mismatch';
    
    -- Check auth status before refresh
    -- Set cookies properly in request.cookies instead of request.headers.cookie
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus', access_jwt,
            'statbus-refresh', refresh_jwt
        )::text, 
        true
    );
    
    -- Also set headers for completeness, but without the cookie
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1', -- IP at the time of auth_status check
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );
    
    -- Reset JWT claims to ensure we're using cookies
    PERFORM set_config('request.jwt.claims', '', true);
    
    -- Get auth status before refresh
    SELECT to_json(source.*) INTO auth_status_before FROM public.auth_status() AS source;
    RAISE DEBUG 'Auth status before refresh: %', auth_status_before;
    
    -- Verify auth status before refresh
    ASSERT auth_status_before->>'is_authenticated' = 'true', 'Auth status should show authenticated';
    ASSERT auth_status_before->'uid' IS NOT NULL, 'Auth status should include user info';
    ASSERT auth_status_before->>'email' = 'test.admin@statbus.org', 'Auth status should have correct email';
        
    -- Sleep 1 second, to ensure the iat will increase, because it counts in whole seconds.
    PERFORM pg_sleep(1);

    -- Perform token refresh (Scenario 1: HTTPS headers during refresh)
    RAISE NOTICE '--- Test 5.1: Refresh with HTTPS headers ---';
    
    -- Set cookies for refresh call
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus-refresh', refresh_jwt
        )::text, 
        true
    );
    -- Set headers for refresh call
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '192.168.1.100', -- New IP for refresh
            'user-agent', 'Refresh UA HTTPS',   -- New UA for refresh
            'x-forwarded-proto', 'https'      -- Simulate HTTPS for refresh
        )::text, 
        true
    );
    -- Clear response headers before refresh call (as refresh() sets cookies)
    PERFORM set_config('response.headers', '[]'::text, true);

    SELECT to_json(source.*) INTO refresh_result FROM public.refresh() AS source;
    RAISE DEBUG 'Refresh result (HTTPS): %', refresh_result;
    
    DECLARE
        response_headers_refresh jsonb;
        header_obj jsonb;
        access_cookie_is_secure boolean := false;
        refresh_cookie_is_secure boolean := false;
        access_cookie_found_https boolean := false;
        refresh_cookie_found_https boolean := false;
        cookie_value_text text;
    BEGIN
        response_headers_refresh := nullif(current_setting('response.headers', true), '')::jsonb;
        RAISE DEBUG 'Response headers after HTTPS refresh: %', response_headers_refresh;
        ASSERT response_headers_refresh IS NOT NULL, 'Response headers should not be null after HTTPS refresh';

        FOR header_obj IN SELECT * FROM jsonb_array_elements(response_headers_refresh) LOOP
            IF header_obj ? 'Set-Cookie' THEN
                cookie_value_text := header_obj->>'Set-Cookie';
                IF cookie_value_text LIKE 'statbus=%' THEN
                    access_cookie_found_https := true;
                    IF cookie_value_text LIKE '%Secure%' THEN
                        access_cookie_is_secure := true;
                    END IF;
                END IF;
                IF cookie_value_text LIKE 'statbus-refresh=%' THEN
                    refresh_cookie_found_https := true;
                    IF cookie_value_text LIKE '%Secure%' THEN
                        refresh_cookie_is_secure := true;
                    END IF;
                END IF;
            END IF;
        END LOOP;
        ASSERT access_cookie_found_https, 'Access cookie from HTTPS refresh should be set';
        ASSERT refresh_cookie_found_https, 'Refresh cookie from HTTPS refresh should be set';
        ASSERT access_cookie_is_secure, 'Access cookie from HTTPS refresh should have Secure flag';
        ASSERT refresh_cookie_is_secure, 'Refresh cookie from HTTPS refresh should have Secure flag';
    END;
    
    -- Verify refresh result contains expected fields for HTTPS refresh
    ASSERT refresh_result ? 'access_jwt', 'Refresh result should contain access_jwt';
    ASSERT refresh_result ? 'refresh_jwt', 'Refresh result should contain refresh_jwt';
    ASSERT refresh_result ? 'uid', 'Refresh result should contain user_id';
    ASSERT refresh_result ? 'role', 'Refresh result should contain role';
    ASSERT refresh_result ? 'statbus_role', 'Refresh result should contain statbus_role';
    ASSERT refresh_result ? 'email', 'Refresh result should contain email';
        
    -- Debug information to help identify token issues
    RAISE DEBUG 'Original access token: %', login_result->>'access_jwt';
    RAISE DEBUG 'New access token: %', refresh_result->>'access_jwt';
    
    -- Decode tokens to compare their contents
    DECLARE
        login_access_jwt_payload jsonb;
        refresh_access_jwt_payload jsonb;
        login_access_jwt_verification record;
        refresh_access_jwt_verification record;
    BEGIN
        -- Decode the tokens
        SELECT * INTO login_access_jwt_verification FROM verify(login_result->>'access_jwt', 'test-jwt-secret-for-testing-only', 'HS256');
        SELECT * INTO refresh_access_jwt_verification FROM verify(refresh_result->>'access_jwt', 'test-jwt-secret-for-testing-only', 'HS256');
        
        -- Convert payloads to jsonb
        login_access_jwt_payload := login_access_jwt_verification.payload::jsonb;
        refresh_access_jwt_payload := refresh_access_jwt_verification.payload::jsonb;
        
        -- Debug the token payloads
        RAISE DEBUG 'Original access jwt payload: %', login_access_jwt_payload;
        RAISE DEBUG 'New access jwt payload: %', refresh_access_jwt_payload;
        
        -- Verify token properties
        -- Check that exp (expiration time) increases
        ASSERT (refresh_access_jwt_payload->>'exp')::numeric > (login_access_jwt_payload->>'exp')::numeric,
            'New access jwt should have a later expiration time';
            
        -- Check that iat (issued at time) increases or stays the same
        ASSERT (refresh_access_jwt_payload->>'iat')::numeric >= (login_access_jwt_payload->>'iat')::numeric,
            'New access jwt should have same or later issued at time';
            
        -- Check that sub (subject) remains the same
        ASSERT refresh_access_jwt_payload->>'sub' = login_access_jwt_payload->>'sub',
            'Subject should remain the same across token refreshes';
            
        -- Check that jti (JWT ID) is different for access tokens
        -- Access tokens should have unique JTIs
        ASSERT refresh_access_jwt_payload->>'jti' <> login_access_jwt_payload->>'jti',
            'Access tokens should have different JTIs';
            
        -- Check that fixed value fields remain the same
        ASSERT refresh_access_jwt_payload->>'role' = login_access_jwt_payload->>'role',
            'Role should remain the same';
        ASSERT refresh_access_jwt_payload->>'email' = login_access_jwt_payload->>'email',
            'Email should remain the same';
        ASSERT refresh_access_jwt_payload->>'type' = login_access_jwt_payload->>'type',
            'Token type should remain the same';
        ASSERT refresh_access_jwt_payload->>'statbus_role' = login_access_jwt_payload->>'statbus_role',
            'Statbus role should remain the same';
    END;
    
    -- Compare tokens
    ASSERT refresh_result->>'access_jwt' <> login_result->>'access_jwt', 'New access token should be different';
    ASSERT refresh_result->>'refresh_jwt' <> login_result->>'refresh_jwt', 'New refresh token should be different';
    
    -- Verify session was updated (HTTPS refresh)
    SELECT rs.* INTO refresh_session_after
    FROM auth.refresh_session rs
    JOIN auth.user u ON rs.user_id = u.id
    WHERE u.email = 'test.admin@statbus.org' AND rs.jti = (refresh_session_before.jti) -- ensure we are checking the same session
    LIMIT 1; -- jti is unique, so limit 1 is fine

    ASSERT FOUND, format('Failed to find session after HTTPS refresh for JTI %L. Session before: %L. Current request headers: %L', refresh_session_before.jti, row_to_json(refresh_session_before), current_setting('request.headers', true)::jsonb);
    
    ASSERT refresh_session_after.refresh_version = refresh_session_before.refresh_version + 1, 
        format('Session version mismatch (HTTPS refresh). Expected: %s, Got: %s. Session before: %L, Session after: %L. Request headers: %L', refresh_session_before.refresh_version + 1, refresh_session_after.refresh_version, row_to_json(refresh_session_before), row_to_json(refresh_session_after), current_setting('request.headers', true)::jsonb);
    ASSERT refresh_session_after.last_used_at > refresh_session_before.last_used_at, 
        format('Session last_used_at should be updated (HTTPS refresh). Before: %L (%s), After: %L (%s). Request headers: %L', refresh_session_before.last_used_at, extract(epoch from refresh_session_before.last_used_at), refresh_session_after.last_used_at, extract(epoch from refresh_session_after.last_used_at), current_setting('request.headers', true)::jsonb);
    ASSERT refresh_session_after.ip_address = '192.168.1.100'::inet, 
        format('Session IP address mismatch (HTTPS refresh). Expected: %L, Got: %L. Request headers: %L, Session record after: %L', '192.168.1.100'::inet, refresh_session_after.ip_address, current_setting('request.headers', true)::jsonb, row_to_json(refresh_session_after));
    ASSERT refresh_session_after.user_agent = 'Refresh UA HTTPS', 
        format('Session User Agent mismatch (HTTPS refresh). Expected: %L, Got: %L. Request headers: %L, Session record after: %L', 'Refresh UA HTTPS', refresh_session_after.user_agent, current_setting('request.headers', true)::jsonb, row_to_json(refresh_session_after));

    -- Store the new refresh token for the next scenario
    refresh_jwt := refresh_result->>'refresh_jwt'; 
    -- Update refresh_session_before to the state after the HTTPS refresh for the next comparison
    refresh_session_before := refresh_session_after;

    RAISE NOTICE '--- Test 5.2: Refresh with HTTP headers ---';
    PERFORM pg_sleep(1); -- Ensure time progresses for new token iat

    -- Set cookies for the next refresh call (using the latest refresh_jwt)
    PERFORM set_config('request.cookies', 
        json_build_object('statbus-refresh', refresh_jwt)::text, true);
    -- Set headers for HTTP refresh call
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '172.16.0.5',     -- Different IP for HTTP refresh
            'user-agent', 'Refresh UA HTTP',    -- Different UA
            'x-forwarded-proto', 'http'         -- Simulate HTTP for refresh
        )::text, 
        true
    );
    -- Clear response headers before refresh call (as refresh() sets cookies)
    PERFORM set_config('response.headers', '[]'::text, true); 

    SELECT to_json(source.*) INTO refresh_result FROM public.refresh() AS source;
    RAISE DEBUG 'Refresh result (HTTP): %', refresh_result;

    DECLARE
        response_headers_http_refresh jsonb;
        header_obj_http jsonb;
        access_cookie_is_not_secure boolean := false;
        refresh_cookie_is_not_secure boolean := false;
        access_cookie_found_http boolean := false;
        refresh_cookie_found_http boolean := false;
        cookie_value_text_http text;
    BEGIN
        response_headers_http_refresh := nullif(current_setting('response.headers', true), '')::jsonb;
        RAISE DEBUG 'Response headers after HTTP refresh: %', response_headers_http_refresh;
        ASSERT response_headers_http_refresh IS NOT NULL, 'Response headers should not be null after HTTP refresh';

        FOR header_obj_http IN SELECT * FROM jsonb_array_elements(response_headers_http_refresh) LOOP
            IF header_obj_http ? 'Set-Cookie' THEN
                cookie_value_text_http := header_obj_http->>'Set-Cookie';
                IF cookie_value_text_http LIKE 'statbus=%' THEN
                    access_cookie_found_http := true;
                    IF cookie_value_text_http NOT LIKE '%Secure%' THEN
                        access_cookie_is_not_secure := true;
                    END IF;
                END IF;
                IF cookie_value_text_http LIKE 'statbus-refresh=%' THEN
                    refresh_cookie_found_http := true;
                    IF cookie_value_text_http NOT LIKE '%Secure%' THEN
                        refresh_cookie_is_not_secure := true;
                    END IF;
                END IF;
            END IF;
        END LOOP;
        ASSERT access_cookie_found_http, 'Access cookie from HTTP refresh should be set';
        ASSERT refresh_cookie_found_http, 'Refresh cookie from HTTP refresh should be set';
        ASSERT access_cookie_is_not_secure, 'Access cookie from HTTP refresh should NOT have Secure flag';
        ASSERT refresh_cookie_is_not_secure, 'Refresh cookie from HTTP refresh should NOT have Secure flag';
    END;

    -- Verify session was updated (HTTP refresh)
    SELECT rs.* INTO refresh_session_after
    FROM auth.refresh_session rs
    WHERE rs.jti = (refresh_session_before.jti) -- refresh_session_before now holds state after HTTPS refresh
    LIMIT 1;

    ASSERT FOUND, format('Failed to find session after HTTP refresh for JTI %L. Session before HTTP refresh: %L. Current request headers: %L', refresh_session_before.jti, row_to_json(refresh_session_before), current_setting('request.headers', true)::jsonb);
    
    ASSERT refresh_session_after.refresh_version = refresh_session_before.refresh_version + 1, 
        format('Session version mismatch (HTTP refresh). Expected: %s, Got: %s. Session before HTTP refresh: %L, Session after: %L. Request headers: %L', refresh_session_before.refresh_version + 1, refresh_session_after.refresh_version, row_to_json(refresh_session_before), row_to_json(refresh_session_after), current_setting('request.headers', true)::jsonb);
    ASSERT refresh_session_after.last_used_at > refresh_session_before.last_used_at, 
        format('Session last_used_at should be updated (HTTP refresh). Before: %L (%s), After: %L (%s). Request headers: %L', refresh_session_before.last_used_at, extract(epoch from refresh_session_before.last_used_at), refresh_session_after.last_used_at, extract(epoch from refresh_session_after.last_used_at), current_setting('request.headers', true)::jsonb);
    ASSERT refresh_session_after.ip_address = '172.16.0.5'::inet, 
        format('Session IP address mismatch (HTTP refresh). Expected: %L, Got: %L. Request headers: %L, Session record after: %L', '172.16.0.5'::inet, refresh_session_after.ip_address, current_setting('request.headers', true)::jsonb, row_to_json(refresh_session_after));
    ASSERT refresh_session_after.user_agent = 'Refresh UA HTTP', 
        format('Session User Agent mismatch (HTTP refresh). Expected: %L, Got: %L. Request headers: %L, Session record after: %L', 'Refresh UA HTTP', refresh_session_after.user_agent, current_setting('request.headers', true)::jsonb, row_to_json(refresh_session_after));

    -- Final auth status check with the latest tokens from HTTP refresh
    RAISE NOTICE '--- Test 5.3: Final Auth Status Check ---';
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus', refresh_result->>'access_jwt',
            'statbus-refresh', refresh_result->>'refresh_jwt'
        )::text, 
        true
    );
    -- Use headers corresponding to the last refresh (HTTP)
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '172.16.0.5', 
            'user-agent', 'Refresh UA HTTP',
            'x-forwarded-proto', 'http' 
        )::text, 
        true
    );
    PERFORM set_config('request.jwt.claims', '', true);
    
    SELECT to_json(source.*) INTO auth_status_after FROM public.auth_status() AS source;
    RAISE DEBUG 'Auth status after all refreshes: %', auth_status_after;
    ASSERT auth_status_after->>'is_authenticated' = 'true', 'Final auth status should show authenticated';
    ASSERT auth_status_after->>'email' = 'test.admin@statbus.org', 'Final auth status should have correct email';
    
        RAISE NOTICE 'Test 5: Token Refresh (including header variations) - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 5 (Token Refresh) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 5 (Token Refresh) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  --- Test 5.1: Refresh with HTTPS headers ---
NOTICE:  --- Test 5.2: Refresh with HTTP headers ---
NOTICE:  --- Test 5.3: Final Auth Status Check ---
NOTICE:  Test 5: Token Refresh (including header variations) - PASSED
-- Test 6: Logout
\echo '=== Test 6: Logout ==='
=== Test 6: Logout ===
DO $$
DECLARE
    login_result jsonb;
    logout_result jsonb;
    session_count_before integer;
    session_count_after integer;
    has_cleared_access_cookie boolean := false;
    has_cleared_refresh_cookie boolean := false;
    cookies record;
    access_jwt text;
    refresh_jwt text;
    auth_status_before jsonb;
    auth_status_after jsonb;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Set up headers to simulate a browser
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );

    -- First login to create a session
    SELECT to_json(source.*) INTO login_result FROM public.login('test.restricted@statbus.org', 'Restricted#123!') AS source;
    RAISE DEBUG 'Login result: %', login_result;
    
    -- Extract tokens from login result
    access_jwt := login_result->>'access_jwt';
    refresh_jwt := login_result->>'refresh_jwt';
    
    -- Debug the returned headers from the login function
    RAISE DEBUG 'Response headers after login: %', nullif(current_setting('response.headers', true), '')::jsonb;
    
    -- Count sessions before logout
    SELECT COUNT(*) INTO session_count_before
    FROM auth.refresh_session rs
    JOIN auth.user u ON rs.user_id = u.id
    WHERE u.email = 'test.restricted@statbus.org';
    
    RAISE DEBUG 'Session count before logout: %', session_count_before;
    
    -- Check auth status before logout
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus', access_jwt,
            'statbus-refresh', refresh_jwt
        )::text, 
        true
    );
    
    -- Also set headers for completeness
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );
    
    -- Reset JWT claims to ensure we're using cookies
    PERFORM set_config('request.jwt.claims', '', true);
    
    -- Get auth status before logout
    SELECT to_json(source.*) INTO auth_status_before FROM public.auth_status() AS source;
    RAISE DEBUG 'Auth status before logout: %', auth_status_before;
    
    -- Verify auth status before logout
    ASSERT auth_status_before->>'is_authenticated' = 'true', 'Auth status should show authenticated';
    ASSERT auth_status_before->'uid' IS NOT NULL, 'Auth status should include user info';
    ASSERT auth_status_before->>'email' = 'test.restricted@statbus.org', 'Auth status should have correct email';
    
    -- Set cookies to simulate browser cookies for logout
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus', access_jwt,
            'statbus-refresh', refresh_jwt
        )::text, 
        true
    );
    
    -- Also set headers for completeness
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );
    
    -- Perform logout
    SELECT to_json(source.*) INTO logout_result FROM public.logout() AS source;
    RAISE DEBUG 'Logout result: %', logout_result;
    
    -- Debug the returned headers from the logout function
    RAISE DEBUG 'Response headers after logout: %', nullif(current_setting('response.headers', true), '')::jsonb;
    
    -- Verify logout result
    ASSERT logout_result->>'success' = 'true', 'Logout should return success: true';
    
    -- Count sessions after logout
    SELECT COUNT(*) INTO session_count_after
    FROM auth.refresh_session rs
    JOIN auth.user u ON rs.user_id = u.id
    WHERE u.email = 'test.restricted@statbus.org';
    
    RAISE DEBUG 'Session count after logout: %', session_count_after;
    
    -- Verify exactly one session was deleted
    ASSERT session_count_after = session_count_before - 1, 
        format('Exactly one session should be deleted after logout. Before: %s, After: %s', session_count_before, session_count_after);
    
    -- Verify cookies were cleared
    FOR cookies IN SELECT * FROM test.extract_cookies()
    LOOP
        RAISE DEBUG 'Cookie found: name=%, value=%, expires=%', cookies.cookie_name, cookies.cookie_value, cookies.expires_at;
        IF cookies.cookie_name = 'statbus' AND 
           (cookies.cookie_value = '' OR cookies.expires_at = '1970-01-01 00:00:00+00'::timestamptz) THEN
            has_cleared_access_cookie := true;
        ELSIF cookies.cookie_name = 'statbus-refresh' AND 
              (cookies.cookie_value = '' OR cookies.expires_at = '1970-01-01 00:00:00+00'::timestamptz) THEN
            has_cleared_refresh_cookie := true;
        END IF;
    END LOOP;
    
    ASSERT has_cleared_access_cookie, 'Access cookie was not cleared';
    ASSERT has_cleared_refresh_cookie, 'Refresh cookie was not cleared';
    
    -- Check auth status after logout
    -- Use the cleared cookies
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus', '',
            'statbus-refresh', ''
        )::text, 
        true
    );
    
    -- Also set headers for completeness
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );
    
    -- Reset JWT claims to ensure we're using cookies
    PERFORM set_config('request.jwt.claims', '', true);
    
    -- Get auth status after logout
    SELECT to_json(source.*) INTO auth_status_after FROM public.auth_status() AS source;
    RAISE DEBUG 'Auth status after logout: %', auth_status_after;
    
    -- Verify auth status after logout
    ASSERT auth_status_after->>'is_authenticated' = 'false', 'Auth status should show not authenticated';
    ASSERT auth_status_after->>'uid' IS NULL, 'Auth status should not include user info';
    ASSERT auth_status_after->>'email' IS NULL, 'Auth status should not have email';
    
        RAISE NOTICE 'Test 6: Logout - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 6 (Logout) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 6 (Logout) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 6: Logout - PASSED
-- Test 7: Role Management
\echo '=== Test 7: Role Management ==='
=== Test 7: Role Management ===
DO $$
DECLARE
    login_result jsonb;
    grant_result RECORD;
    revoke_result boolean;
    user_sub uuid;
    original_role public.statbus_role;
    new_role public.statbus_role;
    access_jwt text;
    user_email text;
    role_exists boolean;
    role_granted boolean;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Set up headers to simulate a browser
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );

    -- Get user sub and original role for the target user
    SELECT sub, statbus_role, email INTO user_sub, original_role, user_email
    FROM auth.user
    WHERE email = 'test.external@statbus.org';
    
    RAISE DEBUG 'Testing role management for user: % (sub: %, original role: %)', 
        user_email, user_sub, original_role;
    
    -- Check if the user role exists in PostgreSQL
    SELECT EXISTS (
        SELECT 1 FROM pg_roles WHERE rolname = user_email
    ) INTO role_exists;
    
    RAISE DEBUG 'User role exists in PostgreSQL: %', role_exists;
    
    -- Check current role grants
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = original_role::text AND r2.rolname = user_email
    ) INTO role_granted;
    
    RAISE DEBUG 'Original role % is granted to user %: %', 
        original_role, user_email, role_granted;
    
    -- First login as admin to get valid JWT
    SELECT to_json(source.*) INTO login_result FROM public.login('test.admin@statbus.org', 'Admin#123!') AS source;
    RAISE DEBUG 'Login result: %', login_result;
    
    -- Extract access token from login result
    access_jwt := login_result->>'access_jwt';
    
    -- Set up JWT claims using the actual token
    PERFORM set_config('request.jwt.claims', 
        (SELECT payload::text FROM verify(access_jwt, 'test-jwt-secret-for-testing-only')),
        true
    );
    
    -- Set cookies to simulate browser cookies
    PERFORM set_config('request.cookies', 
        jsonb_build_object(
            'statbus', access_jwt
        )::text, 
        true
    );
    
    -- Also set headers for completeness
    PERFORM set_config('request.headers', 
        jsonb_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent'
        )::text, 
        true
    );
    
    -- Check if restricted_user role exists
    SELECT EXISTS (
        SELECT 1 FROM pg_roles WHERE rolname = 'restricted_user'
    ) INTO role_exists;
    
    RAISE DEBUG 'restricted_user role exists in PostgreSQL: %', role_exists;
    
    -- Check if restricted_user is already granted to the user
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'restricted_user' AND r2.rolname = user_email
    ) INTO role_granted;
    
    RAISE DEBUG 'restricted_user role is already granted to user %: %', 
        user_email, role_granted;
    
    -- Grant restricted_user role
    RAISE DEBUG 'Attempting to grant restricted_user role to %', user_email;
    UPDATE public.user
    SET statbus_role = 'restricted_user'::public.statbus_role
    WHERE sub = user_sub
    RETURNING * INTO grant_result;
    RAISE DEBUG 'Grant result: %', to_jsonb(grant_result);
    
    -- Check if the role was actually granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'restricted_user' AND r2.rolname = user_email
    ) INTO role_granted;
    
    RAISE DEBUG 'After grant: restricted_user role is granted to user %: %', 
        user_email, role_granted;
    
    -- Verify grant was successful
    ASSERT grant_result.statbus_role = 'restricted_user', 'Grant role should return true';
    
    -- Verify role was updated in database
    SELECT statbus_role INTO new_role
    FROM auth.user
    WHERE sub = user_sub;
    
    RAISE DEBUG 'User role in database after grant: %', new_role;
    
    ASSERT new_role = 'restricted_user', 
        'User role should be updated to restricted_user';
    
    -- Check if regular_user role exists
    SELECT EXISTS (
        SELECT 1 FROM pg_roles WHERE rolname = 'regular_user'
    ) INTO role_exists;
    
    RAISE DEBUG 'regular_user role exists in PostgreSQL: %', role_exists;
    
    -- Check if regular_user is already granted to the user
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'regular_user' AND r2.rolname = user_email
    ) INTO role_granted;
    
    RAISE DEBUG 'regular_user role is already granted to user %: %', 
        user_email, role_granted;
    
    -- Revoke role (which sets it back to regular_user)
    RAISE DEBUG 'Attempting to revoke role from % (setting back to regular_user)', user_email;
    UPDATE public.user
    SET statbus_role = 'regular_user'::public.statbus_role
    WHERE sub = user_sub
    RETURNING * INTO grant_result; -- Re-using grant_result variable name for consistency
    RAISE DEBUG 'Revoke (set to regular_user) result: %', to_jsonb(grant_result);
    
    -- Check if the role was actually granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'regular_user' AND r2.rolname = user_email
    ) INTO role_granted;
    
    RAISE DEBUG 'After revoke: regular_user role is granted to user %: %', 
        user_email, role_granted;
    
    -- Verify revoke was successful
    ASSERT grant_result.statbus_role = 'regular_user', 'Revoke role (set to regular_user) should return true and correct role';
    
    -- Verify role was reset to regular_user
    SELECT statbus_role INTO new_role
    FROM auth.user
    WHERE sub = user_sub;
    
    RAISE DEBUG 'User role in database after revoke: %', new_role;
    
    ASSERT new_role = 'regular_user', 
        'User role should be reset to regular_user';
    
    -- Reset to original role
    RAISE DEBUG 'Resetting user % to original role: %', user_email, original_role;
    UPDATE public.user
    SET statbus_role = original_role
    WHERE sub = user_sub
    RETURNING * INTO grant_result;
    RAISE DEBUG 'Reset role result: %', to_jsonb(grant_result);
    ASSERT grant_result.statbus_role = original_role, 'Resetting role should return true and correct role';
    
    -- Verify final role state
    SELECT statbus_role INTO new_role
    FROM auth.user
    WHERE sub = user_sub;
    
    RAISE DEBUG 'Final user role in database: %', new_role;
    
    -- Check if the original role was actually granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = original_role::text AND r2.rolname = user_email
    ) INTO role_granted;
    
    RAISE DEBUG 'Final check: original role % is granted to user %: %', 
        original_role, user_email, role_granted;
    
        RAISE NOTICE 'Test 7: Role Management - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 7 (Role Management) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 7 (Role Management) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 7: Role Management - PASSED
-- Test 8: Session Management
\echo '=== Test 8: Session Management ==='
=== Test 8: Session Management ===
DO $$
DECLARE
    login_result jsonb;
    sessions_result jsonb[];
    session_id integer;
    session_jti uuid;
    revoke_result boolean;
    session_count_before integer;
    session_count_after integer;
    access_jwt text;
    jwt_claims json;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Set up headers to simulate a browser
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );

    -- First login to create a session
    SELECT to_json(source.*) INTO login_result FROM public.login('test.regular@statbus.org', 'Regular#123!') AS source;
    
    -- Extract access token from login result
    access_jwt := login_result->>'access_jwt';
    
    -- Set up JWT claims using the actual token
    SELECT payload::json INTO jwt_claims 
    FROM verify(access_jwt, 'test-jwt-secret-for-testing-only');
    
    PERFORM set_config('request.jwt.claims', jwt_claims::text, true);
    
    -- Set cookies in request.cookies and headers for list_active_sessions
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus', access_jwt 
            -- list_active_sessions uses request.jwt.claims, so cookie content doesn't strictly matter here
            -- as long as claims are set.
        )::text, 
        true
    );
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );
    
    -- List active sessions
    SELECT array_agg(to_json(s.*)) INTO sessions_result
    FROM public.list_active_sessions() AS s;
    
    -- Debug the sessions result
    RAISE DEBUG 'Active sessions: %', sessions_result;
    
    -- Verify sessions were returned
    ASSERT array_length(sessions_result, 1) > 0, 'Should have at least one active session';
    
    -- Get session ID for revocation
    SELECT (sessions_result[1]->>'id')::integer INTO session_id;
    
    -- Get the JTI for the session
    SELECT jti INTO session_jti
    FROM auth.refresh_session
    WHERE id = session_id;
    
    -- Count sessions before revocation
    SELECT COUNT(*) INTO session_count_before
    FROM auth.refresh_session rs
    JOIN auth.user u ON rs.user_id = u.id
    WHERE u.email = 'test.regular@statbus.org';
    
    -- Revoke a specific session
    SELECT public.revoke_session(session_jti) INTO revoke_result;
    
    -- Debug the revoke result
    RAISE DEBUG 'Revoke session result: %', revoke_result;
    
    -- Verify revocation was successful
    ASSERT revoke_result = true, 'Revoke session should return true';
    
    -- Count sessions after revocation
    SELECT COUNT(*) INTO session_count_after
    FROM auth.refresh_session rs
    JOIN auth.user u ON rs.user_id = u.id
    WHERE u.email = 'test.regular@statbus.org';
    
    -- Verify session was deleted
    ASSERT session_count_after = session_count_before - 1, 
        'One session should be deleted after revocation';
    
        RAISE NOTICE 'Test 8: Session Management - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 8 (Session Management) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 8 (Session Management) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 8: Session Management - PASSED
-- Test 9: JWT Claims Building
\echo '=== Test 9: JWT Claims Building ==='
=== Test 9: JWT Claims Building ===
DO $$
DECLARE
    claims jsonb;
    test_email text := 'test.regular@statbus.org';
    test_sub uuid;
    test_role public.statbus_role;
    test_expires_at timestamptz;
    test_jwt text;
    jwt_payload jsonb;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Get user details
    SELECT sub, statbus_role INTO test_sub, test_role
    FROM auth.user
    WHERE email = test_email;
    
    -- Set test expiration time
    test_expires_at := clock_timestamp() + interval '1 hour';
    
    -- Build claims with email only
    claims := auth.build_jwt_claims(test_email);
    
    -- Debug the claims
    RAISE DEBUG 'Basic JWT claims: %', claims;
    
    -- Verify basic claims
    ASSERT claims ? 'role', 'Claims should contain role';
    ASSERT claims ? 'statbus_role', 'Claims should contain statbus_role';
    ASSERT claims ? 'sub', 'Claims should contain sub';
    ASSERT claims ? 'email', 'Claims should contain email';
    ASSERT claims ? 'type', 'Claims should contain type';
    ASSERT claims ? 'iat', 'Claims should contain iat';
    ASSERT claims ? 'exp', 'Claims should contain exp';
    ASSERT claims ? 'jti', 'Claims should contain jti';
    ASSERT claims ? 'uid', 'Claims should contain uid';

    -- Verify claim values
    ASSERT claims->>'role' = test_email, 'role claim should match email';
    ASSERT claims->>'statbus_role' = test_role::text, 'statbus_role claim should match user role';
    ASSERT claims->>'sub' = test_sub::text, 'sub claim should match user sub';
    ASSERT claims->>'email' = test_email, 'email claim should match email';
    ASSERT claims->>'type' = 'access', 'type claim should be access by default';
    
    -- Build claims with additional parameters
    claims := auth.build_jwt_claims(
        p_email => test_email,
        p_type => 'refresh',
        p_expires_at => test_expires_at,
        p_additional_claims => jsonb_build_object('custom_claim', 'test_value')
    );
    
    -- Debug the claims with additional parameters
    RAISE DEBUG 'Advanced JWT claims: %', claims;
    
    -- Verify additional parameters
    ASSERT claims->>'type' = 'refresh', 'type claim should be refresh';
    ASSERT claims->>'custom_claim' = 'test_value', 'custom claim should be included';
    ASSERT (claims->>'exp')::numeric = extract(epoch from test_expires_at)::integer, 
        'exp claim should match provided expiration time';
    
    -- Test generating a JWT from claims
    SELECT auth.generate_jwt(claims) INTO test_jwt;
    
    -- Debug the generated JWT
    RAISE DEBUG 'Generated JWT: %', test_jwt;
    
    -- Verify the JWT can be decoded
    SELECT payload::jsonb INTO jwt_payload 
    FROM verify(test_jwt, 'test-jwt-secret-for-testing-only');
    
    -- Debug the decoded JWT payload
    RAISE DEBUG 'Decoded JWT payload: %', jwt_payload;
    
    -- Verify JWT payload matches claims
    ASSERT jwt_payload->>'role' = claims->>'role', 'JWT role should match claims';
    ASSERT jwt_payload->>'type' = 'refresh', 'JWT type should be refresh';
    ASSERT jwt_payload->>'custom_claim' = 'test_value', 'JWT should include custom claims';

        RAISE NOTICE 'Test 9: JWT Claims Building - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 9 (JWT Claims Building) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 9 (JWT Claims Building) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 9: JWT Claims Building - PASSED
-- Test 10: JWT Tampering Detection
\echo '=== Test 10: JWT Tampering Detection ==='
=== Test 10: JWT Tampering Detection ===
DO $$
DECLARE
    login_result_admin jsonb;
    login_result_regular jsonb;
    tampered_access_jwt text;
    tampered_refresh_jwt text;
    tampered_claims jsonb;
    refresh_result jsonb;
    auth_status_result jsonb;
    admin_email text := 'test.admin@statbus.org';
    regular_email text := 'test.regular@statbus.org';
    admin_access_jwt text;
    admin_refresh_jwt text;
    regular_access_jwt text;
    admin_claims jsonb;
    regular_claims jsonb;
    random_jti uuid := gen_random_uuid();
    wrong_secret text := 'wrong-jwt-secret-for-testing-only';
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Set up headers to simulate a browser
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );

    -- First login as admin to get valid tokens
    SELECT to_json(source.*) INTO login_result_admin FROM public.login(admin_email, 'Admin#123!') AS source;
    admin_access_jwt := login_result_admin->>'access_jwt';
    admin_refresh_jwt := login_result_admin->>'refresh_jwt';
    
    -- Get admin token claims
    SELECT payload::jsonb INTO admin_claims 
    FROM verify(admin_access_jwt, 'test-jwt-secret-for-testing-only');
    
    -- Login as regular user to get valid tokens
    SELECT to_json(source.*) INTO login_result_regular FROM public.login(regular_email, 'Regular#123!') AS source;
    regular_access_jwt := login_result_regular->>'access_jwt';
    
    -- Get regular user token claims
    SELECT payload::jsonb INTO regular_claims 
    FROM verify(regular_access_jwt, 'test-jwt-secret-for-testing-only');
    
    -- Test 1: Tamper with access JWT to change role without changing signature
    -- This simulates a user trying to elevate privileges by modifying the token payload
    -- without knowing the JWT secret (which would be required to create a valid signature)
    -- Approach 1: Change the payload but keep the original (now invalid) signature
    DECLARE
        tampered_access_payload jsonb;
    BEGIN
        -- Create tampered claims by changing role from regular to admin
        -- but keeping the same signature (which will now be invalid)
        tampered_access_payload := jsonb_set(
            regular_claims,
            '{role}',
            to_jsonb(admin_email::text)
        );
        tampered_access_payload := jsonb_set(
            tampered_access_payload,
            '{statbus_role}',
            to_jsonb('admin_user'::public.statbus_role)
        );
        
        -- Manually construct a tampered JWT with invalid signature
        -- Format: base64(header).base64(tampered_payload).original_signature
        DECLARE
            header text;
            payload text;
            signature text;
            parts text[];
        BEGIN
            -- Split the original token
            parts := string_to_array(regular_access_jwt, '.');
            header := parts[1];
            signature := parts[3];
            
            -- Use the same base64url encoding that pgjwt uses
            -- This ensures compatibility with the verify function
            SELECT url_encode(convert_to(tampered_access_payload::text, 'UTF8')) INTO payload;
            
            -- Construct the tampered token
            tampered_access_jwt := header || '.' || payload || '.' || signature;
        END;
        
        -- Set the tampered token in the JWT claims
        BEGIN
            -- This should fail because the signature is now invalid
            PERFORM set_config('request.jwt.claims', 
                (SELECT payload::text FROM verify(tampered_access_jwt, 'test-jwt-secret-for-testing-only')),
                true
            );
            
            -- If we get here, the verification didn't fail as expected
            RAISE EXCEPTION 'Tampered access token was incorrectly verified as valid';
        EXCEPTION WHEN OTHERS THEN
            -- This is expected - the token should be rejected
            RAISE DEBUG 'Tampered access token was correctly rejected: %', SQLERRM;
        END;
    END;
    
    -- Test 2: Try to create a token with an incorrect JWT secret
    -- This simulates an attacker who doesn't know the real JWT secret but tries to forge a token
    DECLARE
        forged_payload jsonb;
        forged_jwt text;
        forged_result jsonb;
    BEGIN
        -- Create a payload with admin privileges
        forged_payload := jsonb_build_object(
            'role', admin_email,
            'statbus_role', 'admin_user',
            'email', admin_email,
            'sub', (SELECT sub::text FROM auth.user WHERE email = admin_email),
            'type', 'access',
            'iat', extract(epoch from clock_timestamp())::integer,
            'exp', extract(epoch from clock_timestamp() + interval '1 hour')::integer,
            'jti', gen_random_uuid()
        );
        
        -- Sign the payload with the wrong secret
        -- This simulates an attacker trying to forge a token without knowing the real secret
        forged_jwt := sign(
            forged_payload::json, 
            wrong_secret,  -- Using wrong secret here
            'HS256'
        );
        
        -- Debug the forged token
        RAISE DEBUG 'Forged JWT with wrong secret: %', forged_jwt;
        
        -- Set the forged token in the JWT claims
        BEGIN
            -- This should fail because the signature is invalid
            PERFORM set_config('request.jwt.claims', 
                (SELECT payload::text FROM verify(forged_jwt, 'test-jwt-secret-for-testing-only')),
                true
            );
            
            -- If we get here, the verification didn't fail as expected
            RAISE EXCEPTION 'Forged token with wrong secret was incorrectly verified as valid';
        EXCEPTION WHEN OTHERS THEN
            -- This is expected - the token should be rejected
            RAISE DEBUG 'Forged token with wrong secret was correctly rejected: %', SQLERRM;
        END;
    END;
    
    -- Test 3: Try to use a refresh token with a non-existent session JTI
    DECLARE
        tampered_refresh_payload jsonb;
        tampered_refresh_result jsonb;
    BEGIN
        -- Create tampered claims by changing the JTI to a random UUID
        tampered_refresh_payload := jsonb_set(
            (SELECT payload::jsonb FROM verify(admin_refresh_jwt, 'test-jwt-secret-for-testing-only')),
            '{jti}',
            to_jsonb(random_jti::text)
        );
        
        -- Manually construct a tampered JWT with valid signature but non-existent session
        DECLARE
            header text;
            payload text;
            signature text;
            parts text[];
        BEGIN
            -- Split the original token
            parts := string_to_array(admin_refresh_jwt, '.');
            header := parts[1];
            
            -- Use the same base64url encoding that pgjwt uses
            -- This ensures compatibility with the verify function
            SELECT url_encode(convert_to(tampered_refresh_payload::text, 'UTF8')) INTO payload;
            
            -- Use the original signature from the valid token
            -- This simulates an attacker who doesn't know the secret
            -- They can only modify the payload but can't create a valid signature
            signature := parts[3];
            
            -- Construct the tampered token
            tampered_refresh_jwt := header || '.' || payload || '.' || signature;
        END;
        
        -- Set cookies with the tampered refresh token
        PERFORM set_config('request.cookies', 
            jsonb_build_object(
                'statbus-refresh', tampered_refresh_jwt
            )::text, 
            true
        );
    
        -- Also set headers for completeness
        PERFORM set_config('request.headers', 
            jsonb_build_object(
                'x-forwarded-for', '127.0.0.1',
                'user-agent', 'Test User Agent'
            )::text, 
            true
        );
        
        -- Try to refresh with the tampered token
        BEGIN
            SELECT to_json(source.*) INTO tampered_refresh_result FROM public.refresh() AS source;
            -- If we get here, the refresh didn't fail as expected
            RAISE EXCEPTION 'Refresh with non-existent session should have failed';
        EXCEPTION WHEN OTHERS THEN
            -- This is expected - the token should be rejected
            tampered_refresh_result := jsonb_build_object('error', SQLERRM);
            RAISE DEBUG 'Refresh with non-existent session correctly failed: %', SQLERRM;
        END;
        
        -- Debug the result
        RAISE DEBUG 'Refresh result with non-existent session: %', tampered_refresh_result;
        
        -- Verify the refresh was rejected
        ASSERT tampered_refresh_result ? 'error', 
            'Refresh with non-existent session should return an error';
    END;
    
    -- Test 4: Try to impersonate another user with a valid refresh token
    DECLARE
        impersonation_payload jsonb;
        impersonation_jwt text;
        impersonation_result jsonb;
    BEGIN
        -- Get a valid refresh token for admin
        SELECT payload::jsonb INTO impersonation_payload 
        FROM verify(admin_refresh_jwt, 'test-jwt-secret-for-testing-only');
        
        -- Modify the token to change the user (sub) while keeping the same session
        impersonation_payload := jsonb_set(
            impersonation_payload,
            '{sub}',
            to_jsonb((SELECT sub::text FROM auth.user WHERE email = 'test.restricted@statbus.org'))
        );
        impersonation_payload := jsonb_set(
            impersonation_payload,
            '{email}',
            to_jsonb('test.restricted@statbus.org'::text)
        );
        impersonation_payload := jsonb_set(
            impersonation_payload,
            '{role}',
            to_jsonb('test.restricted@statbus.org'::text)
        );
        
        -- Manually construct a tampered JWT with valid signature
        DECLARE
            header text;
            payload text;
            signature text;
            parts text[];
        BEGIN
            -- Split the original token
            parts := string_to_array(admin_refresh_jwt, '.');
            header := parts[1];
            
            -- Use the same base64url encoding that pgjwt uses
            -- This ensures compatibility with the verify function
            SELECT url_encode(convert_to(impersonation_payload::text, 'UTF8')) INTO payload;
            
            -- Use the original signature from the valid token
            -- This simulates an attacker who doesn't know the secret
            -- They can only modify the payload but can't create a valid signature
            signature := parts[3];
            
            -- Construct the tampered token
            impersonation_jwt := header || '.' || payload || '.' || signature;
        END;
        
        -- Set cookies with the tampered refresh token
        PERFORM set_config('request.cookies', 
            jsonb_build_object(
                'statbus-refresh', impersonation_jwt
            )::text, 
            true
        );
    
        -- Also set headers for completeness
        PERFORM set_config('request.headers', 
            jsonb_build_object(
                'x-forwarded-for', '127.0.0.1',
                'user-agent', 'Test User Agent'
            )::text, 
            true
        );
        
        -- Try to refresh with the tampered token
        BEGIN
            SELECT to_json(source.*) INTO impersonation_result FROM public.refresh() AS source;
            -- If we get here, the refresh didn't fail as expected
            RAISE EXCEPTION 'Refresh with impersonation attempt should have failed';
        EXCEPTION WHEN OTHERS THEN
            -- This is expected - the token should be rejected
            impersonation_result := jsonb_build_object('error', SQLERRM);
            RAISE DEBUG 'Refresh with impersonation attempt correctly failed: %', SQLERRM;
        END;
        
        -- Debug the result
        RAISE DEBUG 'Refresh result with impersonation attempt: %', impersonation_result;
        
        -- Verify the refresh was rejected
        ASSERT impersonation_result ? 'error', 
            'Refresh with impersonation attempt should return an error';
    END;
    
        RAISE NOTICE 'Test 10: JWT Tampering Detection - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 10 (JWT Tampering Detection) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 10 (JWT Tampering Detection) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 10: JWT Tampering Detection - PASSED
-- Test 11: Auth Status Function
\echo '=== Test 11: Auth Status Function ==='
=== Test 11: Auth Status Function ===
DO $$
DECLARE
    login_result jsonb;
    auth_status_result jsonb;
    auth_status_unauthenticated jsonb;
    access_jwt text;
    refresh_jwt text;
    jwt_claims json;
    test_email text := 'test.admin@statbus.org';
    test_sub uuid;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Set up headers to simulate a browser
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );

    -- Get user details for verification
    SELECT sub INTO test_sub
    FROM auth.user
    WHERE email = test_email;
    
    -- First check unauthenticated status (no cookies)
    PERFORM set_config('request.cookies', '{}', true);
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );
    PERFORM set_config('request.jwt.claims', '', true);
    
    SELECT to_json(source.*) INTO auth_status_unauthenticated FROM public.auth_status() AS source;
    
    -- Debug the unauthenticated status
    RAISE DEBUG 'Auth status (unauthenticated): %', auth_status_unauthenticated;
    
    -- Verify unauthenticated status
    ASSERT auth_status_unauthenticated->>'is_authenticated' = 'false', 'Auth status should show not authenticated';
    ASSERT auth_status_unauthenticated->>'uid' IS NULL, 'Auth status should not include user info';
    ASSERT auth_status_unauthenticated->>'email' IS NULL, 'Auth status should not have email';
    
    -- Now login to get a valid token
    SELECT to_json(source.*) INTO login_result FROM public.login(test_email, 'Admin#123!') AS source;
    
    -- Extract tokens from login result
    access_jwt := login_result->>'access_jwt';
    refresh_jwt := login_result->>'refresh_jwt';
    
    -- Set up cookies to simulate browser cookies
    PERFORM set_config('request.cookies', 
        json_build_object(
            'statbus', access_jwt,
            'statbus-refresh', refresh_jwt
        )::text, 
        true
    );
    
    -- Also set headers for completeness
    PERFORM set_config('request.headers', 
        json_build_object(
            'x-forwarded-for', '127.0.0.1',
            'user-agent', 'Test User Agent',
            'x-forwarded-proto', 'https' -- Simulate HTTPS
        )::text, 
        true
    );
    
    -- Reset JWT claims to ensure we're using cookies
    PERFORM set_config('request.jwt.claims', '', true);
    
    -- Check authenticated status using cookies
    SELECT to_json(source.*) INTO auth_status_result FROM public.auth_status() AS source;
    
    -- Debug the authenticated status
    RAISE DEBUG 'Auth status (authenticated via cookies): %', auth_status_result;
    
    -- Verify authenticated status
    ASSERT auth_status_result->>'is_authenticated' = 'true', 'Auth status should show authenticated';
    ASSERT auth_status_result->'uid' IS NOT NULL, 'Auth status should include user info';
    ASSERT auth_status_result->>'email' = test_email, 'Auth status should have correct email';
    
    -- Test with an expiring token (modify the token to make it expire soon)
    DECLARE
        expiring_claims json;
        expiring_jwt text;
        expiring_status jsonb;
    BEGIN
        -- Get the claims from the token
        SELECT payload::json INTO jwt_claims 
        FROM verify(access_jwt, 'test-jwt-secret-for-testing-only');
        
        -- Create a copy of the claims with an expiration time 4 minutes from now
        expiring_claims := jsonb_set(
            jwt_claims::jsonb, 
            '{exp}', 
            to_jsonb(extract(epoch from now())::integer + 240)
        )::json;
        
        -- Create a new token with the modified claims
        SELECT sign(expiring_claims, 'test-jwt-secret-for-testing-only') INTO expiring_jwt;
        
        -- Set the cookie with the expiring token
        PERFORM set_config('request.cookies', 
            json_build_object(
                'statbus', expiring_jwt,
                'statbus-refresh', refresh_jwt
            )::text, 
            true
        );
        
        -- Also set headers for completeness
        PERFORM set_config('request.headers', 
            json_build_object(
                'x-forwarded-for', '127.0.0.1',
                'user-agent', 'Test User Agent',
                'x-forwarded-proto', 'https' -- Simulate HTTPS
            )::text, 
            true
        );
        
        -- Reset JWT claims to ensure we're using cookies
        PERFORM set_config('request.jwt.claims', '', true);
        
        -- Check status with expiring token
        SELECT to_json(source.*) INTO expiring_status FROM public.auth_status() AS source;
        
        -- Debug the expiring status
        RAISE DEBUG 'Auth status (expiring token): %', expiring_status;
        
        -- Verify expiring token status
        ASSERT expiring_status->>'is_authenticated' = 'true', 'Auth status should show authenticated';
        ASSERT expiring_status->'uid' IS NOT NULL, 'Auth status should include user info';
        ASSERT expiring_status->>'email' = test_email, 'Auth status should have correct email';
    END;
    
    -- Test with an invalid user sub (user not found)
    DECLARE
        invalid_claims json;
        invalid_jwt text;
        invalid_status jsonb;
        random_uuid uuid := gen_random_uuid();
    BEGIN
        -- Get the claims from the token
        SELECT payload::json INTO jwt_claims 
        FROM verify(access_jwt, 'test-jwt-secret-for-testing-only');
        
        -- Create a copy of the claims with an invalid user sub
        invalid_claims := jsonb_set(
            jwt_claims::jsonb, 
            '{sub}', 
            to_jsonb(random_uuid::text)
        )::json;
        
        -- Create a new token with the modified claims
        SELECT sign(invalid_claims, 'test-jwt-secret-for-testing-only') INTO invalid_jwt;
        
        -- Set the cookie with the invalid token
        PERFORM set_config('request.cookies', 
            json_build_object(
                'statbus', invalid_jwt,
                'statbus-refresh', refresh_jwt
            )::text, 
            true
        );
        
        -- Also set headers for completeness
        PERFORM set_config('request.headers', 
            json_build_object(
                'x-forwarded-for', '127.0.0.1',
                'user-agent', 'Test User Agent',
                'x-forwarded-proto', 'https' -- Simulate HTTPS
            )::text, 
            true
        );
        
        -- Reset JWT claims to ensure we're using cookies
        PERFORM set_config('request.jwt.claims', '', true);
        
        -- Check status with invalid user
        SELECT to_json(source.*) INTO invalid_status FROM public.auth_status() AS source;
        
        -- Debug the invalid status
        RAISE DEBUG 'Auth status (invalid user): %', invalid_status;
        
        -- Verify invalid user status
        ASSERT invalid_status->>'is_authenticated' = 'false', 'Auth status should show not authenticated';
        ASSERT invalid_status->>'uid' IS NULL, 'Auth status should not include user info';
        ASSERT invalid_status->>'email' IS NULL, 'Auth status should not have email';
    END;
    
        RAISE NOTICE 'Test 11: Auth Status Function - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 11 (Auth Status Function) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 11 (Auth Status Function) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 11: Auth Status Function - PASSED
-- Test 12: Idempotent User Creation
\echo '=== Test 12: Idempotent User Creation ==='
=== Test 12: Idempotent User Creation ===
DO $$
DECLARE
    first_creation_result record;
    second_creation_result record;
    user_count_before integer;
    user_count_after integer;
    test_email text := 'test.idempotent@example.com';
    test_password text := 'idempotent123';
    test_role public.statbus_role := 'regular_user';
    old_encrypted_password text;
    new_encrypted_password text;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Count users with this email before
    SELECT COUNT(*) INTO user_count_before
    FROM auth.user
    WHERE email = test_email;
    
    -- First creation
    SELECT * INTO first_creation_result 
    FROM public.user_create(test_email, test_role, test_password);
    
    -- Debug the first creation result
    RAISE DEBUG 'First creation result: %', first_creation_result;
    
    -- Verify first creation
    ASSERT first_creation_result.email = test_email, 'First creation should return correct email';
    ASSERT first_creation_result.password = test_password, 'First creation should return correct password';
    
    -- Verify user exists in database
    ASSERT EXISTS (
        SELECT 1 FROM auth.user WHERE email = test_email
    ), 'User should exist after first creation';
    
    -- Store the old encrypted password before updating
    SELECT encrypted_password INTO old_encrypted_password
    FROM auth.user
    WHERE email = test_email;
    RAISE DEBUG 'Old encrypted password: %', old_encrypted_password;
    
    -- Second creation with same email but different password and role
    SELECT * INTO second_creation_result 
    FROM public.user_create(test_email, 'admin_user'::public.statbus_role, 'newpassword123');
    
    -- Debug the second creation result
    RAISE DEBUG 'Second creation result: %', second_creation_result;
    
    -- Verify second creation
    ASSERT second_creation_result.email = test_email, 'Second creation should return correct email';
    ASSERT second_creation_result.password = 'newpassword123', 'Second creation should return new password';
    
    -- Count users with this email after
    SELECT COUNT(*) INTO user_count_after
    FROM auth.user
    WHERE email = test_email;
    
    -- Verify only one user exists (idempotent)
    ASSERT user_count_after = 1, 'Should still have only one user after second creation';
    
    -- Verify user was updated with new role and password
    ASSERT (
        SELECT statbus_role FROM auth.user WHERE email = test_email
    ) = 'admin_user'::public.statbus_role, 'User role should be updated';
    
    -- Verify the encrypted password has changed
    SELECT encrypted_password INTO new_encrypted_password
    FROM auth.user
    WHERE email = test_email;
    RAISE DEBUG 'New encrypted password: %', new_encrypted_password;
    
    ASSERT old_encrypted_password IS DISTINCT FROM new_encrypted_password, 
        'Encrypted password should change after update';
    
    -- Clean up
    DELETE FROM auth.user WHERE email = test_email;
    
        RAISE NOTICE 'Test 12: Idempotent User Creation - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 12 (Idempotent User Creation) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 12 (Idempotent User Creation) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 12: Idempotent User Creation - PASSED
-- Test 13: Trigger Role Change Handling
\echo '=== Test 13: Trigger Role Change Handling ==='
=== Test 13: Trigger Role Change Handling ===
DO $$
DECLARE
    test_email text := 'test.role.change@example.com';
    test_password text := 'rolechange123';
    user_sub uuid;
    role_exists boolean;
    role_granted boolean;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Create a test user with regular_user role
    PERFORM public.user_create(test_email, 'regular_user'::public.statbus_role, test_password);
    
    -- Get the user's sub
    SELECT sub INTO user_sub FROM auth.user WHERE email = test_email;
    
    -- Verify the PostgreSQL role exists
    SELECT EXISTS (
        SELECT 1 FROM pg_roles WHERE rolname = test_email
    ) INTO role_exists;
    
    ASSERT role_exists, 'PostgreSQL role should exist for the user';
    
    -- Verify regular_user role is granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'regular_user' AND r2.rolname = test_email
    ) INTO role_granted;
    
    ASSERT role_granted, 'regular_user role should be granted initially';
    
    -- Change role directly in the database (this should trigger the role change)
    UPDATE auth.user SET statbus_role = 'admin_user' WHERE email = test_email;
    
    -- Verify admin_user role is now granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'admin_user' AND r2.rolname = test_email
    ) INTO role_granted;
    
    ASSERT role_granted, 'admin_user role should be granted after update';
    
    -- Verify regular_user role is no longer granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'regular_user' AND r2.rolname = test_email
    ) INTO role_granted;
    
    ASSERT NOT role_granted, 'regular_user role should be revoked after update';
    
    -- Change to restricted_user
    UPDATE auth.user SET statbus_role = 'restricted_user' WHERE email = test_email;
    
    -- Verify restricted_user role is now granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'restricted_user' AND r2.rolname = test_email
    ) INTO role_granted;
    
    ASSERT role_granted, 'restricted_user role should be granted after update';
    
    -- Verify admin_user role is no longer granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'admin_user' AND r2.rolname = test_email
    ) INTO role_granted;
    
    ASSERT NOT role_granted, 'admin_user role should be revoked after update';
    
    -- Change to external_user
    UPDATE auth.user SET statbus_role = 'external_user' WHERE email = test_email;
    
    -- Verify external_user role is now granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'external_user' AND r2.rolname = test_email
    ) INTO role_granted;
    
    ASSERT role_granted, 'external_user role should be granted after update';
    
    -- Verify restricted_user role is no longer granted
    SELECT EXISTS (
        SELECT 1 FROM pg_auth_members m
        JOIN pg_roles r1 ON m.roleid = r1.oid
        JOIN pg_roles r2 ON m.member = r2.oid
        WHERE r1.rolname = 'restricted_user' AND r2.rolname = test_email
    ) INTO role_granted;
    
    ASSERT NOT role_granted, 'restricted_user role should be revoked after update';
    
    -- Clean up
    DELETE FROM auth.user WHERE email = test_email;
    
    -- Verify the PostgreSQL role was dropped by the delete trigger
    SELECT EXISTS (
        SELECT 1 FROM pg_roles WHERE rolname = test_email
    ) INTO role_exists;
    
    ASSERT NOT role_exists, 'PostgreSQL role should be dropped after user deletion';
    
        RAISE NOTICE 'Test 13: Trigger Role Change Handling - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 13 (Trigger Role Change Handling) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 13 (Trigger Role Change Handling) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 13: Trigger Role Change Handling - PASSED
-- Test 14: Session Context Management
\echo '=== Test 14: Session Context Management ==='
=== Test 14: Session Context Management ===
DO $$
DECLARE
    test_email text := 'test.external@statbus.org';
    claims_before text;
    claims_after text;
    claims_json jsonb;
    test_sub uuid;
    test_role public.statbus_role;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Get user details for verification
    SELECT sub, statbus_role INTO test_sub, test_role
    FROM auth.user
    WHERE email = test_email;
    
    -- Store current claims
    claims_before := current_setting('request.jwt.claims', true);
    
    -- Debug the claims before
    RAISE DEBUG 'Claims before: %', claims_before;
    
    -- Set user context from email
    PERFORM auth.set_user_context_from_email(test_email);
    
    -- Debug after setting user context
    RAISE DEBUG 'Set user context from email: %', test_email;
    
    -- Verify claims were set
    claims_after := current_setting('request.jwt.claims', true);
    claims_json := claims_after::jsonb;
    
    -- Debug the claims after
    RAISE DEBUG 'Claims after: %', claims_after;
    
    ASSERT claims_after <> claims_before, 'Claims should be updated';
    ASSERT claims_json->>'email' = test_email, 'Claims should contain the correct email';
    ASSERT claims_json->>'role' = test_email, 'Claims should set role to email';
    ASSERT claims_json->>'statbus_role' = test_role::text, 'Claims should contain correct statbus_role';
    ASSERT claims_json->>'sub' = test_sub::text, 'Claims should contain correct sub';
    ASSERT claims_json->>'type' = 'access', 'Claims should have type=access';
    ASSERT claims_json ? 'iat', 'Claims should contain iat';
    ASSERT claims_json ? 'exp', 'Claims should contain exp';
    ASSERT claims_json ? 'jti', 'Claims should contain jti';
    
    -- Test using JWT claims in session
    DECLARE
        test_claims jsonb;
    BEGIN
        test_claims := jsonb_build_object(
            'role', test_email,
            'statbus_role', test_role,
            'sub', test_sub,
            'email', test_email,
            'type', 'access',
            'iat', extract(epoch from clock_timestamp())::integer,
            'exp', extract(epoch from clock_timestamp() + interval '1 hour')::integer,
            'jti', gen_random_uuid()
        );
        
        PERFORM auth.use_jwt_claims_in_session(test_claims);
        
        -- Debug the test claims
        RAISE DEBUG 'Using test claims in session: %', test_claims;
        
        -- Verify claims were set correctly
        ASSERT (current_setting('request.jwt.claims', true)::jsonb)->>'role' = test_email, 
            'use_jwt_claims_in_session should set role correctly';
    END;
    
    -- Reset session context
    PERFORM auth.reset_session_context();
    
    -- Debug after reset
    RAISE DEBUG 'Session context after reset: %', current_setting('request.jwt.claims', true);
    
    -- Verify claims were cleared
    ASSERT current_setting('request.jwt.claims', true) = '', 
        'Claims should be cleared';
    
        RAISE NOTICE 'Test 14: Session Context Management - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 14 (Session Context Management) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 14 (Session Context Management) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 14: Session Context Management - PASSED
-- Test 15: Password Change (User)
\echo '=== Test 15: Password Change (User) ==='
=== Test 15: Password Change (User) ===
DO $$
DECLARE
    login_result jsonb;
    test_email text := 'test.regular@statbus.org';
    old_password text := 'Regular#123!'; -- Original password for test.regular@statbus.org
    new_password text := 'newRegularPass456';
    access_jwt text;
    refresh_jwt text;
    session_count_before integer;
    session_count_after integer;
    -- change_result boolean; -- This variable was declared but not used in the original 14.1
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior for the entire Test 14
        
        -- Setup part of Test 14
        RAISE NOTICE 'Test 14: Setup - Logging in user and checking initial session count.';
        SELECT to_jsonb(source.*) INTO login_result FROM public.login(test_email, old_password) AS source;
        RAISE DEBUG 'Logged in user %: %', test_email, login_result;
        ASSERT login_result IS NOT NULL AND login_result->>'access_jwt' IS NOT NULL, 'Setup: Login failed for user ' || test_email;
        access_jwt := login_result->>'access_jwt';
        refresh_jwt := login_result->>'refresh_jwt';

        SELECT COUNT(*) INTO session_count_before FROM auth.refresh_session
        WHERE user_id = (SELECT id FROM auth.user WHERE email = test_email);
        ASSERT session_count_before > 0, 'Setup: User ' || test_email || ' should have at least one session before password change.';
        RAISE NOTICE 'Test 14: Password Change (User) - Setup complete. User has % sessions.', session_count_before;

        -- Test 14.1: Change password as user (simulating user-initiated action)
        RAISE NOTICE 'Test 14.1: Attempting to change password for user %.', test_email;
        BEGIN -- Nested block for SET LOCAL ROLE and its specific rollback simulation
            EXECUTE format('SET LOCAL ROLE %I', test_email); -- Use %I for identifiers
            RAISE DEBUG 'Test 14.1: Switched to role % (current_user: %)', test_email, current_user;
            ASSERT current_user = test_email, 'Test 14.1: Failed to switch role to ' || test_email;

            -- Set JWT claims as if an access token was used for this operation
            PERFORM set_config('request.jwt.claims', (SELECT payload::text FROM verify(access_jwt, 'test-jwt-secret-for-testing-only')), true);

            PERFORM public.change_password(new_password);
            RAISE DEBUG 'Test 14.1: public.change_password(%L) executed for user %', new_password, test_email;
            
            SELECT COUNT(*) INTO session_count_after FROM auth.refresh_session
            WHERE user_id = (SELECT id FROM auth.user WHERE email = test_email);
            RAISE DEBUG 'Test 14.1: Session count for user % after password change: %', test_email, session_count_after;
            ASSERT session_count_after = 0, 'Test 14.1: All sessions for user ' || test_email || ' should be deleted after password change.';
            
            -- Verify password was updated (try logging in with new password)
            DECLARE
                login_result_verify record;
                -- old_password_verify text := 'regular123'; -- Use outer scope old_password
            BEGIN
                RAISE DEBUG 'Test 14.1: Verifying login with new password for %', test_email;
                SELECT * INTO login_result_verify FROM public.login(test_email, new_password);
                RAISE DEBUG 'Test 14.1: Login result with new password (access_jwt): %', login_result_verify.access_jwt;
                ASSERT login_result_verify IS NOT NULL AND login_result_verify.access_jwt IS NOT NULL, 'Test 14.1: Login with new password for ' || test_email || ' should succeed.';

                RAISE DEBUG 'Test 14.1: Verifying login with old password for % fails', test_email;
                SELECT * INTO login_result_verify FROM public.login(test_email, old_password);
                RAISE DEBUG 'Test 14.1: Login result with old password (access_jwt): %', login_result_verify.access_jwt;
                ASSERT login_result_verify IS NULL OR login_result_verify.access_jwt IS NULL, 'Test 14.1: Login with old password for ' || test_email || ' should fail.';
            END;
            
            RAISE NOTICE 'Test 14.1: Password change and immediate verification successful for role %.', test_email;
            RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE for test purposes' USING ERRCODE = 'P0001'; 
            
        EXCEPTION WHEN SQLSTATE 'P0001' THEN
            RAISE DEBUG 'Test 14.1: Caught simulated rollback exception for SET LOCAL ROLE. Current user: %', current_user;
        END; -- End of SET LOCAL ROLE block

        RAISE DEBUG 'Test 14.1: After SET LOCAL ROLE block, current_user: %', current_user;
        ASSERT current_user = 'postgres', 'Test 14.1: After SET LOCAL ROLE block, current_user should be reverted to postgres (or the original test runner role).';
                
        RAISE NOTICE 'Test 14.1: Change password as user and verify - PASSED (within its own transactional context)';
        
        -- Since the SET LOCAL ROLE block was rolled back, the password change is also rolled back.
        -- Verify that the password is back to the original.
        DECLARE
            login_reverify record;
        BEGIN
            RAISE DEBUG 'Test 14: Verifying password reverted to original due to sub-transaction rollback for %', test_email;
            SELECT * INTO login_reverify FROM public.login(test_email, old_password) AS source;
            ASSERT login_reverify IS NOT NULL AND login_reverify.access_jwt IS NOT NULL, 'Test 14: Login with original password should succeed after simulated rollback.';

            SELECT * INTO login_reverify FROM public.login(test_email, new_password) AS source;
            ASSERT login_reverify IS NULL OR login_reverify.access_jwt IS NULL, 'Test 14: Login with new password should fail after simulated rollback.';
            RAISE NOTICE 'Test 14: Password correctly reverted to original for % due to transaction rollback.', test_email;
        END;

        RAISE NOTICE 'Test 14 (Password Change (User)) - Overall PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 14 (Password Change (User)) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 14 (Password Change (User)) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 14: Setup - Logging in user and checking initial session count.
NOTICE:  Test 14: Password Change (User) - Setup complete. User has 12 sessions.
NOTICE:  Test 14.1: Attempting to change password for user test.regular@statbus.org.
NOTICE:  Test 14.1: Password change and immediate verification successful for role test.regular@statbus.org.
NOTICE:  Test 14.1: Change password as user and verify - PASSED (within its own transactional context)
NOTICE:  Test 14: Password correctly reverted to original for test.regular@statbus.org due to transaction rollback.
NOTICE:  Test 14 (Password Change (User)) - Overall PASSED
-- Test 16: Role Switching with SET LOCAL ROLE
\echo '=== Test 16: Role Switching with SET LOCAL ROLE ==='
=== Test 16: Role Switching with SET LOCAL ROLE ===
DO $$
DECLARE
    admin_email text := 'test.admin@statbus.org';
    admin_can_see_count integer;
    regular_email text := 'test.regular@statbus.org';
    regular_can_see_count integer;
    restricted_email text := 'test.restricted@statbus.org';
    restricted_can_see_count integer;
BEGIN
    BEGIN -- Outer BEGIN/EXCEPTION/END for the entire Test 15 (Pattern A)
        
        -- Test 15.1: Admin role permissions
        RAISE NOTICE 'Test 15.1: Testing admin role permissions.';
        BEGIN -- Nested BEGIN/EXCEPTION for SET LOCAL ROLE simulation
            EXECUTE format('SET LOCAL ROLE %I', admin_email);
            RAISE DEBUG 'Test 15.1: Inside SET LOCAL ROLE block, current_user=%', current_user;
            ASSERT current_user = admin_email, 'Test 15.1: Current user should be admin_email.';
            
            SELECT COUNT(*) INTO admin_can_see_count FROM auth.user;
            ASSERT admin_can_see_count > 0, 'Test 15.1: Admin should be able to see users.';
            
            RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE (Test 15.1)' USING ERRCODE = 'P0001';
        EXCEPTION WHEN SQLSTATE 'P0001' THEN
            RAISE DEBUG 'Test 15.1: Caught simulated rollback for SET LOCAL ROLE. Current user: %', current_user;
        END; -- End of SET LOCAL ROLE block for 15.1
        RAISE DEBUG 'Test 15.1: After SET LOCAL ROLE block, current_user=%', current_user;
        ASSERT current_user = 'postgres', 'Test 15.1: After SET LOCAL ROLE block, current_user should be postgres (or original test runner).';
        RAISE NOTICE 'Test 15.1: Admin role permissions - PASSED';

        -- Test 15.2: Regular user permissions
        RAISE NOTICE 'Test 15.2: Testing regular user permissions.';
        BEGIN -- Nested BEGIN/EXCEPTION for SET LOCAL ROLE simulation
            EXECUTE format('SET LOCAL ROLE %I', regular_email);
            RAISE DEBUG 'Test 15.2: Inside SET LOCAL ROLE block, current_user=%', current_user;
            ASSERT current_user = regular_email, 'Test 15.2: Current user should be regular_email.';
            
            BEGIN -- Sub-block to catch potential insufficient_privilege for COUNT(*)
                SELECT COUNT(*) INTO regular_can_see_count FROM auth.user;
                ASSERT regular_can_see_count = 1, 'Test 15.2: Regular user should only see their own user record.';
            EXCEPTION WHEN insufficient_privilege THEN
                RAISE NOTICE 'Test 15.2: Caught insufficient_privilege when regular user tried to count all users, this might be expected depending on RLS. Count set to 0.';
                regular_can_see_count := 0; -- Or handle as appropriate for the test's intent
            END;
            ASSERT EXISTS (SELECT 1 FROM auth.user WHERE email = regular_email), 'Test 15.2: Regular user should see their own record via direct query.';
            ASSERT EXISTS (SELECT 1 FROM public.country LIMIT 1), 'Test 15.2: Regular user should be able to see public data.';
            
            RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE (Test 15.2)' USING ERRCODE = 'P0001';
        EXCEPTION WHEN SQLSTATE 'P0001' THEN
            RAISE DEBUG 'Test 15.2: Caught simulated rollback for SET LOCAL ROLE. Current user: %', current_user;
        END; -- End of SET LOCAL ROLE block for 15.2
        RAISE DEBUG 'Test 15.2: After SET LOCAL ROLE block, current_user=%', current_user;
        ASSERT current_user = 'postgres', 'Test 15.2: After SET LOCAL ROLE block, current_user should be postgres.';
        RAISE NOTICE 'Test 15.2: Regular user permissions - PASSED';

        -- Test 15.3: Restricted user permissions
        RAISE NOTICE 'Test 15.3: Testing restricted user permissions.';
        BEGIN -- Nested BEGIN/EXCEPTION for SET LOCAL ROLE simulation
            EXECUTE format('SET LOCAL ROLE %I', restricted_email);
            RAISE DEBUG 'Test 15.3: Inside SET LOCAL ROLE block, current_user=%', current_user;
            ASSERT current_user = restricted_email, 'Test 15.3: Current user should be restricted_email.';

            BEGIN -- Sub-block to catch potential insufficient_privilege for COUNT(*)
                SELECT COUNT(*) INTO restricted_can_see_count FROM auth.user;
                ASSERT restricted_can_see_count = 1, 'Test 15.3: Restricted user should only see their own user record.';
            EXCEPTION WHEN insufficient_privilege THEN
                RAISE NOTICE 'Test 15.3: Caught insufficient_privilege when restricted user tried to count all users. Count set to 0.';
                restricted_can_see_count := 0;
            END;
            ASSERT EXISTS (SELECT 1 FROM auth.user WHERE email = restricted_email), 'Test 15.3: Restricted user should see their own record.';
            ASSERT EXISTS (SELECT 1 FROM public.country LIMIT 1), 'Test 15.3: Restricted user should be able to see public data.';
            
            RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE (Test 15.3)' USING ERRCODE = 'P0001';
        EXCEPTION WHEN SQLSTATE 'P0001' THEN
            RAISE DEBUG 'Test 15.3: Caught simulated rollback for SET LOCAL ROLE. Current user: %', current_user;
        END; -- End of SET LOCAL ROLE block for 15.3
        RAISE DEBUG 'Test 15.3: After SET LOCAL ROLE block, current_user=%', current_user;
        ASSERT current_user = 'postgres', 'Test 15.3: After SET LOCAL ROLE block, current_user should be postgres.';
        RAISE NOTICE 'Test 15.3: Restricted user permissions - PASSED';
        
        RAISE NOTICE 'Test 16 (Role Switching with SET LOCAL ROLE) - Overall PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 16 (Role Switching with SET LOCAL ROLE) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 16 (Role Switching with SET LOCAL ROLE) - FAILED: %', SQLERRM;
    END; -- End of outer BEGIN/EXCEPTION for Test 15
END; -- End of DO block for Test 15
$$;
NOTICE:  Test 15.1: Testing admin role permissions.
NOTICE:  Test 15.1: Admin role permissions - PASSED
NOTICE:  Test 15.2: Testing regular user permissions.
NOTICE:  Test 15.2: Regular user permissions - PASSED
NOTICE:  Test 15.3: Testing restricted user permissions.
NOTICE:  Test 15.3: Restricted user permissions - PASSED
NOTICE:  Test 16 (Role Switching with SET LOCAL ROLE) - Overall PASSED
-- Test 17: Password Change (Admin)
\echo '=== Test 17: Password Change (Admin) ==='
=== Test 17: Password Change (Admin) ===
DO $$
DECLARE
    target_sub_for_test16 uuid;
    new_password_for_test16 text := 'newExternalPass789';
    original_password_for_test16 text := 'External#123!';
    target_email_for_test16 text := 'test.external@statbus.org';
    target_refresh_jwt_for_test16 text;
    admin_email text := 'test.admin@statbus.org'; -- Hoisted for use across sub-tests
    target_login_result jsonb; -- Hoisted
    session_count_before integer; -- Hoisted
    session_count_after integer; -- Hoisted
    refresh_result record; -- Hoisted
BEGIN
    BEGIN -- Outer BEGIN/EXCEPTION/END for the entire Test 16 (Pattern A)
        -- Initialize GUCs for Test 16 to ensure a clean state
        PERFORM set_config('request.headers', json_build_object('x-forwarded-proto', 'https')::text, true);
        PERFORM set_config('request.cookies', '{}'::text, true); -- Initialize if not set by a specific step
        PERFORM set_config('response.headers', '[]'::text, true); -- Initialize response headers
        PERFORM set_config('request.jwt.claims', '', true);
        
        -- Test 16.1: Setup and initial state
        RAISE NOTICE 'Test 16.1: Setup - Getting target user and logging them in.';
        SELECT sub INTO target_sub_for_test16 FROM auth.user WHERE email = target_email_for_test16;
        RAISE DEBUG 'Test 16.1: Target user % sub: %', target_email_for_test16, target_sub_for_test16;
        ASSERT target_sub_for_test16 IS NOT NULL, 'Test 16.1: Target user ' || target_email_for_test16 || ' not found.';

        SELECT to_jsonb(source.*) INTO target_login_result FROM public.login(target_email_for_test16, original_password_for_test16) AS source;
        ASSERT target_login_result IS NOT NULL AND target_login_result->>'access_jwt' IS NOT NULL, 'Test 16.1: Login failed for target user ' || target_email_for_test16;
        target_refresh_jwt_for_test16 := target_login_result->>'refresh_jwt';

        SELECT COUNT(*) INTO session_count_before FROM auth.refresh_session
        WHERE user_id = (SELECT id FROM auth.user WHERE sub = target_sub_for_test16);
        ASSERT session_count_before > 0, 'Test 16.1: Target user ' || target_email_for_test16 || ' should have at least one session.';
        RAISE NOTICE 'Test 16.1: Setup and initial state - PASSED. Target user has % sessions.', session_count_before;

        -- Test 16.2 & 16.3: Admin changes user password and verifies
        RAISE NOTICE 'Test 16.2: Admin attempts to change password for user %.', target_email_for_test16;
        BEGIN -- Nested BEGIN/EXCEPTION for SET LOCAL ROLE simulation
            EXECUTE format('SET LOCAL ROLE %I', admin_email);
            RAISE DEBUG 'Test 16.2: Switched to admin role % (current_user: %)', admin_email, current_user;
            ASSERT current_user = admin_email, 'Test 16.2: Failed to switch to admin role.';

            PERFORM public.admin_change_password(target_sub_for_test16, new_password_for_test16);
            RAISE DEBUG 'Test 16.2: public.admin_change_password executed for target % by admin %.', target_sub_for_test16, admin_email;
            
            SELECT COUNT(*) INTO session_count_after FROM auth.refresh_session
            WHERE user_id = (SELECT id FROM auth.user WHERE sub = target_sub_for_test16);
            RAISE DEBUG 'Test 16.2: Session count for target user % after admin password change: %', target_email_for_test16, session_count_after;
            ASSERT session_count_after = 0, 'Test 16.2: All sessions for target user ' || target_email_for_test16 || ' should be deleted after admin password change.';
            
            -- Test 16.3: Verify password was changed (within this transaction)
            RAISE NOTICE 'Test 16.3: Verifying password change for user %.', target_email_for_test16;
            SELECT to_jsonb(source.*) INTO target_login_result FROM public.login(target_email_for_test16, new_password_for_test16) AS source;
            ASSERT target_login_result IS NOT NULL AND target_login_result->>'access_jwt' IS NOT NULL, 'Test 16.3: Login with new password for target user ' || target_email_for_test16 || ' should succeed.';

            SELECT to_jsonb(source.*) INTO target_login_result FROM public.login(target_email_for_test16, original_password_for_test16) AS source;
            ASSERT target_login_result IS NULL OR target_login_result->>'access_jwt' IS NULL, 'Test 16.3: Login with old password for target user ' || target_email_for_test16 || ' should fail.';

            PERFORM set_config('request.cookies', jsonb_build_object('statbus-refresh', target_refresh_jwt_for_test16)::text, true);
            PERFORM set_config('request.jwt.claims', '', true);
            -- Ensure headers are set for public.refresh, providing a typical context
            PERFORM set_config('request.headers', json_build_object('x-forwarded-for', '127.0.0.1', 'user-agent', 'Test Agent for Refresh', 'x-forwarded-proto', 'https')::text, true);
            BEGIN
                SELECT * INTO refresh_result FROM public.refresh();
                RAISE EXCEPTION 'Test 16.3: Refresh with target user invalidated session token should have failed but got %', refresh_result;
            EXCEPTION WHEN OTHERS THEN
                ASSERT SQLERRM LIKE '%Invalid session or token has been superseded%', 'Test 16.3: Error should indicate invalid session for old refresh token.';
            END;
            RAISE NOTICE 'Test 16.3: Password change verification - PASSED.';
            
            RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE (Test 16.2/16.3)' USING ERRCODE = 'P0001';
        EXCEPTION WHEN SQLSTATE 'P0001' THEN
            RAISE DEBUG 'Test 16.2/16.3: Caught simulated rollback for SET LOCAL ROLE. Current user: %', current_user;
        END; -- End of SET LOCAL ROLE block for 16.2/16.3
        RAISE DEBUG 'Test 16.2/16.3: After SET LOCAL ROLE block, current_user: %', current_user;
        ASSERT current_user = 'postgres', 'Test 16.2/16.3: Current user should be postgres after SET LOCAL ROLE block.';
        RAISE NOTICE 'Test 16.2: Admin changes user password - PASSED (transactionally, change rolled back).';

        -- Test 16.4: Verify password reverted and test admin changing it back via UPDATE public.user
        RAISE NOTICE 'Test 16.4: Verifying password reverted and testing admin changing it back via UPDATE.';
        BEGIN -- Nested BEGIN/EXCEPTION for SET LOCAL ROLE for 16.4
            EXECUTE format('SET LOCAL ROLE %I', admin_email);
            RAISE DEBUG 'Test 16.4: Switched to admin role % (current_user: %)', admin_email, current_user;
            ASSERT current_user = admin_email, 'Test 16.4: Failed to switch to admin role.';

            -- Verify password is still original (due to previous rollback)
            SELECT to_jsonb(source.*) INTO target_login_result FROM public.login(target_email_for_test16, original_password_for_test16) AS source;
            ASSERT target_login_result IS NOT NULL AND target_login_result->>'access_jwt' IS NOT NULL, 'Test 16.4: Login with original password should still work (confirming rollback).';

            -- Admin changes target user password back to original_password_for_test16 using UPDATE public.user
            -- (This step is a bit redundant if previous was rolled back, but tests the UPDATE path)
            UPDATE public.user SET password = original_password_for_test16 WHERE sub = target_sub_for_test16;
            RAISE DEBUG 'Test 16.4: Admin updated password for % via public.user view.', target_email_for_test16;

            SELECT to_jsonb(source.*) INTO target_login_result FROM public.login(target_email_for_test16, original_password_for_test16) AS source;
            ASSERT target_login_result IS NOT NULL AND target_login_result->>'access_jwt' IS NOT NULL, 'Test 16.4: Login with original password should succeed after admin reset via UPDATE.';
            
            RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE (Test 16.4)' USING ERRCODE = 'P0001';
        EXCEPTION WHEN SQLSTATE 'P0001' THEN
            RAISE DEBUG 'Test 16.4: Caught simulated rollback for SET LOCAL ROLE. Current user: %', current_user;
        END; -- End of SET LOCAL ROLE block for 16.4
        RAISE DEBUG 'Test 16.4: After SET LOCAL ROLE block, current_user: %', current_user;
        ASSERT current_user = 'postgres', 'Test 16.4: Current user should be postgres after SET LOCAL ROLE block.';
        RAISE NOTICE 'Test 17.4: Admin password change back operations - PASSED (transactionally).';

        RAISE NOTICE 'Test 17 (Password Change (Admin)) - Overall PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 17 (Password Change (Admin)) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 17 (Password Change (Admin)) - FAILED: %', SQLERRM;
    END; -- End of outer BEGIN/EXCEPTION for Test 16
END; -- End of DO block for Test 16
$$;
NOTICE:  Test 16.1: Setup - Getting target user and logging them in.
NOTICE:  Test 16.1: Setup and initial state - PASSED. Target user has 1 sessions.
NOTICE:  Test 16.2: Admin attempts to change password for user test.external@statbus.org.
NOTICE:  Test 16.3: Verifying password change for user test.external@statbus.org.
NOTICE:  Test 16.3: Password change verification - PASSED.
NOTICE:  Test 16.2: Admin changes user password - PASSED (transactionally, change rolled back).
NOTICE:  Test 16.4: Verifying password reverted and testing admin changing it back via UPDATE.
NOTICE:  Test 17.4: Admin password change back operations - PASSED (transactionally).
NOTICE:  Test 17 (Password Change (Admin)) - Overall PASSED
-- Test 18: API Key Creation and Usage
\echo '=== Test 18: API Key Creation and Usage ==='
=== Test 18: API Key Creation and Usage ===
DO $$
DECLARE
    login_result jsonb;
    api_key_result record;
    api_key_token text;
    api_key_jti uuid;
    api_key_description text := 'Test API Key';
    test_email text := 'test.regular@statbus.org';
    test_password text := 'Regular#123!';
    access_jwt text;
    api_key_claims jsonb;
    api_key_list record; -- This variable seems unused in the original logic block
    api_key_count integer;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Original Test 17 logic
        -- Use nested block for SET LOCAL ROLE
    BEGIN
        -- Switch to the user's role
        EXECUTE format('SET LOCAL ROLE "%s"', test_email);
        RAISE DEBUG 'Inside nested block, current_user=%', current_user;
        ASSERT current_user = test_email, 'Inside nested block, current user should be test email';
    
    -- Create an API key
    SELECT * INTO api_key_result FROM public.create_api_key(api_key_description, interval '30 days');
    
    -- Debug the API key result
    RAISE DEBUG 'API key result: %', to_jsonb(api_key_result);
    
    -- Verify API key was created
    ASSERT api_key_result.description = api_key_description, 'API key description should match';
    ASSERT api_key_result.token IS NOT NULL, 'API key token should not be null';
    ASSERT api_key_result.jti IS NOT NULL, 'API key JTI should not be null';
    
    -- Store values for later tests
    api_key_token := api_key_result.token;
    api_key_jti := api_key_result.jti;
    
    -- Verify the token is a valid JWT with expected claims
    SELECT payload::jsonb INTO api_key_claims 
    FROM verify(api_key_token, 'test-jwt-secret-for-testing-only');
    
    -- Debug the API key claims
    RAISE DEBUG 'API key claims: %', api_key_claims;
    
    -- Verify API key claims
    ASSERT api_key_claims->>'type' = 'api_key', 'API key type should be api_key';
    ASSERT api_key_claims->>'role' = test_email, 'API key role should match user email';
    ASSERT api_key_claims->>'jti' = api_key_jti::text, 'API key JTI should match';
    ASSERT api_key_claims->>'description' = api_key_description, 'API key description should be in claims';
    
    -- Verify API key is in the database
    ASSERT EXISTS (
        SELECT 1 FROM auth.api_key WHERE jti = api_key_jti
    ), 'API key should exist in database';
    
    -- Test using the API key token for authentication
    -- Clear existing context
    PERFORM set_config('request.jwt.claims', '', true);
    PERFORM set_config('request.cookies', '{}', true);
    
    -- Set up JWT claims using the API key token
    PERFORM set_config('request.jwt.claims', 
        (SELECT payload::text FROM verify(api_key_token, 'test-jwt-secret-for-testing-only')),
        true
    );
    
    -- Run the pre-request function that checks API key revocation
    PERFORM auth.check_api_key_revocation();
    
    -- If we get here without an exception, the API key is valid
    RAISE DEBUG 'API key validation passed';
    
    -- Verify we can access data with the API key
    -- This should work because the API key has the same permissions as the user
    ASSERT EXISTS (
        SELECT 1 FROM public.country LIMIT 1
    ), 'Should be able to access public data with API key';
    
    -- Test listing API keys
    -- We're already using the user's role from SET LOCAL ROLE
    
    -- List API keys
    SELECT COUNT(*) INTO api_key_count FROM public.api_key;
    
    -- Verify we can see our API key
    ASSERT api_key_count > 0, 'Should be able to list API keys';
    ASSERT EXISTS (
        SELECT 1 FROM public.api_key WHERE jti = api_key_jti
    ), 'Should be able to see the created API key';
    
    -- Raise exception to implicitly rollback the SET LOCAL ROLE
    RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE' USING ERRCODE = 'P0001';
    
    EXCEPTION WHEN SQLSTATE 'P0001' THEN
        -- Catch the specific exception and log success
        RAISE DEBUG 'Caught simulated rollback exception, SET LOCAL ROLE was rolled back to %', current_user;
    END;
        RAISE NOTICE 'Test 18 (API Key Creation and Usage) - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 18 (API Key Creation and Usage) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 18 (API Key Creation and Usage) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 18 (API Key Creation and Usage) - PASSED
-- Test 19: API Key Revocation
\echo '=== Test 19: API Key Revocation ==='
=== Test 19: API Key Revocation ===
DO $$
DECLARE
    login_result jsonb;
    api_key_result record;
    api_key_token text;
    api_key_jti uuid;
    api_key_description text := 'Test API Key for Revocation';
    test_email text := 'test.regular@statbus.org';
    test_password text := 'Regular#123!';
    access_jwt text;
    revoke_result boolean;
    api_key_claims jsonb;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Original Test 18 logic
        -- First login to get a valid access token
    SELECT to_json(source.*) INTO login_result FROM public.login(test_email, test_password) AS source;
    access_jwt := login_result->>'access_jwt';
    
    -- Use nested block for SET LOCAL ROLE to properly test RLS
    BEGIN
        -- Switch to the user's role to create and then revoke an API key
        EXECUTE format('SET LOCAL ROLE "%s"', test_email);
        RAISE DEBUG 'Inside nested block, current_user=%', current_user;
        ASSERT current_user = test_email, 'Inside nested block, current user should be test email';
        
        -- Create an API key
        SELECT * INTO api_key_result FROM public.create_api_key(api_key_description, interval '30 days');
        
        -- Store values for later tests
        api_key_token := api_key_result.token;
        api_key_jti := api_key_result.jti;
        
        -- Get the claims from the token
        SELECT payload::jsonb INTO api_key_claims 
        FROM verify(api_key_token, 'test-jwt-secret-for-testing-only');
        
        -- Verify API key is in the database and not revoked
        ASSERT EXISTS (
            SELECT 1 FROM auth.api_key WHERE jti = api_key_jti AND revoked_at IS NULL
        ), 'API key should exist in database and not be revoked';
        
        -- Revoke the API key
        SELECT public.revoke_api_key(api_key_jti) INTO revoke_result;
        
        -- Verify revocation was successful
        ASSERT revoke_result = true, 'Revoke API key should return true';
        
        -- Verify API key is marked as revoked in the database
        ASSERT EXISTS (
            SELECT 1 FROM auth.api_key WHERE jti = api_key_jti AND revoked_at IS NOT NULL
        ), 'API key should be marked as revoked in database';
        
        -- Test using the revoked API key token for authentication
        -- This simulates what PostgREST would do when receiving a revoked API key token
        
        -- Set JWT claims to simulate what PostgREST would do
        PERFORM set_config('request.jwt.claims', api_key_claims::text, true);
        
        -- Try to use the revoked API key
        BEGIN
            -- This should raise an exception because the key is revoked
            PERFORM auth.check_api_key_revocation();
            
            -- If we get here, the revocation check failed
            RAISE EXCEPTION 'Revoked API key should not pass validation';
        EXCEPTION WHEN OTHERS THEN
            -- This is expected - the key should be rejected
            RAISE DEBUG 'Revoked API key was correctly rejected: %', SQLERRM;
            ASSERT SQLERRM LIKE '%API Key has been revoked%', 'Error should indicate revoked key';
        END;

        -- Raise exception to implicitly rollback the SET LOCAL ROLE
        RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE' USING ERRCODE = 'P0001';
    EXCEPTION WHEN SQLSTATE 'P0001' THEN
        -- Catch the specific exception and log success
        RAISE DEBUG 'Caught simulated rollback exception, SET LOCAL ROLE was rolled back to %', current_user;
    END;
        
        RAISE NOTICE 'Test 19 (API Key Revocation) - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 19 (API Key Revocation) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 19 (API Key Revocation) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 19 (API Key Revocation) - PASSED
-- Test 20: API Key Permissions and Boundaries
\echo '=== Test 20: API Key Permissions and Boundaries ==='
=== Test 20: API Key Permissions and Boundaries ===
DO $$
DECLARE
    login_result jsonb;
    api_key_result record;
    api_key_token text;
    api_key_jti uuid;
    api_key_description text := 'Test API Key for Permissions';
    test_email text := 'test.regular@statbus.org';
    test_password text := 'Regular#123!';
    access_jwt text;
    api_key_claims jsonb;
BEGIN
    BEGIN -- Inner BEGIN/EXCEPTION/END for savepoint-like behavior
        -- Original Test 19 logic
        -- First login to get a valid access token
    SELECT to_json(source.*) INTO login_result FROM public.login(test_email, test_password) AS source;
    access_jwt := login_result->>'access_jwt';
    
    -- Use nested block for SET LOCAL ROLE to properly test RLS
    BEGIN
        -- Switch to the user's role to create an API key
        EXECUTE format('SET LOCAL ROLE "%s"', test_email);
        RAISE DEBUG 'Inside nested block, current_user=%', current_user;
        ASSERT current_user = test_email, 'Inside nested block, current user should be test email';
        
        -- Create an API key
        SELECT * INTO api_key_result FROM public.create_api_key(api_key_description, interval '30 days');
        
        -- Store values for later tests
        api_key_token := api_key_result.token;
        api_key_jti := api_key_result.jti;
        
        -- Get the claims from the token
        SELECT payload::jsonb INTO api_key_claims 
        FROM verify(api_key_token, 'test-jwt-secret-for-testing-only');
        
        -- Raise exception to implicitly rollback the SET LOCAL ROLE
        RAISE EXCEPTION 'Simulating rollback for SET LOCAL ROLE' USING ERRCODE = 'P0001';
    EXCEPTION WHEN SQLSTATE 'P0001' THEN
        -- Catch the specific exception and log success
        RAISE DEBUG 'Caught simulated rollback exception, SET LOCAL ROLE was rolled back to %', current_user;
    END;
    -- Now test API key permissions and boundaries
    -- This simulates what PostgREST would do when receiving an API key token
    BEGIN
        -- Extract the role from the token
        DECLARE
            api_key_role text;
        BEGIN
            api_key_role := api_key_claims->>'role';
            
            -- Switch to the role specified in the API key token
            EXECUTE format('SET LOCAL ROLE "%s"', api_key_role);
            RAISE DEBUG 'Using API key token, current_user=%', current_user;
            ASSERT current_user = test_email, 'When using API key, current user should be test email';
            
            -- Set JWT claims to simulate what PostgREST would do
            PERFORM set_config('request.jwt.claims', api_key_claims::text, true);
            
            -- Test 1: API keys should not be able to create other API keys
            BEGIN
                -- This should fail because API keys shouldn't be able to create other API keys
                PERFORM public.create_api_key('API Key created by another API key', interval '1 day');
                
                -- If we get here, the permission check failed
                RAISE EXCEPTION 'API keys should not be able to create other API keys';
            EXCEPTION WHEN OTHERS THEN
                -- This is expected - the operation should be rejected
                RAISE DEBUG 'API key creating another API key was correctly rejected: %', SQLERRM;
            END;
            
            -- Test 2: API keys should not be able to change passwords
            BEGIN
                -- This should fail because API keys shouldn't be able to change passwords
                PERFORM public.change_password('NewPassword123');
                
                -- If we get here, the permission check failed
                RAISE EXCEPTION 'API keys should not be able to change passwords';
            EXCEPTION WHEN OTHERS THEN
                -- This is expected - the operation should be rejected
                RAISE DEBUG 'API key changing password was correctly rejected: %', SQLERRM;
                ASSERT SQLERRM LIKE '%Password change requires a valid access token%', 
                    'Error should indicate that password change requires access token';
            END;
            
            -- Test 3: API keys should not be able to refresh tokens
            BEGIN
                -- This should fail because API keys shouldn't be able to refresh tokens
                PERFORM public.refresh();
                
                -- If we get here, the permission check failed
                RAISE EXCEPTION 'API keys should not be able to refresh tokens';
            EXCEPTION WHEN OTHERS THEN
                -- This is expected - the operation should be rejected
                RAISE DEBUG 'API key refreshing token was correctly rejected: %', SQLERRM;
            END;
            
            -- Raise exception to implicitly rollback the SET LOCAL ROLE
            RAISE EXCEPTION 'Simulating rollback for API key role' USING ERRCODE = 'P0002';
        END;
    EXCEPTION WHEN SQLSTATE 'P0002' THEN
        -- Catch the specific exception and log success
        RAISE DEBUG 'Caught simulated rollback exception, SET LOCAL ROLE was rolled back to %', current_user;
    END;
        RAISE NOTICE 'Test 20 (API Key Permissions and Boundaries) - PASSED';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN
            RAISE NOTICE 'Test 20 (API Key Permissions and Boundaries) - FAILED (ASSERT): %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE 'Test 20 (API Key Permissions and Boundaries) - FAILED: %', SQLERRM;
    END;
END;
$$;
NOTICE:  Test 20 (API Key Permissions and Boundaries) - PASSED
-- Clean up test environment
-- Clean up test sessions
DELETE FROM auth.refresh_session
WHERE user_id IN (
    SELECT id FROM auth.user 
    WHERE email LIKE 'test.%@statbus.org' -- Updated domain
);
-- Clean up test API keys
DELETE FROM auth.api_key
WHERE user_id IN (
    SELECT id FROM auth.user
    WHERE email LIKE 'test.%@statbus.org' -- Updated domain
);
DELETE FROM auth.user
WHERE email LIKE 'test.%@statbus.org'; -- Updated domain
