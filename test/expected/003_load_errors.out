BEGIN;
\echo "Setting up Statbus to load establishments without legal units"
"Setting up Statbus to load establishments without legal units"
-- Only load settings and sectors from samples/norway/getting-started.sql to get lots of errors due to missing lookup information.
\i samples/norway/settings.sql
INSERT INTO settings(activity_category_standard_id,country_id)
SELECT (SELECT id FROM activity_category_standard WHERE code = 'nace_v2.1')
     , (SELECT id FROM public.country WHERE iso_2 = 'NO')
ON CONFLICT (only_one_setting)
DO UPDATE SET
   activity_category_standard_id = EXCLUDED.activity_category_standard_id,
   country_id = EXCLUDED.country_id
   WHERE settings.only_one_setting = EXCLUDED.only_one_setting;
;
-- \i samples/norway/activity_category/activity_category_norway.sql
-- \i samples/norway/regions/norway-regions-2024.sql
-- \i samples/norway/sector/sector_norway.sql
-- \i samples/norway/legal_form/legal_form_norway.sql
-- \i samples/norway/data_source/data_source_norway.sql
SELECT acs.code
  FROM public.settings AS s
  JOIN activity_category_standard AS acs
    ON s.activity_category_standard_id = acs.id;
   code    
-----------
 nace_v2.1
(1 row)

\d public.sector_custom_only
           View "public.sector_custom_only"
   Column    | Type  | Collation | Nullable | Default 
-------------+-------+-----------+----------+---------
 path        | ltree |           |          | 
 name        | text  |           |          | 
 description | text  |           |          | 
Triggers:
    sector_custom_only_prepare_trigger BEFORE INSERT ON sector_custom_only FOR EACH STATEMENT EXECUTE FUNCTION admin.sector_custom_only_prepare()
    sector_custom_only_upsert INSTEAD OF INSERT ON sector_custom_only FOR EACH ROW EXECUTE FUNCTION admin.sector_custom_only_upsert()

\sf admin.sector_custom_only_upsert
CREATE OR REPLACE FUNCTION admin.sector_custom_only_upsert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    maybe_parent_id int := NULL;
    row RECORD;
BEGIN
    -- Find parent sector based on NEW.path
    IF public.nlevel(NEW.path) > 1 THEN
        SELECT id INTO maybe_parent_id
          FROM public.sector
         WHERE path OPERATOR(public.=) public.subltree(NEW.path, 0, public.nlevel(NEW.path) - 1)
           AND active
           AND custom;
        IF NOT FOUND THEN
          RAISE EXCEPTION 'Could not find parent for path %', NEW.path;
        END IF;
        RAISE DEBUG 'maybe_parent_id %', maybe_parent_id;
    END IF;

    -- Perform an upsert operation on public.sector
    BEGIN
        INSERT INTO public.sector
            ( path
            , parent_id
            , name
            , description
            , updated_at
            , active
            , custom
            )
        VALUES
            ( NEW.path
            , maybe_parent_id
            , NEW.name
            , NEW.description
            , statement_timestamp()
            , TRUE -- Active
            , TRUE -- Custom
            )
        ON CONFLICT (path, active, custom)
        DO UPDATE SET
                parent_id = maybe_parent_id
              , name = NEW.name
              , description = NEW.description
              , updated_at = statement_timestamp()
              , active = TRUE
              , custom = TRUE
           RETURNING * INTO row;

        -- Log the upserted row
        RAISE DEBUG 'UPSERTED %', to_json(row);

    EXCEPTION WHEN unique_violation THEN
        DECLARE
            code varchar := regexp_replace(regexp_replace(NEW.path::TEXT, '[^0-9]', '', 'g'),'^([0-9]{2})(.+)$','\1.\2','');
            data JSONB := to_jsonb(NEW);
        BEGIN
           data := jsonb_set(data, '{code}', code::jsonb, true);
            RAISE EXCEPTION '% for row %', SQLERRM, data
                USING
                DETAIL = 'Failed during UPSERT operation',
                HINT = 'Check for path derived numeric code violations';
        END;
    END;

    RETURN NULL;
END;
$function$
\echo "User uploads the sectors with errors"
"User uploads the sectors with errors"
\copy public.sector_custom_only(path,name,description) FROM 'test/data/30_ug_sectorcodes_with_index_error.csv' WITH (FORMAT csv, DELIMITER ',', QUOTE '"', HEADER true);
ERROR:  duplicate key value violates unique constraint "sector_code_active_key" for row {"code": 1, "name": "er ror,part2 ", "path": "s1", "description": "desc works"}
DETAIL:  Failed during UPSERT operation
HINT:  Check for path derived numeric code violations
CONTEXT:  PL/pgSQL function admin.sector_custom_only_upsert() line 58 at RAISE
COPY sector_custom_only, line 9: "s1,"er ror,part2 ",desc works"
ROLLBACK;
