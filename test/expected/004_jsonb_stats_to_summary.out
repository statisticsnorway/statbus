-- Test: jsonb_stats extension functions
-- Tests the full pipeline used by timeline views for statistical aggregation
-- Create test table mirroring stat_for_unit's typed columns
CREATE TEMPORARY TABLE test_stat_rows (
    id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    test_case integer,
    entity_id integer,
    code text,
    value_int integer,
    value_float double precision,
    value_string text,
    value_bool boolean,
    stat JSONB GENERATED ALWAYS AS (
        COALESCE(stat(value_int), stat(value_float), stat(value_string), stat(value_bool))
    ) STORED
);
-- Test case 1: 3 entities, each with (num, str, bool) stats
-- Entity 1: num=1, str='a', bool=true
-- Entity 2: num=2, str='a', bool=false
-- Entity 3: num=3, str='b', bool=true
INSERT INTO test_stat_rows (test_case, entity_id, code, value_int) VALUES
    (1, 1, 'num', 1), (1, 2, 'num', 2), (1, 3, 'num', 3);
INSERT INTO test_stat_rows (test_case, entity_id, code, value_string) VALUES
    (1, 1, 'str', 'a'), (1, 2, 'str', 'a'), (1, 3, 'str', 'b');
INSERT INTO test_stat_rows (test_case, entity_id, code, value_bool) VALUES
    (1, 1, 'bool', true), (1, 2, 'bool', false), (1, 3, 'bool', true);
-- Test case 2: 10 entities for numeric accuracy testing
INSERT INTO test_stat_rows (test_case, entity_id, code, value_int) VALUES
    (2, 1, 'num', 0), (2, 2, 'num', 100), (2, 3, 'num', 200), (2, 4, 'num', 300), (2, 5, 'num', 400),
    (2, 6, 'num', 500), (2, 7, 'num', 600), (2, 8, 'num', 700), (2, 9, 'num', 800), (2, 10, 'num', 900);
INSERT INTO test_stat_rows (test_case, entity_id, code, value_string) VALUES
    (2, 1, 'str', 'a'), (2, 2, 'str', 'b'), (2, 3, 'str', 'b'), (2, 4, 'str', 'c'), (2, 5, 'str', 'c'),
    (2, 6, 'str', 'c'), (2, 7, 'str', 'd'), (2, 8, 'str', 'd'), (2, 9, 'str', 'd'), (2, 10, 'str', 'd');
INSERT INTO test_stat_rows (test_case, entity_id, code, value_bool) VALUES
    (2, 1, 'bool', true), (2, 2, 'bool', false), (2, 3, 'bool', true), (2, 4, 'bool', true), (2, 5, 'bool', false),
    (2, 6, 'bool', true), (2, 7, 'bool', true), (2, 8, 'bool', true), (2, 9, 'bool', false), (2, 10, 'bool', false);
-- Reference view for SQL-native aggregation (for verification)
CREATE TEMPORARY VIEW reference AS
SELECT
    test_case,
    SUM(value_int) AS num_sum,
    COUNT(value_int) AS num_count,
    MIN(value_int) AS num_min,
    MAX(value_int) AS num_max,
    ROUND(AVG(value_int), 2) AS num_mean,
    SUM(CASE WHEN value_bool THEN 1 ELSE 0 END) AS bool_true_count,
    SUM(CASE WHEN NOT value_bool THEN 1 ELSE 0 END) AS bool_false_count,
    COUNT(*) FILTER (WHERE value_string = 'a') AS str_a_count,
    COUNT(*) FILTER (WHERE value_string = 'b') AS str_b_count,
    COUNT(*) FILTER (WHERE value_string = 'c') AS str_c_count,
    COUNT(*) FILTER (WHERE value_string = 'd') AS str_d_count
FROM test_stat_rows
GROUP BY test_case
ORDER BY test_case;
\t
\a
-- Test 1: stat() constructors
SELECT '## stat() constructors' AS test;
## stat() constructors
SELECT stat(42);
{"type": "int", "value": 42}
SELECT stat(3.14::float8);
{"type": "float", "value": 3.14}
SELECT stat('hello'::text);
{"type": "str", "value": "hello"}
SELECT stat(true);
{"type": "bool", "value": true}
-- Test 2: jsonb_stats_agg(code, stat) - builds stats per entity
-- This is Level 1: build one stats object per entity (like establishment_stats CTE)
SELECT '## Level 1: stats per entity (test_case=1, entity_id=1)' AS test;
## Level 1: stats per entity (test_case=1, entity_id=1)
SELECT jsonb_pretty(jsonb_stats_agg(code, stat)) AS stats
FROM test_stat_rows
WHERE test_case = 1 AND entity_id = 1;
{
    "num": {
        "type": "int",
        "value": 1
    },
    "str": {
        "type": "str",
        "value": "a"
    },
    "bool": {
        "type": "bool",
        "value": true
    },
    "type": "stats"
}
-- Test 3: jsonb_stats_to_agg - convert single entity stats to stats_agg
-- This is Level 2: convert per-entity stats to stats_agg (like stats_summary in timeline views)
SELECT '## Level 2: stats_agg per entity (test_case=1, entity_id=1)' AS test;
## Level 2: stats_agg per entity (test_case=1, entity_id=1)
WITH entity_stats AS (
    SELECT jsonb_stats_agg(code, stat) AS stats
    FROM test_stat_rows
    WHERE test_case = 1 AND entity_id = 1
)
SELECT jsonb_pretty(jsonb_stats_to_agg(stats)) AS stats_agg
FROM entity_stats;
{
    "num": {
        "max": 1,
        "min": 1,
        "sum": 1,
        "mean": 1.00,
        "type": "int_agg",
        "count": 1,
        "stddev": null,
        "variance": null,
        "sum_sq_diff": 0.00,
        "coefficient_of_variation_pct": null
    },
    "str": {
        "type": "str_agg",
        "counts": {
            "a": 1
        }
    },
    "bool": {
        "type": "bool_agg",
        "counts": {
            "true": 1
        }
    },
    "type": "stats_agg"
}
-- Test 4: Full pipeline - build per-entity stats_agg, then merge across entities
-- This is Level 3: merge multiple entities' stats_agg (like establishment_aggs CTE)
SELECT '## Level 3: merged stats_agg across all entities (test_case=1)' AS test;
## Level 3: merged stats_agg across all entities (test_case=1)
WITH entity_stats AS (
    SELECT entity_id,
           jsonb_stats_to_agg(jsonb_stats_agg(code, stat)) AS stats_agg
    FROM test_stat_rows
    WHERE test_case = 1
    GROUP BY entity_id
)
SELECT jsonb_pretty(jsonb_stats_merge_agg(stats_agg)) AS merged
FROM entity_stats;
{
    "num": {
        "max": 3,
        "min": 1,
        "sum": 6,
        "mean": 2.00,
        "type": "int_agg",
        "count": 3,
        "stddev": 1.00,
        "variance": 1.00,
        "sum_sq_diff": 2.00,
        "coefficient_of_variation_pct": 50.00
    },
    "str": {
        "type": "str_agg",
        "counts": {
            "a": 2,
            "b": 1
        }
    },
    "bool": {
        "type": "bool_agg",
        "counts": {
            "true": 2,
            "false": 1
        }
    },
    "type": "stats_agg"
}
\x
\a
SELECT * FROM reference WHERE test_case = 1;
test_case        | 1
num_sum          | 6
num_count        | 3
num_min          | 1
num_max          | 3
num_mean         | 2.00
bool_true_count  | 2
bool_false_count | 1
str_a_count      | 2
str_b_count      | 1
str_c_count      | 0
str_d_count      | 0

\a
\x
-- Test 5: Full pipeline with 10 entities
SELECT '## Level 3: merged stats_agg (test_case=2)' AS test;
## Level 3: merged stats_agg (test_case=2)
WITH entity_stats AS (
    SELECT entity_id,
           jsonb_stats_to_agg(jsonb_stats_agg(code, stat)) AS stats_agg
    FROM test_stat_rows
    WHERE test_case = 2
    GROUP BY entity_id
)
SELECT jsonb_pretty(jsonb_stats_merge_agg(stats_agg)) AS merged
FROM entity_stats;
{
    "num": {
        "max": 900,
        "min": 0,
        "sum": 4500,
        "mean": 450.00,
        "type": "int_agg",
        "count": 10,
        "stddev": 302.77,
        "variance": 91666.67,
        "sum_sq_diff": 825000.00,
        "coefficient_of_variation_pct": 67.28
    },
    "str": {
        "type": "str_agg",
        "counts": {
            "a": 1,
            "b": 2,
            "c": 3,
            "d": 4
        }
    },
    "bool": {
        "type": "bool_agg",
        "counts": {
            "true": 6,
            "false": 4
        }
    },
    "type": "stats_agg"
}
\x
\a
SELECT * FROM reference WHERE test_case = 2;
test_case        | 2
num_sum          | 4500
num_count        | 10
num_min          | 0
num_max          | 900
num_mean         | 450.00
bool_true_count  | 6
bool_false_count | 4
str_a_count      | 1
str_b_count      | 2
str_c_count      | 3
str_d_count      | 4

\a
\x
-- Test 6: Split-merge test
-- Split entities into two halves, merge separately, then merge the halves
-- Verifies merge associativity: merge(merge(A), merge(B)) == merge(A âˆª B)
SELECT '## Split-merge test' AS test;
## Split-merge test
WITH entity_stats AS (
    SELECT entity_id,
           jsonb_stats_to_agg(jsonb_stats_agg(code, stat)) AS stats_agg
    FROM test_stat_rows
    WHERE test_case = 2
    GROUP BY entity_id
),
first_half AS (
    SELECT jsonb_stats_merge_agg(stats_agg) AS agg
    FROM entity_stats
    WHERE entity_id <= 5
),
second_half AS (
    SELECT jsonb_stats_merge_agg(stats_agg) AS agg
    FROM entity_stats
    WHERE entity_id > 5
),
ordered_groups AS (
    SELECT agg AS stats_summary FROM first_half
    UNION ALL
    SELECT agg AS stats_summary FROM second_half
)
SELECT '## first_half' AS stats_summary
UNION ALL
SELECT jsonb_pretty(agg) FROM first_half
UNION ALL
SELECT '## second_half' AS stats_summary
UNION ALL
SELECT jsonb_pretty(agg) FROM second_half
UNION ALL
SELECT '## jsonb_stats_merge_agg'
UNION ALL
SELECT jsonb_pretty(jsonb_stats_merge_agg(stats_summary)) FROM ordered_groups
UNION ALL
SELECT '## jsonb_stats_merge'
UNION ALL
SELECT jsonb_pretty(jsonb_stats_merge(f.agg, s.agg)) FROM first_half f, second_half s;
## first_half
{
    "num": {
        "max": 400,
        "min": 0,
        "sum": 1000,
        "mean": 200.00,
        "type": "int_agg",
        "count": 5,
        "stddev": 158.11,
        "variance": 25000.00,
        "sum_sq_diff": 100000.00,
        "coefficient_of_variation_pct": 79.06
    },
    "str": {
        "type": "str_agg",
        "counts": {
            "a": 1,
            "b": 2,
            "c": 2
        }
    },
    "bool": {
        "type": "bool_agg",
        "counts": {
            "true": 3,
            "false": 2
        }
    },
    "type": "stats_agg"
}
## second_half
{
    "num": {
        "max": 900,
        "min": 500,
        "sum": 3500,
        "mean": 700.00,
        "type": "int_agg",
        "count": 5,
        "stddev": 158.11,
        "variance": 25000.00,
        "sum_sq_diff": 100000.00,
        "coefficient_of_variation_pct": 22.59
    },
    "str": {
        "type": "str_agg",
        "counts": {
            "c": 1,
            "d": 4
        }
    },
    "bool": {
        "type": "bool_agg",
        "counts": {
            "true": 3,
            "false": 2
        }
    },
    "type": "stats_agg"
}
## jsonb_stats_merge_agg
{
    "num": {
        "max": 900,
        "min": 0,
        "sum": 4500,
        "mean": 450.00,
        "type": "int_agg",
        "count": 10,
        "stddev": 302.77,
        "variance": 91666.67,
        "sum_sq_diff": 825000.00,
        "coefficient_of_variation_pct": 67.28
    },
    "str": {
        "type": "str_agg",
        "counts": {
            "a": 1,
            "b": 2,
            "c": 3,
            "d": 4
        }
    },
    "bool": {
        "type": "bool_agg",
        "counts": {
            "true": 6,
            "false": 4
        }
    },
    "type": "stats_agg"
}
## jsonb_stats_merge
{
    "num": {
        "max": 900,
        "min": 0,
        "sum": 4500,
        "mean": 450,
        "type": "int_agg",
        "count": 10,
        "sum_sq_diff": 825000
    },
    "str": {
        "type": "str_agg",
        "counts": {
            "a": 1,
            "b": 2,
            "c": 3,
            "d": 4
        }
    },
    "bool": {
        "type": "bool_agg",
        "counts": {
            "true": 6,
            "false": 4
        }
    },
    "type": "stats_agg"
}
