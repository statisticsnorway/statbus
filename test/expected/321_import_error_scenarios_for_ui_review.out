--
-- Test: Import Error Scenarios for UI Review
--
-- This test creates import jobs with various error types to allow visual
-- inspection of how errors and invalid_codes are displayed in the UI.
--
-- Run with PERSIST=true to keep data for UI review:
--   PERSIST=true ./devops/manage-statbus.sh psql < test/sql/321_import_error_scenarios_for_ui_review.sql
--
-- Then view in the UI:
--   - Job list: http://localhost:3012/import/jobs
--   - Job data: http://localhost:3012/import/jobs/errors_lu_analysis/data
--
-- Error types demonstrated:
--   1. Hard errors (errors column) - rows that cannot be imported:
--      - Invalid codes (sector, legal_form, activity)
--      - Malformed dates (birth_date, valid_from, valid_to)
--      - Invalid period (valid_from > valid_to)
--      - Invalid region/country codes
--      - Missing required identifiers
--
--   2. Soft errors (invalid_codes column) - rows imported with warnings:
--      - Invalid status code (falls back to default)
--      - Invalid postal region (location still created)
--      - Domestic unit missing region (warning only)
--
-- Structure:
--   1. Setup phase: Create Norway environment and import definitions
--   2. Create jobs and upload data with errors
--   3. Process imports
--   4. Display results
--   5. Rollback unless PERSIST=true
--
BEGIN;
\i test/setup.sql
\echo -- test/setup.sql output suppressed for cleaner test output
-- test/setup.sql output suppressed for cleaner test output
\set ECHO none
\echo -- test/setup.sql done, test output follows
-- test/setup.sql done, test output follows
-- Reset import_job sequence to ensure deterministic job IDs
ALTER TABLE public.import_job ALTER COLUMN id RESTART WITH 1;
CALL test.set_user_from_email('test.admin@statbus.org');
-- ============================================================================
-- PHASE 1: SETUP
-- ============================================================================
\echo '=== Phase 1: Setting up Norway environment ==='
=== Phase 1: Setting up Norway environment ===
\i samples/norway/getting-started.sql
\i samples/norway/settings.sql
INSERT INTO settings(activity_category_standard_id,country_id)
SELECT (SELECT id FROM activity_category_standard WHERE code = 'nace_v2.1')
     , (SELECT id FROM public.country WHERE iso_2 = 'NO')
ON CONFLICT (only_one_setting)
DO UPDATE SET
   activity_category_standard_id = EXCLUDED.activity_category_standard_id,
   country_id = EXCLUDED.country_id
   WHERE settings.only_one_setting = EXCLUDED.only_one_setting;
;
\i samples/norway/activity_category/activity_category_norway.sql
\copy public.activity_category_available_custom FROM 'samples/norway/activity_category/activity_category_norway.csv' WITH (FORMAT csv, DELIMITER ',', QUOTE '"', HEADER true);
\i samples/norway/regions/norway-regions-2024.sql
\copy public.region_upload(path, name) FROM 'samples/norway/regions/norway-regions-2024.csv' WITH (FORMAT csv, DELIMITER ',', QUOTE '"', HEADER true);
\i samples/norway/sector/sector_norway.sql
\copy public.sector_custom_only FROM 'samples/norway/sector/sector_norway.csv' WITH (FORMAT csv, DELIMITER ',', QUOTE '"', HEADER true);
\i samples/norway/legal_form/legal_form_norway.sql
\copy public.legal_form_custom_only FROM 'samples/norway/legal_form/legal_form_norway.csv' WITH (FORMAT csv, DELIMITER ',', QUOTE '"', HEADER true);
\i samples/norway/data_source/data_source_norway.sql
\copy public.data_source_custom (code, name) FROM 'samples/norway/data_source/data_source_norway.csv' WITH (FORMAT csv, DELIMITER ',', QUOTE '"', HEADER true);
-- ============================================================================
-- PHASE 2: CREATE JOBS AND UPLOAD DATA
-- ============================================================================
\echo '=== Phase 2: Creating import jobs with error scenarios ==='
=== Phase 2: Creating import jobs with error scenarios ===
-- Job 1: Legal Unit with various analysis errors (comprehensive)
DO $$
DECLARE v_definition_id INT;
BEGIN
    SELECT id INTO v_definition_id FROM public.import_definition WHERE slug = 'legal_unit_source_dates';
    INSERT INTO public.import_job (definition_id, slug, description, note, edit_comment)
    VALUES (v_definition_id, 'errors_lu_analysis', 'LU Import with Analysis Errors',
            'Demonstrates various hard errors (invalid codes, malformed dates) and soft errors (invalid_codes that fall back to defaults)',
            'Test 404: Error scenarios for UI review');
END $$;
\echo 'Uploading data with various error types...'
Uploading data with various error types...
INSERT INTO public.errors_lu_analysis_upload(
    tax_ident, name, valid_from, valid_to, 
    sector_code, legal_form_code, primary_activity_category_code, 
    birth_date, death_date,
    secondary_activity_category_code, 
    physical_address_part1, physical_region_code, physical_country_iso_2, physical_latitude,
    postal_address_part1, postal_region_code, postal_country_iso_2,
    status_code, data_source_code, unit_size_code,
    employees, turnover
) VALUES
-- === VALID ROWS (for comparison) ===
('VALID001', 'Valid Company Alpha', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2020-01-15', NULL, NULL, 'Main Street 1', '0301', 'NO', '59.9139', NULL, NULL, NULL, 'active', NULL, NULL, 50, 1000000),
('VALID002', 'Valid Company Beta', '2023-01-01', '2023-12-31', '2100', 'ENK', '47.110', '2019-06-01', NULL, NULL, 'Market Square 5', '1103', 'NO', '58.9700', NULL, NULL, NULL, 'active', NULL, NULL, 10, 250000),
-- === HARD ERRORS: Invalid Codes ===
('ERR_SEC', 'Invalid Sector Code', '2023-01-01', '2023-12-31', 'INVALID_SECTOR', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_LF', 'Invalid Legal Form', '2023-01-01', '2023-12-31', '2100', 'INVALID_LF', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_ACT1', 'Invalid Primary Activity', '2023-01-01', '2023-12-31', '2100', 'AS', '99.999', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_ACT2', 'Invalid Secondary Activity', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, '88.888', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-- === HARD ERRORS: Malformed Dates ===
('ERR_VF', 'Malformed ValidFrom', 'NOT_A_DATE', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_VT', 'Malformed ValidTo', '2023-01-01', 'ALSO_NOT_DATE', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_BD', 'Malformed BirthDate', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-13-45', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_DD', 'Malformed DeathDate', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', '2023-02-30', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'inactive', NULL, NULL, NULL, NULL),
-- === HARD ERRORS: Invalid Period ===
-- NOTE: Commented out because this causes a batch-level exception during
-- analyse_valid_time which stops all row processing. This demonstrates a
-- job-level failure vs row-level errors. Uncomment to test job failures.
-- ('ERR_PER', 'Invalid Period (from > to)', '2023-12-31', '2023-01-01', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-- === HARD ERRORS: Missing Required Dates ===
('ERR_NVF', 'Missing ValidFrom', NULL, '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_NVT', 'Missing ValidTo', '2023-01-01', NULL, '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-- === HARD ERRORS: Location Errors ===
('ERR_REG', 'Invalid Region Code', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, 'Street 1', 'INVALID_REG', 'NO', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_CTY', 'Invalid Country Code', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, 'Street 1', '0301', 'ZZ', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_LAT', 'Invalid Latitude Format', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, 'NO', 'not_a_number', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
('ERR_LATR', 'Latitude Out of Range', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, 'NO', '95.0', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
-- === HARD ERRORS: Other Invalid Codes ===
('ERR_DS', 'Invalid DataSource', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'INVALID_DS', NULL, NULL, NULL),
('ERR_US', 'Invalid UnitSize', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'HUGE', NULL, NULL),
-- === HARD ERRORS: Invalid Statistical Variables ===
('ERR_EMP', 'Invalid Employees (not integer)', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'fifty', NULL),
('ERR_TUR', 'Invalid Turnover (not numeric)', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'one million'),
-- === SOFT ERRORS: Invalid Codes with Fallback (invalid_codes column) ===
('WARN_STS', 'Invalid Status (uses default)', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'sleeping_unknown', NULL, NULL, 25, 500000),
('WARN_PREG', 'Invalid Postal Region', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, 'Office Park 10', '0301', 'NO', NULL, 'PO Box 123', 'INVALID_POSTAL', NULL, 'active', NULL, NULL, 15, 300000),
('WARN_PCTY', 'Invalid Postal Country', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, 'Harbor Street 7', '1103', 'NO', NULL, 'Overseas Box', NULL, 'XX', 'active', NULL, NULL, 8, 150000),
-- === SOFT ERRORS: Missing Region Warnings ===
('WARN_NREG', 'Domestic Missing Region (warning)', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, 'Unknown Location', NULL, 'NO', NULL, NULL, NULL, NULL, 'active', NULL, NULL, 5, 100000),
('OK_FREG', 'Foreign Missing Region (ok)', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, 'International HQ', NULL, 'SE', NULL, NULL, NULL, NULL, 'active', NULL, NULL, 100, 5000000),
('WARN_FDREG', 'Foreign with Domestic Region (error)', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110', '2023-01-01', NULL, NULL, 'Mixed Location', '0301', 'SE', NULL, NULL, NULL, NULL, 'active', NULL, NULL, 20, 400000);
\echo 'Upload complete. Row count:'
Upload complete. Row count:
SELECT COUNT(*) as uploaded_rows FROM public.errors_lu_analysis_upload;
 uploaded_rows 
---------------
            26
(1 row)

-- Job 2: Formal Establishment with link errors
DO $$
DECLARE 
    v_lu_def_id INT;
    v_es_def_id INT;
BEGIN
    SELECT id INTO v_lu_def_id FROM public.import_definition WHERE slug = 'legal_unit_source_dates';
    SELECT id INTO v_es_def_id FROM public.import_definition WHERE slug = 'establishment_for_lu_source_dates';
    
    -- First create some valid LUs for the ES to link to
    INSERT INTO public.import_job (definition_id, slug, description, note, edit_comment)
    VALUES (v_lu_def_id, 'errors_lu_for_es', 'Valid LUs for Establishment Tests',
            'These LUs are created to test establishment linking errors',
            'Test 404');
    
    -- Then create ES job with link errors
    INSERT INTO public.import_job (definition_id, slug, description, note, edit_comment)
    VALUES (v_es_def_id, 'errors_es_formal', 'Formal ES with Link Errors',
            'Demonstrates establishment-to-LU linking errors',
            'Test 404');
END $$;
-- Upload valid LUs first
INSERT INTO public.errors_lu_for_es_upload(tax_ident, name, valid_from, valid_to, sector_code, legal_form_code, primary_activity_category_code)
VALUES
('LU_FOR_ES_001', 'Parent Company One', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110'),
('LU_FOR_ES_002', 'Parent Company Two', '2023-01-01', '2023-12-31', '2100', 'ENK', '47.110');
-- Upload ES with various link errors
INSERT INTO public.errors_es_formal_upload(tax_ident, name, valid_from, valid_to, primary_activity_category_code, legal_unit_tax_ident)
VALUES
-- Valid establishment
('ES_VALID', 'Valid Establishment', '2023-01-01', '2023-12-31', '01.110', 'LU_FOR_ES_001'),
-- Missing LU link
('ES_NO_LINK', 'ES Missing LU Link', '2023-01-01', '2023-12-31', '01.110', NULL),
-- Non-existent LU
('ES_BAD_LINK', 'ES Links to Non-Existent LU', '2023-01-01', '2023-12-31', '01.110', 'LU_DOES_NOT_EXIST'),
-- Invalid activity code
('ES_BAD_ACT', 'ES Invalid Activity', '2023-01-01', '2023-12-31', '99.999', 'LU_FOR_ES_002');
-- Job 3: Missing identifier errors
DO $$
DECLARE v_definition_id INT;
BEGIN
    SELECT id INTO v_definition_id FROM public.import_definition WHERE slug = 'legal_unit_source_dates';
    INSERT INTO public.import_job (definition_id, slug, description, note, edit_comment)
    VALUES (v_definition_id, 'errors_lu_missing_ident', 'LU Missing Identifiers',
            'Demonstrates errors when required identifiers are missing',
            'Test 404');
END $$;
INSERT INTO public.errors_lu_missing_ident_upload(tax_ident, name, valid_from, valid_to, sector_code, legal_form_code, primary_activity_category_code)
VALUES
(NULL, 'Missing Tax Ident', '2023-01-01', '2023-12-31', '2100', 'AS', '01.110'),
('HAS_IDENT', NULL, '2023-01-01', '2023-12-31', '2100', 'AS', '01.110');
-- ============================================================================
-- PHASE 3: PROCESS IMPORTS
-- ============================================================================
\echo '=== Phase 3: Processing imports ==='
=== Phase 3: Processing imports ===
-- Process all pending import tasks
CALL worker.process_tasks(p_queue => 'import');
WARNING:  [Job 1] process_location: Error during temporal_merge for step physical_location: new row for relation "location" violates check constraint "coordinates require both latitude and longitude". SQLSTATE: 23514
WARNING:  [Job 1] Error processing batch 1: new row for relation "location" violates check constraint "coordinates require both latitude and longitude". Context: SQL statement "
                                WITH founding_plan_ops AS (
                                    SELECT DISTINCT ON (p.grouping_key)
                                        p.plan_op_seq,
                                        p.causal_id,
                                        p.grouping_key,
                                        p.new_valid_range,
                                        p.entity_keys || p.data as full_data
                                    FROM temporal_merge_plan p
                                    WHERE p.operation = 'INSERT' AND p.is_new_entity
                                    ORDER BY p.grouping_key, p.plan_op_seq
                                ),
                                id_map_cte AS (
                                    MERGE INTO location t
                                    USING founding_plan_ops s ON false
                                    WHEN NOT MATCHED THEN
                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)
                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)
                                    RETURNING t.*, s.causal_id, s.grouping_key
                                )
                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)
                                SELECT
                                    ir.grouping_key,
                                    ir.causal_id,
                                    jsonb_build_object('id', ir.id)
                                FROM id_map_cte ir;
                            "
PL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE
SQL statement "CALL sql_saga.temporal_merge_execute(
            target_table => temporal_merge.target_table,
            source_table => temporal_merge.source_table,
            identity_columns => v_identity_cols_discovered,
            mode => temporal_merge.mode,
            era_name => temporal_merge.era_name,
            row_id_column => temporal_merge.row_id_column,
            founding_id_column => temporal_merge.founding_id_column,
            update_source_with_identity => temporal_merge.update_source_with_identity,
            lookup_columns => v_natural_identity_cols_discovered,
            delete_mode => temporal_merge.delete_mode,
            update_source_with_feedback => temporal_merge.update_source_with_feedback,
            feedback_status_column => temporal_merge.feedback_status_column,
            feedback_status_key => temporal_merge.feedback_status_key,
            feedback_error_column => temporal_merge.feedback_error_column,
            feedback_error_key => temporal_merge.feedback_error_key,
            ephemeral_columns => temporal_merge.ephemeral_columns,
            delay_constraints => temporal_merge.delay_constraints
        )"
PL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL
SQL statement "CALL sql_saga.temporal_merge(
            target_table => 'public.location'::regclass,
            source_table => v_source_view_name::regclass,
            primary_identity_columns => ARRAY['id'],
            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],
            mode => v_merge_mode,
            row_id_column => 'row_id',
            founding_id_column => 'founding_row_id',
            update_source_with_identity => true,
            update_source_with_feedback => true,
            feedback_status_column => 'merge_status',
            feedback_status_key => p_step_code,
            feedback_error_column => 'errors',
            feedback_error_key => p_step_code
        )"
PL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL
SQL statement "CALL import.process_location($1, $2, $3)"
PL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE
SQL statement "CALL admin.import_job_process_batch(job, v_current_batch)"
PL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL
PL/pgSQL function admin.import_job_process(integer) line 169 at assignment
SQL statement "CALL admin.import_job_process(job_id)"
PL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL
SQL statement "CALL admin.import_job_process($1)"
PL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE. Marking batch rows as error and failing job.
WARNING:  [Job 1] Error detected during processing phase: {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "error_in_processing_batch": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}. Job already transitioned to finished.
-- ============================================================================
-- PHASE 4: DISPLAY RESULTS
-- ============================================================================
\echo '=== Phase 4: Results Summary ==='
=== Phase 4: Results Summary ===
\echo ''

\echo '--- Import Job Status ---'
--- Import Job Status ---
SELECT 
    slug,
    state,
    total_rows,
    imported_rows,
    total_rows - COALESCE(imported_rows, 0) as failed_rows,
    error IS NOT NULL AS has_job_error
FROM public.import_job 
WHERE slug LIKE 'errors_%'
ORDER BY slug;
          slug           |  state   | total_rows | imported_rows | failed_rows | has_job_error 
-------------------------+----------+------------+---------------+-------------+---------------
 errors_es_formal        | finished |          4 |             2 |           2 | f
 errors_lu_analysis      | failed   |         26 |             0 |          26 | t
 errors_lu_for_es        | finished |          2 |             2 |           0 | f
 errors_lu_missing_ident | finished |          2 |             0 |           2 | f
(4 rows)

\echo ''

\echo '--- Job 1: LU Analysis Errors (errors_lu_analysis) ---'
--- Job 1: LU Analysis Errors (errors_lu_analysis) ---
\echo 'Job-level error (if any):'
Job-level error (if any):
SELECT error FROM public.import_job WHERE slug = 'errors_lu_analysis';
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             error                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "error_in_processing_batch": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}
(1 row)

\echo 'All rows (showing state, action, errors, invalid_codes):'
All rows (showing state, action, errors, invalid_codes):
SELECT 
    row_id,
    tax_ident_raw as tax_ident,
    LEFT(name_raw, 30) as name,
    state,
    action,
    CASE WHEN errors IS NOT NULL AND errors != '{}' THEN errors ELSE NULL END as errors,
    CASE WHEN invalid_codes IS NOT NULL AND invalid_codes != '{}' THEN invalid_codes ELSE NULL END as invalid_codes
FROM public.errors_lu_analysis_data
ORDER BY row_id;
 row_id | tax_ident  |              name              | state | action |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         errors                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                          invalid_codes                          
--------+------------+--------------------------------+-------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------
      1 | VALID001   | Valid Company Alpha            | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | 
      2 | VALID002   | Valid Company Beta             | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"primary_activity_category_code_raw": "47.110"}
      3 | ERR_SEC    | Invalid Sector Code            | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"sector_code_raw": "INVALID_SECTOR"}
      4 | ERR_LF     | Invalid Legal Form             | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"legal_form_code_raw": "INVALID_LF"}
      5 | ERR_ACT1   | Invalid Primary Activity       | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"primary_activity_category_code_raw": "99.999"}
      6 | ERR_ACT2   | Invalid Secondary Activity     | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"secondary_activity_category_code_raw": "88.888"}
      7 | ERR_VF     | Malformed ValidFrom            | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "valid_from_raw": "Invalid date format: 'NOT_A_DATE'. SQLSTATE: 22007", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                       | 
      8 | ERR_VT     | Malformed ValidTo              | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "valid_to_raw": "Invalid date format: 'ALSO_NOT_DATE'. SQLSTATE: 22007", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                      | 
      9 | ERR_BD     | Malformed BirthDate            | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"birth_date_raw": "2023-13-45"}
     10 | ERR_DD     | Malformed DeathDate            | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"death_date_raw": "2023-02-30", "status_code_raw": "inactive"}
     11 | ERR_NVF    | Missing ValidFrom              | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "valid_from_raw": "Missing mandatory value", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                  | 
     12 | ERR_NVT    | Missing ValidTo                | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "valid_to_raw": "Missing mandatory value", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                    | 
     13 | ERR_REG    | Invalid Region Code            | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"physical_region_code_raw": "INVALID_REG"}
     14 | ERR_CTY    | Invalid Country Code           | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\"", "physical_country_iso_2_raw": "Country is required and must be valid when other physical address details are provided."}      | 
     15 | ERR_LAT    | Invalid Latitude Format        | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\"", "physical_latitude_raw": "Value 'not_a_number' is not a valid numeric representation for type NUMERIC(9,6). SQLSTATE: 22P02"} | {"physical_latitude_raw": "not_a_number"}
     16 | ERR_LATR   | Latitude Out of Range          | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\"", "physical_latitude_raw": "Value 95.000000 out of range. Expected -90 to 90."}                                                 | {"physical_latitude_raw": "95.0"}
     17 | ERR_DS     | Invalid DataSource             | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"data_source_code_raw": "INVALID_DS"}
     18 | ERR_US     | Invalid UnitSize               | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"unit_size_code_raw": "HUGE"}
     19 | ERR_EMP    | Invalid Employees (not integer | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "employees_raw": "Invalid integer format: 'fifty'. SQLSTATE: 22P02", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                          | 
     20 | ERR_TUR    | Invalid Turnover (not numeric) | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "turnover_raw": "Invalid numeric format: 'one million'. SQLSTATE: 22P02", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                     | 
     21 | WARN_STS   | Invalid Status (uses default)  | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"status_code_raw": "sleeping_unknown"}
     22 | WARN_PREG  | Invalid Postal Region          | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\"", "postal_country_iso_2_raw": "Country is required and must be valid when other postal address details are provided."}          | 
     23 | WARN_PCTY  | Invalid Postal Country         | error | skip   | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\"", "postal_country_iso_2_raw": "Country is required and must be valid when other postal address details are provided."}          | 
     24 | WARN_NREG  | Domestic Missing Region (warni | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | {"physical_region_code_raw": null}
     25 | OK_FREG    | Foreign Missing Region (ok)    | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | 
     26 | WARN_FDREG | Foreign with Domestic Region ( | error | use    | {"context": "SQL statement \"\n                                WITH founding_plan_ops AS (\n                                    SELECT DISTINCT ON (p.grouping_key)\n                                        p.plan_op_seq,\n                                        p.causal_id,\n                                        p.grouping_key,\n                                        p.new_valid_range,\n                                        p.entity_keys || p.data as full_data\n                                    FROM temporal_merge_plan p\n                                    WHERE p.operation = 'INSERT' AND p.is_new_entity\n                                    ORDER BY p.grouping_key, p.plan_op_seq\n                                ),\n                                id_map_cte AS (\n                                    MERGE INTO location t\n                                    USING founding_plan_ops s ON false\n                                    WHEN NOT MATCHED THEN\n                                        INSERT (type, address_part1, address_part2, address_part3, postcode, postplace, region_id, country_id, latitude, longitude, altitude, establishment_id, legal_unit_id, data_source_id, edit_comment, edit_by_user_id, edit_at, valid_range)\n                                        VALUES ((s.full_data->>'type')::location_type, (s.full_data->>'address_part1')::character varying, (s.full_data->>'address_part2')::character varying, (s.full_data->>'address_part3')::character varying, (s.full_data->>'postcode')::character varying, (s.full_data->>'postplace')::character varying, (s.full_data->>'region_id')::integer, (s.full_data->>'country_id')::integer, (s.full_data->>'latitude')::numeric, (s.full_data->>'longitude')::numeric, (s.full_data->>'altitude')::numeric, (s.full_data->>'establishment_id')::integer, (s.full_data->>'legal_unit_id')::integer, (s.full_data->>'data_source_id')::integer, (s.full_data->>'edit_comment')::character varying, (s.full_data->>'edit_by_user_id')::integer, COALESCE((s.full_data->>'edit_at')::timestamp with time zone, statement_timestamp()), s.new_valid_range::daterange)\n                                    RETURNING t.*, s.causal_id, s.grouping_key\n                                )\n                                INSERT INTO temporal_merge_entity_id_map (grouping_key, causal_id, new_entity_keys)\n                                SELECT\n                                    ir.grouping_key,\n                                    ir.causal_id,\n                                    jsonb_build_object('id', ir.id)\n                                FROM id_map_cte ir;\n                            \"\nPL/pgSQL function sql_saga.temporal_merge_execute(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 866 at EXECUTE\nSQL statement \"CALL sql_saga.temporal_merge_execute(\n            target_table => temporal_merge.target_table,\n            source_table => temporal_merge.source_table,\n            identity_columns => v_identity_cols_discovered,\n            mode => temporal_merge.mode,\n            era_name => temporal_merge.era_name,\n            row_id_column => temporal_merge.row_id_column,\n            founding_id_column => temporal_merge.founding_id_column,\n            update_source_with_identity => temporal_merge.update_source_with_identity,\n            lookup_columns => v_natural_identity_cols_discovered,\n            delete_mode => temporal_merge.delete_mode,\n            update_source_with_feedback => temporal_merge.update_source_with_feedback,\n            feedback_status_column => temporal_merge.feedback_status_column,\n            feedback_status_key => temporal_merge.feedback_status_key,\n            feedback_error_column => temporal_merge.feedback_error_column,\n            feedback_error_key => temporal_merge.feedback_error_key,\n            ephemeral_columns => temporal_merge.ephemeral_columns,\n            delay_constraints => temporal_merge.delay_constraints\n        )\"\nPL/pgSQL function sql_saga.temporal_merge(regclass,regclass,text[],sql_saga.temporal_merge_mode,name,name,name,boolean,text[],sql_saga.temporal_merge_delete_mode,boolean,name,name,name,name,text[],boolean) line 250 at CALL\nSQL statement \"CALL sql_saga.temporal_merge(\n            target_table => 'public.location'::regclass,\n            source_table => v_source_view_name::regclass,\n            primary_identity_columns => ARRAY['id'],\n            natural_identity_columns => ARRAY['legal_unit_id', 'establishment_id', 'type'],\n            mode => v_merge_mode,\n            row_id_column => 'row_id',\n            founding_id_column => 'founding_row_id',\n            update_source_with_identity => true,\n            update_source_with_feedback => true,\n            feedback_status_column => 'merge_status',\n            feedback_status_key => p_step_code,\n            feedback_error_column => 'errors',\n            feedback_error_key => p_step_code\n        )\"\nPL/pgSQL function import.process_location(integer,integer,text) line 141 at CALL\nSQL statement \"CALL import.process_location($1, $2, $3)\"\nPL/pgSQL function admin.import_job_process_batch(import_job,integer) line 39 at EXECUTE\nSQL statement \"CALL admin.import_job_process_batch(job, v_current_batch)\"\nPL/pgSQL function admin.import_job_processing_phase(import_job) line 24 at CALL\nPL/pgSQL function admin.import_job_process(integer) line 169 at assignment\nSQL statement \"CALL admin.import_job_process(job_id)\"\nPL/pgSQL function admin.import_job_process(jsonb) line 9 at CALL\nSQL statement \"CALL admin.import_job_process($1)\"\nPL/pgSQL function worker.process_tasks(integer,integer,text,bigint,worker.process_mode) line 195 at EXECUTE", "process_batch_error": "new row for relation \"location\" violates check constraint \"coordinates require both latitude and longitude\""}                                                                                                                               | 
(26 rows)

\echo ''

\echo '--- Job 2: Formal ES Link Errors (errors_es_formal) ---'
--- Job 2: Formal ES Link Errors (errors_es_formal) ---
SELECT 
    row_id,
    tax_ident_raw as tax_ident,
    name_raw as name,
    state,
    action,
    errors,
    invalid_codes
FROM public.errors_es_formal_data
ORDER BY row_id;
 row_id |  tax_ident  |            name             |   state   | action |                                                            errors                                                             |                  invalid_codes                   
--------+-------------+-----------------------------+-----------+--------+-------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------
      1 | ES_VALID    | Valid Establishment         | processed | use    | {}                                                                                                                            | {}
      2 | ES_NO_LINK  | ES Missing LU Link          | error     | skip   | {"legal_unit_tax_ident_raw": "Missing legal unit identifier.", "legal_unit_stat_ident_raw": "Missing legal unit identifier."} | {}
      3 | ES_BAD_LINK | ES Links to Non-Existent LU | error     | skip   | {"legal_unit_tax_ident_raw": "Legal unit not found with provided identifiers."}                                               | {}
      4 | ES_BAD_ACT  | ES Invalid Activity         | processed | use    | {}                                                                                                                            | {"primary_activity_category_code_raw": "99.999"}
(4 rows)

\echo ''

\echo '--- Job 3: Missing Identifier Errors (errors_lu_missing_ident) ---'
--- Job 3: Missing Identifier Errors (errors_lu_missing_ident) ---
SELECT 
    row_id,
    tax_ident_raw as tax_ident,
    name_raw as name,
    state,
    action,
    errors,
    invalid_codes
FROM public.errors_lu_missing_ident_data
ORDER BY row_id;
 row_id | tax_ident |       name        | state | action |                                          errors                                           | invalid_codes 
--------+-----------+-------------------+-------+--------+-------------------------------------------------------------------------------------------+---------------
      1 |           | Missing Tax Ident | error | skip   | {"tax_ident_raw": "No identifier specified", "stat_ident_raw": "No identifier specified"} | {}
      2 | HAS_IDENT |                   | error | skip   | {"name_raw": "Missing required name for legal unit."}                                     | {}
(2 rows)

\echo ''

\echo '=== Summary Statistics ==='
=== Summary Statistics ===
SELECT 
    slug,
    COUNT(*) as total_rows,
    COUNT(*) FILTER (WHERE state = 'processed') as processed,
    COUNT(*) FILTER (WHERE state = 'error') as errors,
    COUNT(*) FILTER (WHERE action = 'skip') as skipped,
    COUNT(*) FILTER (WHERE errors IS NOT NULL AND errors != '{}') as rows_with_errors,
    COUNT(*) FILTER (WHERE invalid_codes IS NOT NULL AND invalid_codes != '{}') as rows_with_warnings
FROM (
    SELECT slug, state, action, errors, invalid_codes FROM public.errors_lu_analysis_data, (SELECT 'errors_lu_analysis' as slug) s
    UNION ALL
    SELECT slug, state, action, errors, invalid_codes FROM public.errors_es_formal_data, (SELECT 'errors_es_formal' as slug) s
    UNION ALL
    SELECT slug, state, action, errors, invalid_codes FROM public.errors_lu_missing_ident_data, (SELECT 'errors_lu_missing_ident' as slug) s
) combined
GROUP BY slug
ORDER BY slug;
          slug           | total_rows | processed | errors | skipped | rows_with_errors | rows_with_warnings 
-------------------------+------------+-----------+--------+---------+------------------+--------------------
 errors_es_formal        |          4 |         2 |      2 |       2 |                2 |                  1
 errors_lu_analysis      |         26 |         0 |     26 |      11 |               26 |                 14
 errors_lu_missing_ident |          2 |         0 |      2 |       2 |                2 |                  0
(3 rows)

\echo ''

\echo '=== View in UI ==='
=== View in UI ===
\echo 'Job list:     http://localhost:3012/import/jobs'
Job list:     http://localhost:3012/import/jobs
\echo 'LU Errors:    http://localhost:3012/import/jobs/errors_lu_analysis/data'
LU Errors:    http://localhost:3012/import/jobs/errors_lu_analysis/data
\echo 'ES Errors:    http://localhost:3012/import/jobs/errors_es_formal/data'
ES Errors:    http://localhost:3012/import/jobs/errors_es_formal/data
\echo 'Missing ID:   http://localhost:3012/import/jobs/errors_lu_missing_ident/data'
Missing ID:   http://localhost:3012/import/jobs/errors_lu_missing_ident/data
-- ============================================================================
-- PHASE 5: ROLLBACK UNLESS PERSIST
-- ============================================================================
\i test/rollback_unless_persist_is_specified.sql
\echo -- test/rollback_unless_persist_is_specified.sql output suppressed
-- test/rollback_unless_persist_is_specified.sql output suppressed
\set ECHO none
