## SQL Test Error and Assertion Handling

When writing SQL tests for `pg_regress` (executed via `./devops/manage-statbus.sh test ...`), it's crucial to handle errors and assertions correctly to ensure test isolation and clear reporting.

See `test/sql/014_test_template_for_error_handling.sql` for runnable examples of these patterns.

### Pattern A: Catching `ASSERT` Failures and Isolating Test Units

This is the **recommended pattern for most test units**, especially when using `ASSERT`. It ensures that an `ASSERT` failure (or other SQL error) is caught, reported, and that the test unit's changes are rolled back without aborting the entire test file's transaction.

**Structure:**
Each logical test unit is wrapped in a `DO` block. Inside this `DO` block, the core test logic (including `ASSERT` statements and any DML/DDL) is further wrapped in a nested `BEGIN ... EXCEPTION ... END;` sub-block.

```sql
-- Example of Pattern A
DO $$
BEGIN
    -- This outer BEGIN is part of the DO block structure.
    -- The nested BEGIN/EXCEPTION/END provides the error catching and sub-transaction.
    BEGIN
        RAISE NOTICE 'Test Unit Name: Starting scenario.';
        -- Your DDL/DML and test logic here
        CREATE TEMP TABLE temp_example (id int);
        INSERT INTO temp_example VALUES (1);
        ASSERT (SELECT COUNT(*) FROM temp_example) > 0, 'Assertion message with details if it fails.';
        RAISE NOTICE 'Test Unit Name: Scenario PASSED.';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN -- Catches ASSERT failures (SQLSTATE P0004)
            RAISE NOTICE 'Test Unit Name: Scenario FAILED (ASSERT_FAILURE): %', SQLERRM;
            -- Effects of this sub-block are implicitly rolled back.
        WHEN OTHERS THEN -- Catches other SQL errors
            RAISE NOTICE 'Test Unit Name: Scenario FAILED (OTHER ERROR): %', SQLERRM;
            -- Effects of this sub-block are implicitly rolled back.
    END; -- End of nested error-catching block
    
    -- Cleanup that should run regardless of sub-block success/failure (if needed)
    DROP TABLE IF EXISTS temp_example; 
END; -- End of DO block
$$;
```

**Key Points for Pattern A:**
*   The nested `BEGIN/EXCEPTION/END` sub-block acts like a savepoint. If an error occurs and is caught by its `EXCEPTION` clause, the sub-block's effects are rolled back.
*   `ASSERT` failures (condition `ASSERT_FAILURE`, SQLSTATE `P0004`) are caught by `WHEN ASSERT_FAILURE THEN ...` or `WHEN OTHERS THEN ...`.
*   This pattern allows multiple independent test units within a single `.sql` file, each isolated from the others' failures.

### Pattern B: Catching PL/pgSQL Runtime Errors (e.g., `RAISE EXCEPTION`)

This pattern uses a `DO` block with its own direct `EXCEPTION` clause. It's suitable for testing functions or blocks of code that are expected to `RAISE EXCEPTION` or encounter other PL/pgSQL runtime errors (e.g., division by zero, invalid dynamic SQL).

**Structure:**
```sql
-- Example of Pattern B
DO $$
BEGIN
    RAISE NOTICE 'Test Unit Name: Starting scenario expecting a RAISE EXCEPTION.';
    -- Logic that might raise a specific PL/pgSQL error
    RAISE EXCEPTION 'This is an intentional test exception.' USING ERRCODE = 'P0001';
    RAISE NOTICE 'Test Unit Name: Scenario PASSED (this should not print).';
EXCEPTION
    WHEN SQLSTATE 'P0001' THEN -- Catch specific error code
        RAISE NOTICE 'Test Unit Name: Scenario FAILED as expected (Caught P0001): %', SQLERRM;
    WHEN OTHERS THEN
        RAISE NOTICE 'Test Unit Name: Scenario FAILED with unexpected error: %', SQLERRM;
END;
$$;
```

**Key Points for Pattern B:**
*   The `EXCEPTION` clause of the `DO` block itself will catch PL/pgSQL runtime errors like those generated by `RAISE EXCEPTION`.
*   **Important:** This pattern's `EXCEPTION` clause will **NOT** catch `ASSERT` failures from within the same `DO` block. An `ASSERT` failure will directly abort the `DO` block itself. If such an abort needs to be handled gracefully by the test script, the `DO` block containing the `ASSERT` must itself be wrapped using Pattern A (see Scenario B.4 in the example template).

### Further Reading:
*   PL/pgSQL Control Structures (Error Trapping): [PostgreSQL Documentation - Trapping Errors](https://www.postgresql.org/docs/current/plpgsql-control-structures.html#PLPGSQL-ERROR-TRAPPING)
*   PL/pgSQL Assertions: [PostgreSQL Documentation - Checking Assertions](https://www.postgresql.org/docs/current/plpgsql-errors-and-messages.html#PLPGSQL-STATEMENTS-ASSERT)
*   PL/pgSQL Transaction Management: [PostgreSQL Documentation - Transaction Management](https://www.postgresql.org/docs/current/plpgsql-transactions.html)

### Common Pitfall: Misuse of SQL-level `SAVEPOINT` with PL/pgSQL `BEGIN/END`

A common mistake is attempting to manage SQL-level `SAVEPOINT`s with a top-level PL/pgSQL-style `BEGIN ... EXCEPTION ... END;` block directly in a `.sql` test script.

**Incorrect (Non-Working) Pattern:**
```sql
-- This pattern DOES NOT WORK as intended in pg_regress test scripts
SAVEPOINT my_savepoint; -- SQL-level command
BEGIN -- Intended as a PL/pgSQL block, but psql parses differently at top level
    -- Some logic, possibly a DO block
    DO $$ 
    BEGIN 
        ASSERT 1=0, 'This will fail'; 
    END; 
    $$;
    RELEASE SAVEPOINT my_savepoint; -- SQL command
EXCEPTION -- PL/pgSQL construct
    WHEN OTHERS THEN
        ROLLBACK TO SAVEPOINT my_savepoint; -- SQL command
        RAISE NOTICE 'Test FAILED: %', SQLERRM;
END; -- PL/pgSQL construct
```

**Why it Fails:**
*   `psql` (used by `pg_regress`) processes these as separate top-level commands.
*   The `SAVEPOINT my_savepoint;` command is executed.
*   The subsequent `BEGIN ... EXCEPTION ... END;` is parsed as an attempt to start a PL/pgSQL anonymous block. However, at this top level, `psql` does not link this block's transaction scope to the preceding `SAVEPOINT` in the way required for `RELEASE SAVEPOINT` or `ROLLBACK TO SAVEPOINT` to be valid *within* that PL/pgSQL block structure if they were plain SQL commands.
*   This leads to errors like "SAVEPOINT can only be used in transaction blocks" for the `SAVEPOINT` itself (if `psql` deems it outside a suitable block context at parse time) or syntax errors for `RELEASE/ROLLBACK TO SAVEPOINT` and `EXCEPTION` because they are not valid top-level SQL commands in that sequence.

**Correct Approach:**
*   To manage savepoint-like behavior and catch `ASSERT` failures, use **Pattern A**. All logic, including the error-catching `BEGIN/EXCEPTION/END` sub-block, is encapsulated within a single `DO $$ ... $$;` block.
*   The structure used in `test/sql/013_auth.sql` (after its successful refactor to Pattern A) is the correct way to implement test units. Each test unit is a self-contained `DO $$ ... $$;` block following Pattern A.
```
