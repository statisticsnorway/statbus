## SQL Test Error and Assertion Handling

When writing SQL tests for `pg_regress` (executed via `./devops/manage-statbus.sh test ...`), it's crucial to handle errors and assertions correctly to ensure test isolation and clear reporting.

See `test/sql/014_test_template_for_error_handling.sql` for runnable examples of these patterns.

### Pattern A: Catching `ASSERT` Failures and Isolating Test Units

This is the **recommended pattern for most test units**, especially when using `ASSERT`. It ensures that an `ASSERT` failure (or other SQL error) is caught, reported, and that the test unit's changes are rolled back without aborting the entire test file's transaction.

**Structure:**
Each logical test unit is wrapped in a `DO` block. Inside this `DO` block, the core test logic (including `ASSERT` statements and any DML/DDL) is further wrapped in a nested `BEGIN ... EXCEPTION ... END;` sub-block.

```sql
-- Example of Pattern A
DO $$
BEGIN
    -- This outer BEGIN is part of the DO block structure.
    -- The nested BEGIN/EXCEPTION/END provides the error catching and sub-transaction.
    BEGIN
        RAISE NOTICE 'Test Unit Name: Starting scenario.';
        -- Your DDL/DML and test logic here
        CREATE TEMP TABLE temp_example (id int);
        INSERT INTO temp_example VALUES (1);
        ASSERT (SELECT COUNT(*) FROM temp_example) > 0, 'Assertion message with details if it fails.';
        RAISE NOTICE 'Test Unit Name: Scenario PASSED.';
    EXCEPTION
        WHEN ASSERT_FAILURE THEN -- Catches ASSERT failures (SQLSTATE P0004)
            RAISE NOTICE 'Test Unit Name: Scenario FAILED (ASSERT_FAILURE): %', SQLERRM;
            -- Effects of this sub-block are implicitly rolled back.
        WHEN OTHERS THEN -- Catches other SQL errors
            RAISE NOTICE 'Test Unit Name: Scenario FAILED (OTHER ERROR): %', SQLERRM;
            -- Effects of this sub-block are implicitly rolled back.
    END; -- End of nested error-catching block
    
    -- Cleanup that should run regardless of sub-block success/failure (if needed)
    DROP TABLE IF EXISTS temp_example; 
END; -- End of DO block
$$;
```

**Key Points for Pattern A:**
*   The nested `BEGIN/EXCEPTION/END` sub-block acts like a savepoint. If an error occurs and is caught by its `EXCEPTION` clause, the sub-block's effects are rolled back.
*   `ASSERT` failures (condition `ASSERT_FAILURE`, SQLSTATE `P0004`) are caught by `WHEN ASSERT_FAILURE THEN ...` or `WHEN OTHERS THEN ...`.
*   This pattern allows multiple independent test units within a single `.sql` file, each isolated from the others' failures.

### Pattern B: Catching PL/pgSQL Runtime Errors (e.g., `RAISE EXCEPTION`)

This pattern uses a `DO` block with its own direct `EXCEPTION` clause. It's suitable for testing functions or blocks of code that are expected to `RAISE EXCEPTION` or encounter other PL/pgSQL runtime errors (e.g., division by zero, invalid dynamic SQL).

**Structure:**
```sql
-- Example of Pattern B
DO $$
BEGIN
    RAISE NOTICE 'Test Unit Name: Starting scenario expecting a RAISE EXCEPTION.';
    -- Logic that might raise a specific PL/pgSQL error
    RAISE EXCEPTION 'This is an intentional test exception.' USING ERRCODE = 'P0001';
    RAISE NOTICE 'Test Unit Name: Scenario PASSED (this should not print).';
EXCEPTION
    WHEN SQLSTATE 'P0001' THEN -- Catch specific error code
        RAISE NOTICE 'Test Unit Name: Scenario FAILED as expected (Caught P0001): %', SQLERRM;
    WHEN OTHERS THEN
        RAISE NOTICE 'Test Unit Name: Scenario FAILED with unexpected error: %', SQLERRM;
END;
$$;
```

**Key Points for Pattern B:**
*   The `EXCEPTION` clause of the `DO` block itself will catch PL/pgSQL runtime errors like those generated by `RAISE EXCEPTION`.
*   **Important:** This pattern's `EXCEPTION` clause will **NOT** catch `ASSERT` failures from within the same `DO` block. An `ASSERT` failure will directly abort the `DO` block itself. If such an abort needs to be handled gracefully by the test script, the `DO` block containing the `ASSERT` must itself be wrapped using Pattern A (see Scenario B.4 in the example template).

### Further Reading:
*   PL/pgSQL Control Structures (Error Trapping): [PostgreSQL Documentation - Trapping Errors](https://www.postgresql.org/docs/current/plpgsql-control-structures.html#PLPGSQL-ERROR-TRAPPING)
*   PL/pgSQL Assertions: [PostgreSQL Documentation - Checking Assertions](https://www.postgresql.org/docs/current/plpgsql-errors-and-messages.html#PLPGSQL-STATEMENTS-ASSERT)
*   PL/pgSQL Transaction Management: [PostgreSQL Documentation - Transaction Management](https://www.postgresql.org/docs/current/plpgsql-transactions.html)

### Common Pitfall: Misuse of SQL-level `SAVEPOINT` with PL/pgSQL `BEGIN/END`

A common mistake is attempting to manage SQL-level `SAVEPOINT`s with a top-level PL/pgSQL-style `BEGIN ... EXCEPTION ... END;` block directly in a `.sql` test script.

**Incorrect (Non-Working) Pattern:**
```sql
-- This pattern DOES NOT WORK as intended in pg_regress test scripts
SAVEPOINT my_savepoint; -- SQL-level command
BEGIN -- Intended as a PL/pgSQL block, but psql parses differently at top level
    -- Some logic, possibly a DO block
    DO $$ 
    BEGIN 
        ASSERT 1=0, 'This will fail'; 
    END; 
    $$;
    RELEASE SAVEPOINT my_savepoint; -- SQL command
EXCEPTION -- PL/pgSQL construct
    WHEN OTHERS THEN
        ROLLBACK TO SAVEPOINT my_savepoint; -- SQL command
        RAISE NOTICE 'Test FAILED: %', SQLERRM;
END; -- PL/pgSQL construct
```

**Why it Fails:**
*   `psql` (used by `pg_regress`) processes these as separate top-level commands.
*   The `SAVEPOINT my_savepoint;` command is executed.
*   The subsequent `BEGIN ... EXCEPTION ... END;` is parsed as an attempt to start a PL/pgSQL anonymous block. However, at this top level, `psql` does not link this block's transaction scope to the preceding `SAVEPOINT` in the way required for `RELEASE SAVEPOINT` or `ROLLBACK TO SAVEPOINT` to be valid *within* that PL/pgSQL block structure if they were plain SQL commands.
*   This leads to errors like "SAVEPOINT can only be used in transaction blocks" for the `SAVEPOINT` itself (if `psql` deems it outside a suitable block context at parse time) or syntax errors for `RELEASE/ROLLBACK TO SAVEPOINT` and `EXCEPTION` because they are not valid top-level SQL commands in that sequence.

**Correct Approach:**
*   To manage savepoint-like behavior and catch `ASSERT` failures, use **Pattern A**. All logic, including the error-catching `BEGIN/EXCEPTION/END` sub-block, is encapsulated within a single `DO $$ ... $$;` block.
*   The structure used in `test/sql/013_auth.sql` (after its successful refactor to Pattern A) is the correct way to implement test units. Each test unit is a self-contained `DO $$ ... $$;` block following Pattern A.

## psql Meta-command Limitations in Tests

When writing test scripts that are run by `psql` (like those in `pg_regress`), it's important to understand the limitations of its meta-commands (commands starting with `\`, like `\copy` and `\gexec`).

### `\copy` Does Not Support Variables for Table Names

The `\copy` meta-command is used to copy data between a file (on the client side) and a table. A common pitfall is attempting to use a `psql` variable (set via `\set`) for the table name. `psql` does not perform variable substitution for the table name argument of `\copy`.

**Incorrect Pattern:**
```sql
-- This will fail
\set my_table 'public.my_data_table'
-- The following command fails because :my_table is not expanded.
\copy :my_table FROM 'my_data.csv';
-- ERROR: syntax error at or near ":"
```

### `\gexec` Cannot Execute Meta-commands

Another approach to dynamic SQL is using `\gexec`, which executes the SQL query or queries returned by a `SELECT` statement. However, `\gexec` can only execute **SQL commands**, not other `psql` meta-commands. Attempting to generate a `\copy` command dynamically will fail.

**Incorrect Pattern:**
```sql
-- This will fail because \gexec cannot execute the \copy meta-command
SELECT format($$\copy %I FROM 'my_data.csv'$$, 'public.my_data_table') \gexec;
-- ERROR: syntax error at or near "\"
-- (The psql parser sees `\copy` and reports an error because it's not valid SQL for execution)
```

### Solution for Dynamic Table Names in `\copy`

Given the previously mentioned limitations, the only recommended way to handle `\copy` in tests is to hard-code table names.

#### Hard-Code the Table Name (The Only Recommended Solution)

For tests, simplicity and predictability are key. The most reliable solution is to hard-code the table name. If a test script dynamically generates a table name (e.g., based on the current year), the subsequent `\copy` command must use that explicit, hard-coded name. This avoids complex scripting and makes the test's behavior explicit.

This was the solution applied in `test/sql/310_import_jobs_for_brreg_selection.sql`.

**Correct Pattern (for a test running in 2025):**
```sql
-- In this test, the table name is dynamically generated in the setup logic,
-- but for the \copy command itself, we use the known, final table name.
\copy public.import_hovedenhet_2025_selection_upload FROM 'tmp/enheter.csv' WITH CSV HEADER
```

*Note on Why SQL `COPY` is Not a Viable Alternative*: The server-side SQL `COPY` command (as opposed to the `psql` client-side `\copy` meta-command) might seem like an alternative because it can be used within dynamic SQL (`\gexec`). However, `COPY` requires the data file to be accessible on the database server's filesystem. In our Docker-based testing environment, this would require copying test files into the database container, which is an anti-pattern we avoid for test portability and simplicity. Therefore, `COPY` is not a viable solution for our tests.
```
