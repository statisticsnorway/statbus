-- This test verifies that all public tables have RLS enabled and all public
-- views have proper grants. It also generates security documentation at
-- doc/db/security.md.
--
-- When a developer adds a new table without RLS, this test fails and the
-- diff shows exactly which table is missing and the fix command to add
-- to their migration.

-- Turn off decorative output for clean markdown generation
\t
\a

-- Create the docs directory if it doesn't exist
\! mkdir -p doc/db

CREATE OR REPLACE FUNCTION public.generate_security_doc(
    OUT doc TEXT,
    OUT verification TEXT
)
LANGUAGE plpgsql AS $generate_security_doc$
DECLARE
    v_doc TEXT := '';
    v_problems TEXT[] := ARRAY[]::text[];
    v_rec RECORD;
    v_policy_str TEXT;
    v_grant_str TEXT;
    v_role_name TEXT;
    v_privilege_name TEXT;
    v_required_roles TEXT[] := ARRAY['authenticated', 'regular_user', 'admin_user'];
    v_required_privileges TEXT[] := ARRAY['SELECT', 'INSERT'];
    -- Tables that are intentionally exempt from RLS because they are internal
    -- staging/working tables not exposed via PostgREST.
    v_exempt_tables TEXT[] := ARRAY[
        'statistical_unit_facet_dirty_partitions',
        'statistical_unit_facet_staging',
        'statistical_unit_staging'
    ];
    -- Views with intentionally non-standard grant patterns.
    -- public.user: security_barrier view, user creation via user_create() function,
    --   only authenticated has SELECT, specific column UPDATE grants.
    v_exempt_views TEXT[] := ARRAY[
        'user'
    ];
BEGIN
    -- ========== Generate Documentation ==========

    v_doc := '# StatBus Security Posture

This document is automatically generated by `test/sql/008_verify_rls_and_grants.sql`. Do not edit it manually.

## Database Roles

| Role | Purpose |
|------|---------|
| `postgres` | Superuser, owns all objects |
| `authenticator` | PostgREST connects as this role, then switches via JWT |
| `anon` | Unauthenticated requests (very limited access) |
| `authenticated` | Base role for all logged-in users (SELECT on most tables) |
| `regular_user` | Standard user — can read most tables, edit core business data |
| `restricted_user` | User with region/activity restrictions applied via RLS |
| `admin_user` | Full access to all tables |
| `super_user` | Administrative operations |
| `notify_reader` | Can read notifications (used by worker) |

## Row Level Security (RLS)

All public tables must have RLS enabled. RLS policies control which rows
each role can see and modify.
';

    -- === Public Tables with RLS ===
    v_doc := v_doc || E'\n### Public Tables\n\n';

    FOR v_rec IN
        SELECT c.relname AS table_name,
               c.relrowsecurity AS has_rls
        FROM pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public'
          AND c.relkind = 'r'
        ORDER BY c.relname
    LOOP
        IF v_rec.has_rls THEN
            -- Get policies for this table
            SELECT string_agg(
                format('`%s` (%s → %s)',
                    pol.polname,
                    CASE pol.polcmd
                        WHEN 'r' THEN 'SELECT'
                        WHEN 'a' THEN 'INSERT'
                        WHEN 'w' THEN 'UPDATE'
                        WHEN 'd' THEN 'DELETE'
                        WHEN '*' THEN 'ALL'
                    END,
                    COALESCE(
                        NULLIF(array_to_string(
                            ARRAY(SELECT rolname FROM pg_roles WHERE oid = ANY(pol.polroles) ORDER BY rolname),
                            ', '
                        ), ''),
                        'PUBLIC'
                    )
                ),
                ', ' ORDER BY pol.polname
            )
            INTO v_policy_str
            FROM pg_policy pol
            JOIN pg_class pc ON pol.polrelid = pc.oid
            JOIN pg_namespace pn ON pc.relnamespace = pn.oid
            WHERE pn.nspname = 'public'
              AND pc.relname = v_rec.table_name;

            v_doc := v_doc || format(E'- **`%s`** — RLS ON\n', v_rec.table_name);
            IF v_policy_str IS NOT NULL THEN
                v_doc := v_doc || format(E'  - Policies: %s\n', v_policy_str);
            END IF;
        ELSE
            IF v_rec.table_name = ANY(v_exempt_tables) THEN
                v_doc := v_doc || format(E'- **`%s`** — RLS OFF (exempt: internal staging table)\n', v_rec.table_name);
            ELSE
                v_doc := v_doc || format(E'- **`%s`** — **RLS OFF** ⚠️\n', v_rec.table_name);
            END IF;
        END IF;
    END LOOP;

    -- === Non-public schema tables with RLS ===
    v_doc := v_doc || E'\n### Non-Public Schema Tables with RLS\n\n';

    FOR v_rec IN
        SELECT n.nspname AS schema_name,
               c.relname AS table_name,
               c.relrowsecurity AS has_rls
        FROM pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname IN ('auth', 'db', 'worker', 'import', 'lifecycle_callbacks')
          AND c.relkind = 'r'
          AND c.relrowsecurity
        ORDER BY n.nspname, c.relname
    LOOP
        SELECT string_agg(
            format('`%s` (%s → %s)',
                pol.polname,
                CASE pol.polcmd
                    WHEN 'r' THEN 'SELECT'
                    WHEN 'a' THEN 'INSERT'
                    WHEN 'w' THEN 'UPDATE'
                    WHEN 'd' THEN 'DELETE'
                    WHEN '*' THEN 'ALL'
                END,
                COALESCE(
                    NULLIF(array_to_string(
                        ARRAY(SELECT rolname FROM pg_roles WHERE oid = ANY(pol.polroles) ORDER BY rolname),
                        ', '
                    ), ''),
                    'PUBLIC'
                )
            ),
            ', ' ORDER BY pol.polname
        )
        INTO v_policy_str
        FROM pg_policy pol
        JOIN pg_class pc ON pol.polrelid = pc.oid
        JOIN pg_namespace pn ON pc.relnamespace = pn.oid
        WHERE pn.nspname = v_rec.schema_name
          AND pc.relname = v_rec.table_name;

        v_doc := v_doc || format(E'- **`%s.%s`** — RLS ON\n', v_rec.schema_name, v_rec.table_name);
        IF v_policy_str IS NOT NULL THEN
            v_doc := v_doc || format(E'  - Policies: %s\n', v_policy_str);
        END IF;
    END LOOP;

    -- === View Grants ===
    v_doc := v_doc || E'\n## View Grants\n\nPublic views (excluding `*__for_portion_of_valid`) must have SELECT and INSERT\ngranted to `authenticated`, `regular_user`, and `admin_user`.\n\n';

    FOR v_rec IN
        SELECT c.relname AS view_name
        FROM pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public'
          AND c.relkind = 'v'
          AND c.relname NOT LIKE '%__for_portion_of_valid'
        ORDER BY c.relname
    LOOP
        -- Build grant summary for this view
        SELECT string_agg(
            format('%s: %s', r.rolname, privs.privlist),
            '; ' ORDER BY r.rolname
        )
        INTO v_grant_str
        FROM (VALUES ('authenticated'), ('regular_user'), ('admin_user')) AS roles(rolname)
        JOIN pg_roles r ON r.rolname = roles.rolname
        CROSS JOIN LATERAL (
            SELECT string_agg(priv, ', ' ORDER BY priv) AS privlist
            FROM (
                SELECT 'SELECT' AS priv
                WHERE has_table_privilege(r.oid, format('public.%I', v_rec.view_name)::regclass, 'SELECT')
                UNION ALL
                SELECT 'INSERT'
                WHERE has_table_privilege(r.oid, format('public.%I', v_rec.view_name)::regclass, 'INSERT')
                UNION ALL
                SELECT 'UPDATE'
                WHERE has_table_privilege(r.oid, format('public.%I', v_rec.view_name)::regclass, 'UPDATE')
                UNION ALL
                SELECT 'DELETE'
                WHERE has_table_privilege(r.oid, format('public.%I', v_rec.view_name)::regclass, 'DELETE')
            ) sub
        ) privs
        WHERE privs.privlist IS NOT NULL;

        v_doc := v_doc || format(E'- **`%s`**', v_rec.view_name);
        IF v_grant_str IS NOT NULL THEN
            v_doc := v_doc || format(E': %s', v_grant_str);
        ELSE
            v_doc := v_doc || E': **NO GRANTS** ⚠️';
        END IF;
        v_doc := v_doc || E'\n';
    END LOOP;

    -- ========== Verification ==========

    -- Check 1: Public tables without RLS (excluding exempt tables)
    FOR v_rec IN
        SELECT c.relname AS table_name
        FROM pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public'
          AND c.relkind = 'r'
          AND NOT c.relrowsecurity
          AND c.relname <> ALL(v_exempt_tables)
        ORDER BY c.relname
    LOOP
        -- Suggest edit if table looks like a core business table, read otherwise
        IF v_rec.table_name IN ('establishment', 'legal_unit', 'enterprise',
                                'enterprise_group', 'activity', 'contact',
                                'location', 'person', 'person_for_unit',
                                'stat_for_unit', 'image', 'external_ident',
                                'tag_for_unit', 'unit_notes') THEN
            v_problems := array_append(v_problems,
                format('MISSING RLS: public.%s — fix with: SELECT admin.add_rls_regular_user_can_edit(''public.%s'');',
                    v_rec.table_name, v_rec.table_name));
        ELSE
            v_problems := array_append(v_problems,
                format('MISSING RLS: public.%s — fix with: SELECT admin.add_rls_regular_user_can_read(''public.%s'');',
                    v_rec.table_name, v_rec.table_name));
        END IF;
    END LOOP;

    -- Check 2: Public views without proper grants (excluding exempt views)
    FOR v_rec IN
        SELECT c.relname AS view_name
        FROM pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public'
          AND c.relkind = 'v'
          AND c.relname NOT LIKE '%__for_portion_of_valid'
          AND c.relname <> ALL(v_exempt_views)
        ORDER BY c.relname
    LOOP
        FOREACH v_role_name IN ARRAY v_required_roles
        LOOP
            FOREACH v_privilege_name IN ARRAY v_required_privileges
            LOOP
                IF NOT has_table_privilege(
                    v_role_name,
                    format('public.%I', v_rec.view_name)::regclass,
                    v_privilege_name
                ) THEN
                    v_problems := array_append(v_problems,
                        format('MISSING GRANT: %s on public.%s for %s — fix with: GRANT %s ON public.%s TO %s;',
                            v_privilege_name, v_rec.view_name, v_role_name,
                            v_privilege_name, v_rec.view_name, v_role_name));
                END IF;
            END LOOP;
        END LOOP;
    END LOOP;

    -- Build verification output
    IF array_length(v_problems, 1) > 0 THEN
        verification := array_to_string(v_problems, E'\n');
    ELSE
        verification := 'OK: All tables have RLS and all views have grants';
    END IF;

    doc := v_doc;
END;
$generate_security_doc$;

-- Generate the documentation and capture the output
SELECT * FROM public.generate_security_doc() \gset

-- Write the doc file
\o doc/db/security.md
SELECT :'doc';
\o

-- Clean up the function
DROP FUNCTION public.generate_security_doc();

-- Turn decorative output back on for the test result
\t
\a

-- Confirm doc generation
SELECT 'Security documentation generated in doc/db/security.md' AS result;

-- Output the verification result (this is what the test compares)
SELECT :'verification';
