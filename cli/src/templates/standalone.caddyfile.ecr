# Generated by <%= @program_name %> manage generate-config
# Do not edit directly - changes will be lost
#
# Standalone mode configuration - complete and self-contained
# This Caddy instance handles HTTPS directly

{
<% if @config.debug == "true" %>
    debug
<% end %>
    admin off
    log {
        format json
<% if @config.debug != "true" %>
        level INFO
<% end %>
    }
    
    # Layer4 PostgreSQL access
    # Two ports for different access patterns:
    # - Port 5431: Plaintext proxy for local migrations and internal Docker network access
    # - Port 5432: TLS+SNI proxy for public/external connections
    layer4 {
        # Plaintext port - for local migrations (bound to localhost only via docker-compose)
        # This allows `./devops/manage-statbus.sh psql` and migrations to work without TLS
        :5431 {
            route {
                proxy db:5432
            }
        }
        
        # TLS port - public PostgreSQL access with SNI routing
        :5432 {
            @pg_sni_<%= @deployment_slot_code %> {
                tls {
                    # Only match this hostname
                    sni <%= @domain %>
                    # Only when the application protocol is postgresql
                    alpn postgresql
                }
                # No postgres matcher needed - alpn match above is sufficient
            }
            route @pg_sni_<%= @deployment_slot_code %> {
                tls {
                    connection_policy {
                        # Allow TLS handshake to include alpn postgresql in principle, before the matcher runs.
                        alpn postgresql
                    }
                }
                proxy db:5432
            }
        }
    }
}

# Explicit HTTP â†’ HTTPS redirect
http://<%= @domain %> {
    redir https://{host}{uri} permanent
}

# Main HTTPS server
<%= @domain %> {
    encode gzip
    
    # Maintenance mode handling
    @maintenance {
        file {
            try_files /home/<%= @deployment_user %>/maintenance
        }
    }
    handle @maintenance {
        root * /home/<%= @deployment_user %>/statbus/app/public
        rewrite * /maintenance.html
        file_server {
            status 503
        }
    }
    
    # PostgREST auth endpoints (login/logout/refresh/auth_status/auth_gate)
    @auth_paths {
        path /rest/rpc/login
        path /rest/rpc/logout
        path /rest/rpc/refresh
        path /rest/rpc/auth_status
        path /rest/rpc/auth_test
        path /rest/rpc/auth_gate
    }
    handle @auth_paths {
        uri strip_prefix /rest
        reverse_proxy rest:3000 {
        }
    }
    
    # PostgREST API endpoints with cookie-to-header auth conversion
    @has_auth_cookie_and_no_auth_header {
        header_regexp cookie Cookie .*statbus=([^;]+).*
        header !Authorization
    }
    @rest {
        path /rest
        path /rest/*
    }
    handle @rest {
        uri strip_prefix /rest
        
        reverse_proxy @has_auth_cookie_and_no_auth_header rest:3000 {
            header_up Authorization "Bearer {http.request.cookie.statbus}"
        }
        
        reverse_proxy rest:3000 {
        }
    }
    
<% if @config.enable_pgadmin == "true" %>
    # pgAdmin 4 - PostgreSQL administration interface
    # Protected by STATBUS JWT authentication via forward_auth
    # Users must be logged into STATBUS to access pgAdmin
    @pgadmin {
        path /pgadmin
        path /pgadmin/*
    }
    handle @pgadmin {
        # Verify user is authenticated via STATBUS JWT
        # forward_auth calls /rest/rpc/auth_gate which returns:
        # - 200 OK if authenticated (allows access)
        # - 401 Unauthorized if not (handled below to redirect to login)
        forward_auth rest:3000 {
            uri /rpc/auth_gate
            # Copy the user email header if provided by auth_gate
            copy_headers X-Auth-User X-Auth-Email
            
            # Handle 401 responses - redirect to login page instead of showing error
            @unauthorized status 401
            handle_response @unauthorized {
                redir * /?login=required&redirect={uri} temporary
            }
        }
        
        # Proxy to pgAdmin with proper headers for subdirectory hosting
        reverse_proxy pgadmin:5050 {
            header_up X-Script-Name /pgadmin
            header_up X-Scheme {scheme}
            header_up X-Forwarded-Host {host}
        }
    }
<% end %>
    
    # All other requests to Next.js app
    handle {
        reverse_proxy app:3000 {
        }
    }
    
    log {
        output stdout
    }
    
<% if !@config.tls_cert_file.empty? && !@config.tls_key_file.empty? %>
    # Custom certificate provided via TLS_CERT_FILE and TLS_KEY_FILE
    # Files should be placed in caddy/data/custom-certs/ on host
    # The cert file should be in fullchain format (server cert + CA chain)
    tls <%= @config.tls_cert_file %> <%= @config.tls_key_file %>
<% else %>
    # Automatic ACME certificate (Let's Encrypt / ZeroSSL)
    tls {
        issuer acme
    }
<% end %>
}

# Internal Docker network server
# Handles requests from Next.js middleware when SERVER_REST_URL=http://proxy:80
# This is critical for auth checks during RSC (React Server Component) requests
http://proxy {
    # PostgREST auth endpoints for internal middleware auth checks
    @auth_paths {
        path /rest/rpc/login
        path /rest/rpc/logout
        path /rest/rpc/refresh
        path /rest/rpc/auth_status
        path /rest/rpc/auth_test
        path /rest/rpc/auth_gate
    }
    handle @auth_paths {
        uri strip_prefix /rest
        reverse_proxy rest:3000 {
        }
    }
    
    # PostgREST API endpoints with cookie-to-header auth conversion
    @has_auth_cookie_and_no_auth_header {
        header_regexp cookie Cookie .*statbus=([^;]+).*
        header !Authorization
    }
    @rest {
        path /rest
        path /rest/*
    }
    handle @rest {
        uri strip_prefix /rest
        
        reverse_proxy @has_auth_cookie_and_no_auth_header rest:3000 {
            header_up Authorization "Bearer {http.request.cookie.statbus}"
        }
        
        reverse_proxy rest:3000 {
        }
    }
    
    log {
        output stdout
    }
}
