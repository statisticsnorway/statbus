# Generated by <%= @program_name %> manage generate-config
# Do not edit directly - changes will be lost
#
# Development mode configuration - complete and self-contained

{
<% if @config.debug == "true" %>
    debug
<% end %>
    admin off
    log {
        format json
<% if @config.debug != "true" %>
        level INFO
<% end %>
    }
    # Notice that we don't do the redirect to https in development mode, since the cert is self signed anyway.
    auto_https disable_redirects
    
    servers {
<% if @config.debug == "true" %>
        log_credentials
<% end %>
        
        # Listener wrapper to intercept PostgreSQL connections on HTTPS port
        # TODO: The config below allows BOTH encrypted and non encrypted connections to postgres, and is thus not usable.
        #listener_wrappers {
        #    layer4 {
        #        @postgres {
        #            postgres
        #        }
        #        route @postgres {
        #            proxy db:5432
        #        }
        #    }
        #}
        # TODO: The config below fails due to a bug in caddy-l4 with the message:
        # `statbus-speed-proxy  | {"level":"warn","ts":1768298010.5386477,"logger":"http","msg":"tls is enabled, but listener wrapper returns a connection that doesn't implement connectionStater"}`
        #@tls-pgsql tls {
        #    # including the ALPN condition below
        #    # lets Caddy serve HTTPS requests
        #    # for the same server name
        #    alpn postgresql
        #    sni pgsql.example.com
        #}
        #route @tls-pgsql {
        #    tls {
        #        # the connection policy below is required
        #        # if the matcher above has no ALPN condition,
        #        # otherwise it may be securely omitted
        #        connection_policy {
        #            # supported by PostgreSQL 17 or later
        #            alpn postgresql
        #        }
        #    }
        #    # decrypted traffic is presumed to be PostgreSQL,
        #    # so no other checks are made before proxying it
        #    proxy db:5432
        #}
    }
    
    # Layer4 PostgreSQL access for local development
    # Two separate ports for clear separation:
    # - Port <%= @caddy_db_port %>: Plaintext proxy (default for local psql and SSH tunnels)
    # - Port <%= @caddy_db_tls_port %>: TLS+SNI proxy (for testing with TLS=1)
    layer4 {
        # Plaintext port - direct proxy without TLS
        :<%= @caddy_db_port %> {
            route {
                proxy db:5432
            }
        }
        
        # TLS port - for testing production-like connections
        :<%= @caddy_db_tls_port %> {
            @pg_dev {
                tls {
                    # Only match this hostname
                    sni <%= @domain %>
                    # Only when the application protocol is postgresql
                    alpn postgresql
                }
                # Notice not postgres matcher required, since we did the alpn match above.
            }
            route @pg_dev {
                tls {
                    connection_policy {
                        # Allow TLS handshake to include alpn postgresql in principle, before the matcher runs.
                        alpn postgresql
                    }
                }
                proxy db:5432
            }
        }
    }
}

# Notice that we don't do the redirect to https in development mode, since the cert is self signed anyway.
# Explicit HTTP â†’ HTTPS redirect
#http://<%= @domain %> {
#    redir https://{host}{uri} temporary
#}

# Internal fallback site when app:3000 is down
http://127.0.0.1:19999 {
    @json {
        header Accept application/json*
    }
    @html {
        not header Accept application/json*
    }
    
    handle @json {
        header Content-Type "application/json"
        respond `{"error": "Service temporarily unavailable", "details": "The Next.js application is not running. Start it with: cd app && pnpm run dev"}` 503
    }
    
    handle @html {
        header Content-Type "text/html"
        respond `<!DOCTYPE html>
<html><head><title>Service Unavailable</title></head>
<body><h1>Development Mode - App Not Running</h1>
<p>The Next.js application is not running.</p>
<p>Start it with: <code>cd app && pnpm run dev</code></p>
</body></html>` 503
    }
}

# Shared routing configuration for both HTTP and HTTPS
(statbus_routes) {
    # PostgREST auth endpoints (login/logout/refresh/auth_status)
    # These should not have Authorization header as they handle cookies directly
    @auth_paths {
        path /rest/rpc/login
        path /rest/rpc/logout
        path /rest/rpc/refresh
        path /rest/rpc/auth_status
        path /rest/rpc/auth_test
    }
    handle @auth_paths {
        uri strip_prefix /rest
        reverse_proxy rest:3000 {
        }
    }
    
    # PostgREST API endpoints with cookie-to-header auth conversion
    @has_auth_cookie_and_no_auth_header {
        header_regexp cookie Cookie .*statbus=([^;]+).*
        header !Authorization
    }
    @rest {
        path /rest
        path /rest/*
    }
    handle @rest {
        uri strip_prefix /rest
        
        reverse_proxy @has_auth_cookie_and_no_auth_header rest:3000 {
            header_up Authorization "Bearer {http.request.cookie.statbus}"
        }
        
        reverse_proxy rest:3000 {
        }
    }
    
    # All other requests to Next.js app with fallback
    handle {
        reverse_proxy app:3000 {
            @app_down status 502 503 504
            handle_response @app_down {
                rewrite * /
                reverse_proxy 127.0.0.1:19999
            }
        }
    }
    
    log {
        output stdout
    }
}

# HTTP server for local development (port 80)
# Serves same content as HTTPS but without TLS overhead for convenience
http://<%= @domain %> {
    import statbus_routes
}

# HTTPS server for local development (port 443)
# Uses internal CA for automatic certificate generation
<%= @domain %> {
    import statbus_routes
    tls internal
}

# Internal Docker service name support for SSR requests
# Handles requests from Next.js app container to proxy service
http://proxy {
    import statbus_routes
}
