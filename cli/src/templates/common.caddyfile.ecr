# Generated by <%= @program_name %> manage generate-config
# Do not edit directly - changes will be lost

# Common snippets for all Caddyfile configurations

# Auth-related paths definition (as a snippet to be used in matchers)
(secure_cookie_handling_auth_paths) {
    path /rest/rpc/login
    path /rest/rpc/logout
    path /rest/rpc/refresh
    path /rest/rpc/auth_status
    path /rest/rpc/auth_test
}



# Maintenance mode handling
(maintenance) {
    @maintenance {
        file {
            try_files {args[0]}/maintenance
        }
    }
    handle @maintenance {
        root * {args[1]}
        rewrite * /maintenance.html
        file_server {
            status 503
        }
    }
}

# Reverse proxy with standard headers - args[0] is the target address
(reverse_proxy_standard) {
    reverse_proxy {args[0]} {
        header_up Host {host}
        header_up X-Real-IP {remote}
    }
}

# Reverse proxy with auth token - args[0] is the target address
(reverse_proxy_auth) {
    reverse_proxy {args[0]} {
        header_up Host {host}
        header_up X-Real-IP {remote}
        header_up Authorization "Bearer {http.request.cookie.statbus}"
    }
}

# Common PostgREST endpoint handling - args[0] is the postgrest address
(postgrest_endpoints) {
    # Handle PostgREST auth requests (login/logout/refresh/auth_status) that should not fail due to expired Authorization
    # therefore the Authorization is not set.
    # Those functions directly look at the cookies as they can be called by anonymous.
    @auth_paths {
        path /rest/rpc/login
        path /rest/rpc/logout
        path /rest/rpc/refresh
        path /rest/rpc/auth_status
        path /rest/rpc/auth_test
    }    
    
    handle @auth_paths {
        uri strip_prefix /rest
        reverse_proxy {args[0]} {
            header_up Host {host}
            header_up X-Real-IP {remote}
        }
    }

    # Only add Authorization header if the cookie exists and there is no Authorization header,
    # because "Bearer {http.request.cookie.statbus}" gets expanded literally
    # if there is no cookie, and causes a JWT parse error.
    @has_auth_cookie_and_no_auth_header {
        # Has auth cookie
        header_regexp cookie Cookie .*statbus=([^;]+).*
        # Has NO auth header
        header !Authorization
    }
    @rest {
      path /rest
      path /rest/*
    }
    handle @rest {
        uri strip_prefix /rest
        
        reverse_proxy @has_auth_cookie_and_no_auth_header {args[0]} {
            header_up Host {host}
            header_up X-Real-IP {remote}
            header_up Authorization "Bearer {http.request.cookie.statbus}"
        }
        
        reverse_proxy {args[0]} {
            header_up Host {host}
            header_up X-Real-IP {remote}
        }
        
    }
}

# Standard logging configuration
(standard_logging) {
    log {
        # To enable file logging, uncomment the next line and ensure
        # CADDY_LOG_PATH is set in the Caddy environment.
        # output file {$CADDY_LOG_PATH}
        # format json
        output stdout
    }
}
