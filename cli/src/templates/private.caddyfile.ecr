# Generated by <%= @program_name %> manage generate-config
# Do not edit directly - changes will be lost
#
# Private mode configuration - complete and self-contained
# This Caddy instance runs behind a host-level proxy that handles HTTPS

{
<% if @config.debug == "true" %>
    debug
<% end %>
    admin off
    log {
        format json
<% if @config.debug != "true" %>
        level INFO
<% end %>
    }
    auto_https off
    servers {
        trusted_proxies static private_ranges
<% if @config.debug == "true" %>
        log_credentials
<% end %>
    }
    
    # Layer4 PostgreSQL forwarding for public/private mode
    # 
    # Architecture:
    #   1. Client connects to host-level Caddy on public IP port 5432 with TLS+SNI
    #   2. Host-level Caddy (public mode config) terminates TLS and forwards to 127.0.0.1:<%= @caddy_db_port %>
    #   3. This private mode Caddy listens on 127.0.0.1:<%= @caddy_db_port %> and forwards to db:5432 (Docker network)
    #   4. PostgreSQL receives the connection as plain TCP (no TLS)
    #
    # This architecture allows:
    #   - TLS termination at host level with proper certificates
    #   - SNI-based routing for multi-tenant deployments
    #   - Local psql access on the server using this port
    #   - PostgreSQL doesn't need TLS configuration
    layer4 {
        :<%= @caddy_db_port %> {
            # No matchers needed - simple TCP proxy
            # Connection arrives already decrypted from host-level Caddy
            route {
                proxy db:5432
            }
        }
    }
}

# Main HTTP server
http://<%= @domain %> {
    encode gzip
    
    # Maintenance mode handling
    @maintenance {
        file {
            try_files /home/<%= @deployment_user %>/maintenance
        }
    }
    handle @maintenance {
        root * /home/<%= @deployment_user %>/statbus/app/public
        rewrite * /maintenance.html
        file_server {
            status 503
        }
    }
    
    # PostgREST auth endpoints (login/logout/refresh/auth_status)
    @auth_paths {
        path /rest/rpc/login
        path /rest/rpc/logout
        path /rest/rpc/refresh
        path /rest/rpc/auth_status
        path /rest/rpc/auth_test
    }
    handle @auth_paths {
        uri strip_prefix /rest
        reverse_proxy rest:3000 {
        }
    }
    
    # PostgREST API endpoints with cookie-to-header auth conversion
    @has_auth_cookie_and_no_auth_header {
        header_regexp cookie Cookie .*statbus=([^;]+).*
        header !Authorization
    }
    @rest {
        path /rest
        path /rest/*
    }
    handle @rest {
        uri strip_prefix /rest
        
        reverse_proxy @has_auth_cookie_and_no_auth_header rest:3000 {
            header_up Authorization "Bearer {http.request.cookie.statbus}"
        }
        
        reverse_proxy rest:3000 {
        }
    }
    
    # All other requests to Next.js app
    handle {
        reverse_proxy app:3000 {
        }
    }
    
    log {
        output stdout
    }
}
