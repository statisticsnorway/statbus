BEGIN;

CREATE TABLE public.stat_for_unit (
    id integer GENERATED BY DEFAULT AS IDENTITY,
    stat_definition_id integer NOT NULL REFERENCES public.stat_definition(id) ON DELETE RESTRICT,
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date,
    data_source_id integer REFERENCES public.data_source(id) ON DELETE SET NULL,
    establishment_id integer,
    legal_unit_id integer,
    CONSTRAINT "One and only one statistical unit id must be set"
    CHECK (num_nonnulls(establishment_id, legal_unit_id) = 1),
    value_int INTEGER,
    value_float FLOAT,
    value_string VARCHAR,
    value_bool BOOLEAN,
    CHECK (num_nonnulls(value_int, value_float, value_string, value_bool) = 1),
    -- Note: Audit columns (edit_by_user_id, edit_at) are populated by import procedures
    -- using values derived during the import job prepare step.
    edit_comment character varying(512),
    edit_by_user_id integer NOT NULL REFERENCES auth.user(id) ON DELETE RESTRICT,
    edit_at timestamp with time zone NOT NULL DEFAULT statement_timestamp()
);

CREATE INDEX ix_stat_for_unit_stat_definition_id ON public.stat_for_unit USING btree (stat_definition_id);
CREATE INDEX ix_stat_for_unit_data_source_id ON public.stat_for_unit USING btree (data_source_id);
CREATE INDEX ix_stat_for_unit_legal_unit_id ON public.stat_for_unit USING btree (legal_unit_id);
CREATE INDEX ix_stat_for_unit_establishment_id ON public.stat_for_unit USING btree (establishment_id);
CREATE INDEX ix_stat_for_unit_legal_unit_id_valid_range ON public.stat_for_unit USING gist (legal_unit_id, valid_range);
CREATE INDEX ix_stat_for_unit_establishment_id_valid_range ON public.stat_for_unit USING gist (establishment_id, valid_range);
CREATE INDEX ix_stat_for_unit_valid_range ON public.stat_for_unit USING gist (valid_range);

-- Improve filtering for temporal_merge
-- Note: Column order must be alphabetical to match sql_saga's lookup_columns expectation
CREATE INDEX ON stat_for_unit (establishment_id, legal_unit_id, stat_definition_id);
CREATE INDEX ON stat_for_unit (establishment_id, stat_definition_id) WHERE legal_unit_id IS NULL;
CREATE INDEX ON stat_for_unit (legal_unit_id, stat_definition_id) WHERE establishment_id IS NULL;

-- Activate era handling with valid_range as the authoritative column.
-- The trigger will synchronize valid_from, valid_until, and valid_to from valid_range.
SELECT sql_saga.add_era('public.stat_for_unit', 'valid_range', 'valid', ephemeral_columns => ARRAY['edit_comment', 'edit_by_user_id', 'edit_at']);
-- This creates a PRIMARY KEY with WITHOUT OVERLAPS to ensure that
-- there are no overlapping time periods for the same stat_for_unit ID.
SELECT sql_saga.add_unique_key(
    table_oid => 'public.stat_for_unit',
    key_type => 'primary',
    column_names => ARRAY['id'],
    unique_key_name => 'stat_for_unit_id_valid'
);
-- A stat is uniquely defined by its type and the unit it belongs to. Since a stat can belong
-- to either a legal unit or an establishment (but not both), the true natural key is the
-- combination of all three columns. The CHECK constraint on the table ensures that one of the
-- unit ID columns is always NULL. By defining a single natural key with all three columns,
-- we provide the exact metadata signature that sql_saga's temporal_merge function needs to
-- correctly identify and coalesce adjacent, identical records. This creates a GIST exclusion
-- constraint (`stat_for_unit_natural_key_valid_excl`).
SELECT sql_saga.add_unique_key(
    table_oid => 'public.stat_for_unit',
    key_type => 'natural',
    column_names => ARRAY['stat_definition_id', 'legal_unit_id', 'establishment_id'],
    mutually_exclusive_columns => ARRAY['establishment_id','legal_unit_id'],
    unique_key_name => 'stat_for_unit_natural_key_valid'
);

-- This creates triggers to enforce that a stat_for_unit's validity period is always contained
-- within the validity period of its parent establishment.
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'public.stat_for_unit',
    fk_column_names => ARRAY['establishment_id'],
    pk_table_oid => 'public.establishment',
    pk_column_names => ARRAY['id']
);
-- This creates triggers to enforce that a stat_for_unit's validity period is always contained
-- within the validity period of its parent legal unit.
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'public.stat_for_unit',
    fk_column_names => ARRAY['legal_unit_id'],
    pk_table_oid => 'public.legal_unit',
    pk_column_names => ARRAY['id']
);

-- Add a view for portion-of updates, allowing for easier updates to specific time slices.
SELECT sql_saga.add_for_portion_of_view('public.stat_for_unit');

END;
