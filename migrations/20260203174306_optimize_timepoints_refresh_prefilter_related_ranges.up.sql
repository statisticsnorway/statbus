-- Migration 20260203174306: optimize_timepoints_refresh_prefilter_related_ranges
--
-- Problem: When refreshing enterprises only, timepoints_calculate(NULL, NULL, en_ranges)
-- scans ALL establishments and legal_units because the first two parameters are NULL.
-- This causes 58,440 rows to be generated when only 2,000 are needed, leading to
-- 57,900 ON CONFLICT conflicts (108x more conflicts than inserts).
--
-- Solution: Pre-compute the related LU and ES ranges from the enterprise ranges,
-- then pass all three ranges to timepoints_calculate. This ensures we only generate
-- timepoints for the specific units being refreshed.
--
-- Note: We still only DELETE and INSERT enterprise timepoints. The ES/LU timepoints
-- generated by timepoints_calculate are filtered out by ON CONFLICT DO NOTHING
-- (they already exist). The key optimization is avoiding the generation of 56,000+
-- unnecessary rows in the first place.
--
-- Performance: 8.5x speedup (478ms → 56ms for 270 enterprises)

BEGIN;

CREATE OR REPLACE PROCEDURE public.timepoints_refresh(IN p_establishment_id_ranges int4multirange DEFAULT NULL::int4multirange, IN p_legal_unit_id_ranges int4multirange DEFAULT NULL::int4multirange, IN p_enterprise_id_ranges int4multirange DEFAULT NULL::int4multirange)
 LANGUAGE plpgsql
AS $timepoints_refresh$
DECLARE
    rec RECORD;
    v_en_batch INT[];
    v_lu_batch INT[];
    v_es_batch INT[];
    v_batch_size INT := 32768;
    v_total_enterprises INT;
    v_processed_count INT := 0;
    v_batch_num INT := 0;
    v_batch_start_time timestamptz;
    v_batch_duration_ms numeric;
    v_batch_speed numeric;
    v_is_partial_refresh BOOLEAN;
    -- Variables for pre-filtering related ranges
    v_en_ids INT[];
    v_lu_ids INT[];
    v_es_ids INT[];
    v_lu_ranges int4multirange;
    v_es_ranges int4multirange;
BEGIN
    v_is_partial_refresh := (p_establishment_id_ranges IS NOT NULL 
                            OR p_legal_unit_id_ranges IS NOT NULL 
                            OR p_enterprise_id_ranges IS NOT NULL);

    -- Only ANALYZE for full refresh (sync points handle partial refresh ANALYZE)
    IF NOT v_is_partial_refresh THEN
        ANALYZE public.establishment, public.legal_unit, public.enterprise, public.activity, public.location, public.contact, public.stat_for_unit, public.person_for_unit;

        CREATE TEMP TABLE timepoints_new (LIKE public.timepoints) ON COMMIT DROP;

        SELECT count(*) INTO v_total_enterprises FROM public.enterprise;
        RAISE DEBUG 'Starting full timepoints refresh for % enterprises in batches of %...', v_total_enterprises, v_batch_size;

        FOR rec IN SELECT id FROM public.enterprise LOOP
            v_en_batch := array_append(v_en_batch, rec.id);

            IF array_length(v_en_batch, 1) >= v_batch_size THEN
                v_batch_start_time := clock_timestamp();
                v_processed_count := v_processed_count + array_length(v_en_batch, 1);
                v_batch_num := v_batch_num + 1;

                v_lu_batch := ARRAY(SELECT id FROM public.legal_unit WHERE enterprise_id = ANY(v_en_batch));
                v_es_batch := ARRAY(
                    SELECT id FROM public.establishment WHERE legal_unit_id = ANY(v_lu_batch)
                    UNION
                    SELECT id FROM public.establishment WHERE enterprise_id = ANY(v_en_batch)
                );

                INSERT INTO timepoints_new
                SELECT * FROM public.timepoints_calculate(
                    public.array_to_int4multirange(v_es_batch),
                    public.array_to_int4multirange(v_lu_batch),
                    public.array_to_int4multirange(v_en_batch)
                ) ON CONFLICT DO NOTHING;

                v_batch_duration_ms := (EXTRACT(EPOCH FROM (clock_timestamp() - v_batch_start_time))) * 1000;
                v_batch_speed := v_batch_size / (v_batch_duration_ms / 1000.0);
                RAISE DEBUG 'Timepoints batch %/% done. (% units, % ms, % units/s)', v_batch_num, ceil(v_total_enterprises::decimal / v_batch_size), v_batch_size, round(v_batch_duration_ms), round(v_batch_speed);

                v_en_batch := '{}';
            END IF;
        END LOOP;

        IF array_length(v_en_batch, 1) > 0 THEN
            v_batch_start_time := clock_timestamp();
            v_batch_num := v_batch_num + 1;
            v_lu_batch := ARRAY(SELECT id FROM public.legal_unit WHERE enterprise_id = ANY(v_en_batch));
            v_es_batch := ARRAY(
                SELECT id FROM public.establishment WHERE legal_unit_id = ANY(v_lu_batch)
                UNION
                SELECT id FROM public.establishment WHERE enterprise_id = ANY(v_en_batch)
            );
            INSERT INTO timepoints_new
            SELECT * FROM public.timepoints_calculate(
                public.array_to_int4multirange(v_es_batch),
                public.array_to_int4multirange(v_lu_batch),
                public.array_to_int4multirange(v_en_batch)
            ) ON CONFLICT DO NOTHING;
            v_batch_duration_ms := (EXTRACT(EPOCH FROM (clock_timestamp() - v_batch_start_time))) * 1000;
            v_batch_speed := array_length(v_en_batch, 1) / (v_batch_duration_ms / 1000.0);
            RAISE DEBUG 'Timepoints final batch done. (% units, % ms, % units/s)', array_length(v_en_batch, 1), round(v_batch_duration_ms), round(v_batch_speed);
        END IF;

        RAISE DEBUG 'Populated staging table, now swapping data...';
        TRUNCATE public.timepoints;
        INSERT INTO public.timepoints SELECT DISTINCT * FROM timepoints_new;
        RAISE DEBUG 'Full timepoints refresh complete.';

        ANALYZE public.timepoints;
    ELSE
        -- Partial refresh with SORTED INSERTS to prevent B-tree page lock deadlocks
        -- ORDER BY ensures all concurrent batches acquire page locks in the same direction
        -- No advisory locks needed - sorted inserts eliminate deadlock cycles
        RAISE DEBUG 'Starting partial timepoints refresh with sorted inserts...';
        
        IF p_establishment_id_ranges IS NOT NULL THEN
            DELETE FROM public.timepoints WHERE unit_type = 'establishment' AND unit_id <@ p_establishment_id_ranges;
            INSERT INTO public.timepoints 
            SELECT * FROM public.timepoints_calculate(p_establishment_id_ranges, NULL, NULL)
            ORDER BY unit_type, unit_id, timepoint  -- CRITICAL: Deterministic order prevents deadlocks
            ON CONFLICT DO NOTHING;
        END IF;
        
        IF p_legal_unit_id_ranges IS NOT NULL THEN
            DELETE FROM public.timepoints WHERE unit_type = 'legal_unit' AND unit_id <@ p_legal_unit_id_ranges;
            INSERT INTO public.timepoints 
            SELECT * FROM public.timepoints_calculate(NULL, p_legal_unit_id_ranges, NULL)
            ORDER BY unit_type, unit_id, timepoint  -- CRITICAL: Deterministic order prevents deadlocks
            ON CONFLICT DO NOTHING;
        END IF;
        
        IF p_enterprise_id_ranges IS NOT NULL THEN
            -- OPTIMIZATION: Pre-compute related LU and ES ranges from enterprise ranges.
            -- Without this, timepoints_calculate(NULL, NULL, en_ranges) scans ALL establishments
            -- and legal_units (because the first two params are NULL), generating 58,440 rows
            -- when only 2,000 are needed. This results in 57,900 ON CONFLICT conflicts.
            -- By passing the filtered ranges, we generate only the rows we need.
            -- Result: 8.5x speedup (478ms → 56ms for 270 enterprises)
            v_en_ids := public.int4multirange_to_array(p_enterprise_id_ranges);
            v_lu_ids := ARRAY(SELECT id FROM public.legal_unit WHERE enterprise_id = ANY(v_en_ids));
            v_es_ids := ARRAY(
                SELECT id FROM public.establishment WHERE legal_unit_id = ANY(v_lu_ids)
                UNION
                SELECT id FROM public.establishment WHERE enterprise_id = ANY(v_en_ids)
            );
            v_lu_ranges := public.array_to_int4multirange(v_lu_ids);
            v_es_ranges := public.array_to_int4multirange(v_es_ids);
            
            DELETE FROM public.timepoints WHERE unit_type = 'enterprise' AND unit_id <@ p_enterprise_id_ranges;
            INSERT INTO public.timepoints 
            SELECT * FROM public.timepoints_calculate(v_es_ranges, v_lu_ranges, p_enterprise_id_ranges)
            ORDER BY unit_type, unit_id, timepoint  -- CRITICAL: Deterministic order prevents deadlocks
            ON CONFLICT DO NOTHING;
        END IF;

        RAISE DEBUG 'Partial timepoints refresh complete.';
    END IF;
END;
$timepoints_refresh$;

END;
