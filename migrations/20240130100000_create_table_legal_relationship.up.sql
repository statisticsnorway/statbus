BEGIN;

--------------------------------------------------------------------------------
-- legal_relationship table
-- Tracks ownership and control relationships between legal units
-- This is the core table for deriving power group hierarchies
--------------------------------------------------------------------------------

CREATE TABLE public.legal_relationship (
    id integer GENERATED BY DEFAULT AS IDENTITY,
    power_group_id integer REFERENCES public.power_group(id) ON DELETE SET NULL,
    
    -- Temporal fields (sql_saga managed)
    valid_range daterange NOT NULL,
    valid_from date NOT NULL,
    valid_to date,
    valid_until date,
    
    -- The relationship: influencing unit has power over influenced unit
    influencing_id integer NOT NULL,  -- The controlling/owning legal unit
    influenced_id integer NOT NULL,   -- The controlled/owned legal unit
    
    -- What type of relationship (ownership vs control)
    type_id integer NOT NULL REFERENCES public.legal_rel_type(id) ON DELETE RESTRICT,
    
    -- How did this relationship originate (optional - merger, acquisition, etc.)
    reorg_type_id integer REFERENCES public.legal_reorg_type(id),
    
    -- Denormalized from legal_rel_type via trigger (auto-set on INSERT/UPDATE of type_id)
    -- When TRUE, this relationship participates in power group hierarchy formation
    primary_influencer_only boolean,

    -- Ownership/control percentage (for threshold calculations, 0-100)
    percentage numeric(5,2) CHECK (percentage >= 0 AND percentage <= 100),

    -- Standard edit fields
    edit_comment varchar(512),
    edit_by_user_id integer NOT NULL REFERENCES auth.user(id) ON DELETE RESTRICT,
    edit_at timestamptz NOT NULL DEFAULT statement_timestamp(),
    
    -- Dual-column FK ensures primary_influencer_only stays in sync with legal_rel_type
    FOREIGN KEY (type_id, primary_influencer_only) REFERENCES public.legal_rel_type(id, primary_influencer_only) ON UPDATE CASCADE,

    -- A legal unit cannot influence itself
    CONSTRAINT influencing_influenced_different CHECK (influencing_id != influenced_id)
);

-- Indexes for hierarchy traversal
CREATE INDEX ix_legal_relationship_influencing_id ON public.legal_relationship USING btree (influencing_id);
CREATE INDEX ix_legal_relationship_influenced_id ON public.legal_relationship USING btree (influenced_id);
CREATE INDEX ix_legal_relationship_type_id ON public.legal_relationship USING btree (type_id);
CREATE INDEX ix_legal_relationship_reorg_type_id ON public.legal_relationship USING btree (reorg_type_id);
CREATE INDEX ix_legal_relationship_valid_range ON public.legal_relationship USING gist (valid_range);
CREATE INDEX ix_legal_relationship_edit_by_user_id ON public.legal_relationship USING btree (edit_by_user_id);

-- Comments
COMMENT ON TABLE public.legal_relationship IS 'Tracks ownership and control relationships between legal units, forming the basis for power group hierarchies';
COMMENT ON COLUMN public.legal_relationship.influencing_id IS 'The controlling/owning legal unit';
COMMENT ON COLUMN public.legal_relationship.influenced_id IS 'The controlled/owned legal unit';
COMMENT ON COLUMN public.legal_relationship.type_id IS 'Type of relationship (ownership or control)';
COMMENT ON COLUMN public.legal_relationship.reorg_type_id IS 'How this relationship originated (merger, acquisition, etc.)';
COMMENT ON COLUMN public.legal_relationship.primary_influencer_only IS 'Denormalized from legal_rel_type; when TRUE, this relationship forms power group hierarchies';
COMMENT ON COLUMN public.legal_relationship.percentage IS 'Ownership/control percentage (0-100), optional';

--------------------------------------------------------------------------------
-- sql_saga temporal setup
--------------------------------------------------------------------------------

-- Activate era handling with valid_range as the authoritative column.
SELECT sql_saga.add_era('public.legal_relationship', 'valid_range', 'valid', ephemeral_columns => ARRAY['edit_comment', 'edit_by_user_id', 'edit_at']);

-- Primary key with WITHOUT OVERLAPS (id is the primary key, combined with valid_range for temporal)
SELECT sql_saga.add_unique_key(
    table_oid => 'public.legal_relationship',
    key_type => 'primary',
    column_names => ARRAY['id'],
    unique_key_name => 'legal_relationship_id_valid'
);

-- Temporal foreign key: influencing_id -> legal_unit.id
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'public.legal_relationship'::regclass,
    fk_column_names => ARRAY['influencing_id'],
    pk_table_oid => 'public.legal_unit',
    pk_column_names => ARRAY['id']
);

-- Temporal foreign key: influenced_id -> legal_unit.id
SELECT sql_saga.add_foreign_key(
    fk_table_oid => 'public.legal_relationship'::regclass,
    fk_column_names => ARRAY['influenced_id'],
    pk_table_oid => 'public.legal_unit',
    pk_column_names => ARRAY['id']
);

-- An influenced unit can only have one primary influencer of a given type at any point in time
-- (e.g., a legal unit can't have two HFOR parents simultaneously)
SELECT sql_saga.add_unique_key(
    table_oid => 'public.legal_relationship',
    column_names => ARRAY['influenced_id', 'type_id'],
    key_type => 'predicated',
    predicate => 'primary_influencer_only IS TRUE',
    unique_key_name => 'legal_relationship_influenced_primary'
);

-- Add a view for portion-of updates
SELECT sql_saga.add_for_portion_of_view('public.legal_relationship');

--------------------------------------------------------------------------------
-- Auto-set primary_influencer_only from legal_rel_type
--------------------------------------------------------------------------------

CREATE FUNCTION public.legal_relationship_set_primary_influencer_only()
RETURNS trigger
LANGUAGE plpgsql
AS $legal_relationship_set_primary_influencer_only$
BEGIN
    SELECT lrt.primary_influencer_only INTO NEW.primary_influencer_only
    FROM public.legal_rel_type AS lrt WHERE lrt.id = NEW.type_id;
    RETURN NEW;
END;
$legal_relationship_set_primary_influencer_only$;

CREATE TRIGGER trg_legal_relationship_set_primary_influencer_only
    BEFORE INSERT OR UPDATE OF type_id ON public.legal_relationship
    FOR EACH ROW EXECUTE FUNCTION public.legal_relationship_set_primary_influencer_only();

--------------------------------------------------------------------------------
-- Cycle prevention trigger
--------------------------------------------------------------------------------

CREATE FUNCTION public.legal_relationship_cycle_check()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $legal_relationship_cycle_check$
DECLARE
    _path integer[];
    _cycle_found boolean := FALSE;
    _effective_valid_range daterange;
BEGIN
    -- Calculate the effective valid_range from valid_from/valid_to
    -- This is necessary because sql_saga's temporal sync trigger runs AFTER this trigger
    _effective_valid_range := daterange(
        NEW.valid_from, 
        COALESCE(NEW.valid_to, 'infinity'::date),
        '[)'
    );
    
    -- Check for cycles using recursive CTE
    -- Start from NEW.influenced_id and follow influencing_id links to see if we reach NEW.influencing_id
    WITH RECURSIVE ancestors AS (
        -- Base case: start from influenced's influencers (not including the new relationship yet)
        SELECT 
            lr.influencing_id,
            lr.influenced_id,
            ARRAY[lr.influenced_id, lr.influencing_id] AS path,
            lr.valid_range
        FROM public.legal_relationship AS lr
        WHERE lr.influenced_id = NEW.influencing_id
          AND lr.valid_range && _effective_valid_range
          AND lr.id IS DISTINCT FROM NEW.id
        
        UNION ALL
        
        -- Recursive case: follow the chain upward
        SELECT 
            lr.influencing_id,
            lr.influenced_id,
            a.path || lr.influencing_id,
            lr.valid_range * a.valid_range AS valid_range
        FROM ancestors AS a
        JOIN public.legal_relationship AS lr 
            ON lr.influenced_id = a.influencing_id
            AND lr.valid_range && a.valid_range
            AND lr.id IS DISTINCT FROM NEW.id
        WHERE NOT (lr.influencing_id = ANY(a.path))
          AND array_length(a.path, 1) < 100
    )
    SELECT TRUE INTO _cycle_found
    FROM ancestors
    WHERE influencing_id = NEW.influenced_id
    LIMIT 1;
    
    IF _cycle_found THEN
        RAISE EXCEPTION 'Circular ownership detected: adding relationship from legal_unit % to % would create a cycle',
            NEW.influencing_id, NEW.influenced_id;
    END IF;
    
    RETURN NEW;
END;
$legal_relationship_cycle_check$;

COMMENT ON FUNCTION public.legal_relationship_cycle_check() IS 
    'Trigger function to prevent circular ownership/control relationships between legal units';

CREATE TRIGGER legal_relationship_cycle_check_trigger
BEFORE INSERT OR UPDATE ON public.legal_relationship
FOR EACH ROW
EXECUTE FUNCTION public.legal_relationship_cycle_check();

-- Enable RLS (required by 20240603 migration check)
ALTER TABLE public.legal_relationship ENABLE ROW LEVEL SECURITY;

END;
