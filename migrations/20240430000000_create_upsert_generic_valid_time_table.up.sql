BEGIN;

CREATE FUNCTION admin.upsert_generic_valid_time_table
    ( schema_name text
    , table_name text
    , unique_columns jsonb
    , temporal_columns text[]
    , ephemeral_columns text[]
    , NEW RECORD
    )
RETURNS INTEGER AS $upsert_generic_valid_time_table$
DECLARE
  existing_id integer := NEW.id;
  existing RECORD;
  result RECORD;
  existing_data jsonb;
  new_data jsonb;
  new_base_data jsonb;
  adjusted_valid_from date;
  adjusted_valid_to date;
  equivalent_data jsonb;
  equivalent_clause text;
  identifying_clause text;
  existing_query text;
  delete_existing_sql text;
  identifying_query text;
  generated_columns text[];
  generated_columns_sql CONSTANT text :=
      'SELECT array_agg(a.attname) '
      'FROM pg_catalog.pg_attribute AS a '
      'WHERE a.attrelid = $1 '
      '  AND a.attnum > 0 '
      '  AND NOT a.attisdropped '
      '  AND (pg_catalog.pg_get_serial_sequence(a.attrelid::regclass::text, a.attname) IS NOT NULL '
      '    OR a.attidentity <> '''' '
      '    OR a.attgenerated <> '''' '
      '    OR EXISTS (SELECT FROM pg_catalog.pg_constraint AS _c '
      '               WHERE _c.conrelid = a.attrelid '
      '                 AND _c.contype = ''p'' '
      '                 AND _c.conkey @> ARRAY[a.attnum]) '
      '              )';
BEGIN
  new_data := to_jsonb(NEW);
  -- Loop through each conflicting row
  RAISE DEBUG 'UPSERT row %', new_data;
  -- Remove fields that are generated by the database,
  -- since we don't wish to override them with NULL
  -- and get a constraint error.
  EXECUTE generated_columns_sql INTO generated_columns USING (schema_name||'.'||table_name)::regclass;

  new_base_data := new_data - generated_columns;
  -- The equivalent data is the data that makes up the equivalent, and
  -- is the basis for considering it equal to another row, and thus
  -- no historic versioning is required.
  -- Ephemeral columns are used for internal delete tracking, and are non temporal,
  -- and the temporal columns themselves are not part of the value.
  equivalent_data := new_base_data - ephemeral_columns - temporal_columns;

  SELECT string_agg(' '||quote_ident(key)||' IS NOT DISTINCT FROM $1.'||quote_ident(key)||' ', ' AND ')
  INTO equivalent_clause
  FROM jsonb_each_text(equivalent_data);

  IF NEW.id IS NULL THEN
      SELECT
        string_agg(
            CASE jsonb_typeof(unique_column)
            WHEN 'array' THEN
                    '(' || (SELECT string_agg(' '||element||'= $1.'||element||' ', ' AND ') FROM jsonb_array_elements_text(unique_column) AS element) || ')'
            WHEN 'string' THEN ' '||unique_column::text||'= $1.'||unique_column::text||' '
            ELSE NULL
            END,
            ' OR '
        ) INTO identifying_clause
      FROM (SELECT jsonb_array_elements(unique_columns) AS unique_column) AS subquery;

      identifying_query := format($$
          SELECT id
          FROM %1$I.%2$I
          WHERE %3$s
          LIMIT 1;$$
          , schema_name
          , table_name
          , identifying_clause
        );
      RAISE DEBUG 'identifying_query %', identifying_query;

      EXECUTE identifying_query INTO existing_id USING NEW;
      RAISE DEBUG 'existing_id %', existing_id;
      NEW.id = existing_id;
  END IF;

  existing_query := format($$
      SELECT *
           , (%3$s) AS equivalent
           , CASE
             WHEN valid_to = ($1.valid_from - '1 day'::INTERVAL) THEN 'existing_adjacent_valid_from'
             WHEN valid_from = ($1.valid_to + '1 day'::INTERVAL) THEN 'existing_adjacent_valid_to'
             WHEN valid_from <  $1.valid_from AND valid_to <= $1.valid_to THEN 'existing_overlaps_valid_from'
             WHEN valid_from <  $1.valid_from AND valid_to >  $1.valid_to THEN 'inside_existing'
             WHEN valid_from >= $1.valid_from AND valid_to <= $1.valid_to THEN 'contains_existing'
             WHEN valid_from >= $1.valid_from AND valid_to >  $1.valid_to THEN 'existing_overlaps_valid_to'
             END::admin.existing_upsert_case AS upsert_case
      FROM %1$I.%2$I
      WHERE daterange(valid_from, valid_to, '[]') && daterange(($1.valid_from - '1 day'::INTERVAL)::DATE, ($1.valid_to + '1 day'::INTERVAL)::DATE, '[]')
        AND id = $2
      ORDER BY valid_from$$
      , schema_name
      , table_name
      , equivalent_clause
    );
  --RAISE DEBUG 'existing_query %', existing_query;

  FOR existing IN EXECUTE existing_query USING NEW, existing_id
  LOOP
      existing_data := to_jsonb(existing);
      RAISE DEBUG 'EXISTING row %', existing_data;

      delete_existing_sql := format($$
       DELETE FROM %1$I.%2$I
        WHERE id = $1
          AND valid_from = $2
          AND valid_to = $3;
      $$, schema_name, table_name);

      CASE existing.upsert_case
      WHEN 'existing_adjacent_valid_from' THEN
        IF existing.equivalent THEN
          RAISE DEBUG 'Upsert Case: existing_adjacent_valid_from AND equivalent';
          RAISE DEBUG 'DELETE EXISTING';
          EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
          NEW.valid_from := existing.valid_from;
        END IF;
      WHEN 'existing_adjacent_valid_to' THEN
        IF existing.equivalent THEN
          RAISE DEBUG 'Upsert Case: existing_adjacent_valid_to AND equivalent';
          RAISE DEBUG 'DELETE EXISTING';
          EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
          NEW.valid_to := existing.valid_to;
        END IF;
      WHEN 'existing_overlaps_valid_from' THEN
        IF existing.equivalent THEN
          RAISE DEBUG 'Upsert Case: existing_overlaps_valid_from AND equivalent';
          RAISE DEBUG 'DELETE EXISTING';
          EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
          NEW.valid_from := existing.valid_from;
        ELSE
          RAISE DEBUG 'Upsert Case: existing_overlaps_valid_from AND different';
          adjusted_valid_to := NEW.valid_from - interval '1 day';
          RAISE DEBUG 'adjusted_valid_to = %', adjusted_valid_to;
          IF adjusted_valid_to <= existing.valid_from THEN
            RAISE DEBUG 'DELETE EXISTING with zero valid duration %.%(id=%)', schema_name, table_name, existing.id;
            EXECUTE EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
          ELSE
            RAISE DEBUG 'Adjusting existing row %.%(id=%)', schema_name, table_name, existing.id;
            EXECUTE format($$
                UPDATE %1$I.%2$I
                SET valid_to = $1
                WHERE
                  id = $2
                  AND valid_from = $3
                  AND valid_to = $4
              $$, schema_name, table_name) USING adjusted_valid_to, existing.id, existing.valid_from, existing.valid_to;
          END IF;
        END IF;
      WHEN 'inside_existing' THEN
        IF existing.equivalent THEN
          RAISE DEBUG 'Upsert Case: inside_existing AND equivalent';
          RAISE DEBUG 'DELETE EXISTING';
          EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
          NEW.valid_from := existing.valid_from;
          NEW.valid_to := existing.valid_to;
        ELSE
          RAISE DEBUG 'Upsert Case: inside_existing AND different';
          adjusted_valid_from := NEW.valid_to + interval '1 day';
          adjusted_valid_to := NEW.valid_from - interval '1 day';
          RAISE DEBUG 'adjusted_valid_from = %', adjusted_valid_from;
          RAISE DEBUG 'adjusted_valid_to = %', adjusted_valid_to;
          IF adjusted_valid_to <= existing.valid_from THEN
            RAISE DEBUG 'Deleting existing with zero valid duration %.%(id=%)', schema_name, table_name, existing.id;
            RAISE DEBUG 'DELETE EXISTING';
            EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
          ELSE
            RAISE DEBUG 'ADJUSTING EXISTING row %.%(id=%)', schema_name, table_name, existing.id;
            EXECUTE format($$
                UPDATE %1$I.%2$I
                SET valid_to = $1
                WHERE
                  id = $2
                  AND valid_from = $3
                  AND valid_to = $4
              $$, schema_name, table_name) USING adjusted_valid_to, existing.id, existing.valid_from, existing.valid_to;
          END IF;
          IF existing.valid_to < adjusted_valid_from THEN
            RAISE DEBUG 'Don''t create zero duration row';
          ELSE
            existing.valid_from := adjusted_valid_from;
            existing_data := to_jsonb(existing);
            new_base_data := existing_data - generated_columns;
            RAISE DEBUG 'Inserting new tail %', new_base_data;
            EXECUTE format('INSERT INTO %1$I.%2$I(%3$s) VALUES (%4$s)', schema_name, table_name,
              (SELECT string_agg(quote_ident(key), ', ' ORDER BY key) FROM jsonb_each_text(new_base_data)),
              (SELECT string_agg(quote_nullable(value), ', ' ORDER BY key) FROM jsonb_each_text(new_base_data)));
          END IF;
        END IF;
      WHEN 'contains_existing' THEN
          RAISE DEBUG 'Upsert Case: contains_existing';
          RAISE DEBUG 'DELETE EXISTING contained by NEW %.%(id=%)', schema_name, table_name, existing.id;
          EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
      WHEN 'existing_overlaps_valid_to' THEN
        IF existing.equivalent THEN
          RAISE DEBUG 'Upsert Case: existing_overlaps_valid_to AND equivalent';
          RAISE DEBUG 'DELETE EXISTING';
          EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
          NEW.valid_to := existing.valid_to;
        ELSE
          RAISE DEBUG 'Upsert Case: existing_overlaps_valid_to AND different';
          adjusted_valid_from := NEW.valid_to + interval '1 day';
          RAISE DEBUG 'adjusted_valid_from = %', adjusted_valid_from;
          IF existing.valid_to < adjusted_valid_from THEN
              RAISE DEBUG 'DELETE EXISTING with zero valid duration %.%(id=%)', schema_name, table_name, existing.id;
              EXECUTE delete_existing_sql USING existing.id, existing.valid_from, existing.valid_to;
          ELSE
            RAISE DEBUG 'Adjusting existing row %.%(id=%)', schema_name, table_name, existing.id;
            EXECUTE format($$
                UPDATE %1$I.%2$I
                SET valid_from = $1
                WHERE
                  id = $2
                  AND valid_from = $3
                  AND valid_to = $4
              $$, schema_name, table_name) USING adjusted_valid_from, existing.id, existing.valid_from, existing.valid_to;
          END IF;
        END IF;
      ELSE
        RAISE EXCEPTION 'Unknown existing_upsert_case: %', existing.upsert_case;
      END CASE;
    END LOOP;
  --
  -- Insert a new entry
  -- If there was any existing row, then reuse that same id
  new_base_data := to_jsonb(NEW) - generated_columns;
  -- The id is a generated row, so add it back again after removal.
  IF existing_id IS NOT NULL THEN
    new_base_data := jsonb_set(new_base_data, '{id}', existing_id::text::jsonb, true);
  END IF;

  RAISE DEBUG 'INSERT %.%(%)', schema_name, table_name, new_base_data;
  EXECUTE format('INSERT INTO %1$I.%2$I(%3$s) VALUES (%4$s) RETURNING *', schema_name, table_name,
    (SELECT string_agg(quote_ident(key), ', ' ORDER BY key) FROM jsonb_each_text(new_base_data)),
    (SELECT string_agg(quote_nullable(value), ', ' ORDER BY key) FROM jsonb_each_text(new_base_data)))
  INTO result;
  RETURN result.id;
END;
$upsert_generic_valid_time_table$ LANGUAGE plpgsql;

END;
