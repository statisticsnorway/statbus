BEGIN;

CREATE TABLE public.external_ident (
    id integer GENERATED BY DEFAULT AS IDENTITY,
    type_id INTEGER NOT NULL REFERENCES public.external_ident_type(id) ON DELETE RESTRICT,
    shape external_ident_shape NOT NULL, -- Denormalized from type for performance
    
    -- SUM type: exactly one branch must be used
    ident VARCHAR(50),           -- For shape='regular': simple identifier
    idents LTREE,                -- For shape='hierarchical': e.g., 'NORTH.KAMPALA.001'
    labels LTREE,                -- For shape='hierarchical': e.g., 'region.district.unit'
    
    -- Entity associations (unchanged)
    establishment_id INTEGER CHECK (admin.establishment_id_exists(establishment_id)),
    legal_unit_id INTEGER CHECK (admin.legal_unit_id_exists(legal_unit_id)),
    enterprise_id INTEGER REFERENCES public.enterprise(id) ON DELETE CASCADE,
    power_group_id INTEGER CHECK (admin.power_group_id_exists(power_group_id)),
    
    -- Audit fields (unchanged)
    edit_comment character varying(512),
    edit_by_user_id integer NOT NULL REFERENCES auth.user(id) ON DELETE RESTRICT,
    edit_at timestamp with time zone NOT NULL DEFAULT statement_timestamp(),
    
    -- Constraints
    CONSTRAINT shape_data_consistency CHECK (
        (shape = 'regular' AND ident IS NOT NULL AND idents IS NULL AND labels IS NULL) OR
        (shape = 'hierarchical' AND ident IS NULL AND idents IS NOT NULL AND labels IS NOT NULL)
    ),
    CONSTRAINT hierarchical_depth_valid CHECK (
        shape != 'hierarchical' OR nlevel(idents) = nlevel(labels)
    ),
    CONSTRAINT "One and only one statistical unit id must be set"
    CHECK (num_nonnulls(establishment_id, legal_unit_id, enterprise_id, power_group_id) = 1)
);

-- Regular identifiers: unique per type
CREATE UNIQUE INDEX external_ident_regular_uniqueness 
ON public.external_ident (type_id, ident) 
WHERE shape = 'regular';

-- Hierarchical identifiers: unique per type
CREATE UNIQUE INDEX external_ident_hierarchical_uniqueness 
ON public.external_ident (type_id, idents) 
WHERE shape = 'hierarchical';

-- GiST index for hierarchical queries (ancestor/descendant, pattern matching)
CREATE INDEX external_ident_hierarchical_gist 
ON public.external_ident USING GIST (idents) 
WHERE shape = 'hierarchical';

-- One identifier per type per unit - consolidated with NULLS NOT DISTINCT
-- Replaces 4 partial indexes with 1 comprehensive index
CREATE UNIQUE INDEX external_ident_type_unit_association_nulls_not_distinct
ON public.external_ident(type_id, establishment_id, legal_unit_id, enterprise_id, power_group_id) 
NULLS NOT DISTINCT;

-- Lookup indexes
CREATE INDEX external_ident_establishment_id_idx ON public.external_ident(establishment_id);
CREATE INDEX external_ident_legal_unit_id_idx ON public.external_ident(legal_unit_id);
CREATE INDEX external_ident_enterprise_id_idx ON public.external_ident(enterprise_id);
CREATE INDEX external_ident_power_group_id_idx ON public.external_ident(power_group_id);
CREATE INDEX ix_external_ident_edit_by_user_id ON public.external_ident USING btree (edit_by_user_id);

-- FUNDAMENTAL ALGORITHM IMPROVEMENTS: Always-beneficial indexes for import performance
-- These help ANY import regardless of data characteristics
CREATE INDEX external_ident_lookup_covering_idx 
ON public.external_ident (type_id, ident) 
INCLUDE (legal_unit_id, establishment_id);

CREATE INDEX external_ident_ident_hash_idx 
ON public.external_ident USING HASH (ident);

COMMENT ON TABLE public.external_ident IS 'Stores external identifier values using a SUM type design: regular identifiers use ident (text), hierarchical identifiers use idents (ltree) with corresponding labels (ltree).';

-- =============================================================================
-- Trigger: Derive shape and labels from type, validate SUM type consistency
-- =============================================================================
CREATE OR REPLACE FUNCTION public.external_ident_derive_shape_labels()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $external_ident_derive_shape_labels$
DECLARE
    _shape external_ident_shape;
    _labels LTREE;
    _type_code TEXT;
BEGIN
    -- Get shape, labels, and code from type for validation
    SELECT shape, labels, code INTO _shape, _labels, _type_code
    FROM public.external_ident_type 
    WHERE id = NEW.type_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid type_id: %', NEW.type_id;
    END IF;
    
    -- Set denormalized fields
    NEW.shape := _shape;
    
    IF _shape = 'hierarchical' THEN
        NEW.labels := _labels;
        
        -- Validate user provided correct fields
        IF NEW.idents IS NULL THEN
            RAISE EXCEPTION 'Hierarchical identifier type "%" requires idents (ltree), not ident', _type_code;
        END IF;
        IF NEW.ident IS NOT NULL THEN
            RAISE EXCEPTION 'Hierarchical identifier type "%" cannot use ident field, use idents instead', _type_code;
        END IF;
    ELSE -- regular
        NEW.labels := NULL;
        
        -- Validate user provided correct fields  
        IF NEW.ident IS NULL THEN
            RAISE EXCEPTION 'Regular identifier type "%" requires ident (text), not idents', _type_code;
        END IF;
        IF NEW.idents IS NOT NULL THEN
            RAISE EXCEPTION 'Regular identifier type "%" cannot use idents field, use ident instead', _type_code;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$external_ident_derive_shape_labels$;

CREATE TRIGGER external_ident_derive_shape_labels
    BEFORE INSERT OR UPDATE OF type_id ON public.external_ident
    FOR EACH ROW
    EXECUTE FUNCTION public.external_ident_derive_shape_labels();

END;
