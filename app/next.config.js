// next.config.js
const dotenv = require('dotenv');
if (process.env.NODE_ENV !== 'production' && !process.env.ENV_LOADED) {
  const envFilePath = '../.env';
  dotenv.config({ path: envFilePath });
  process.env.ENV_LOADED = 'true';
  console.log(`Development Environment file ${envFilePath} loaded successfully.`);
}

// Environment Variable Loading Strategy:
// 1. Local Development (NODE_ENV !== 'production', e.g., `pnpm run dev`):
//    - The `dotenv.config({ path: '../.env' })` block above explicitly loads variables
//      from the project root's `.env` file (which is typically generated by `../devops/manage.cr`).
//    - This ensures local development running directly on the host (outside Docker)
//      has access to necessary configurations.
// 2. Production Builds & Dockerized Environments (NODE_ENV === 'production'):
//    - The `dotenv.config()` block above is SKIPPED because `NODE_ENV` will be 'production'.
//    - Environment variables are primarily sourced from the Docker environment,
//      as defined in `docker-compose.app.yml` (which itself reads from the root `.env` file).
//    - Next.js's built-in support for files like `.env.production` within the `app` directory
//      would also apply if those files exist, but Docker-provided variables typically take precedence.

const isDevelopment = process.env.NODE_ENV === 'development';

// Report DEBUG and NEXT_PUBLIC_DEBUG status once per process lifecycle, if they are true.
if (!process.env.DEBUG_STATUS_REPORTED) {
  if (process.env.DEBUG === 'true') {
    console.log("next.config.js: DEBUG environment variable is true.");
  }
  if (process.env.NEXT_PUBLIC_DEBUG === 'true') {
    console.log("next.config.js: NEXT_PUBLIC_DEBUG environment variable is true.");
  }
  if (process.env.NODE_ENV === 'development') {
   console.log(`next.config.js: NODE_ENV environment variable is: ${process.env.NODE_ENV}`);
  }
  // Set the flag after the first check to prevent repeated logging
  // in subsequent times this config file might be processed.
  process.env.DEBUG_STATUS_REPORTED = 'true';
}

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  // output: 'standalone' is primarily for production builds.
  // Set it conditionally to avoid potential interference with dev server features like proxying.
  ...(isDevelopment && {
    allowedDevOrigins: ['local.statbus.org'],
  }),
};

if (!isDevelopment) {
  nextConfig.output = 'standalone';
}

// Add API proxying in development mode
if (isDevelopment) {
  // This block runs ONCE to determine URLs, log, and override NEXT_PUBLIC_BROWSER_REST_URL for the client.
  if (!process.env.PROXY_ENV_VARS_CONFIGURED) {
    // Step 1: Determine Caddy's URL (where Next.js should proxy to).
    // Read the original NEXT_PUBLIC_BROWSER_REST_URL from .env, which points to Caddy.
    const originalBrowserRestUrl = process.env.NEXT_PUBLIC_BROWSER_REST_URL;
    if (!originalBrowserRestUrl) {
      console.error(
        "ERROR: NEXT_PUBLIC_BROWSER_REST_URL is not set in .env. " +
        "This is required for local development rewrites to Caddy. " +
        "Please run './devops/manage-statbus.sh generate-config'."
      );
      throw new Error('NEXT_PUBLIC_BROWSER_REST_URL is not set for local development proxy.');
    }
    // Store the determined Caddy URL in an internal environment variable for the rewrites rule.
    process.env.INTERNAL_CADDY_REWRITE_TARGET = originalBrowserRestUrl.startsWith('http')
      ? originalBrowserRestUrl
      : `http://${originalBrowserRestUrl}`;

    // Step 2: Determine the local Next.js app URL.
    // Use local.statbus.org instead of localhost to avoid cross-origin issues
    // when accessing the app via local.statbus.org
    const localAppPort = process.env.PORT || 3000;
    const actualLocalAppUrl = `http://local.statbus.org:${localAppPort}`;
    // Store this also in an internal environment variable.
    process.env.INTERNAL_LOCAL_APP_URL = actualLocalAppUrl;
    
    // Step 3: Log the configuration (once).
    console.log(
      `Local Development: Client-side API calls (NEXT_PUBLIC_BROWSER_REST_URL) will use: ${process.env.INTERNAL_LOCAL_APP_URL}`
    );
    // IMPORTANT: Override NEXT_PUBLIC_BROWSER_REST_URL for the client-side bundle (once).
    // This ensures client-side fetch calls go to the Next.js server (which then proxies).
    process.env.NEXT_PUBLIC_BROWSER_REST_URL = process.env.INTERNAL_LOCAL_APP_URL;

    console.log(
      `Local Development: Next.js server will proxy API calls from ${process.env.INTERNAL_LOCAL_APP_URL}/rest/* to ${process.env.INTERNAL_CADDY_REWRITE_TARGET}/rest/*`
    );
    
    process.env.PROXY_ENV_VARS_CONFIGURED = 'true';
  }

  // This part runs EVERY TIME the config is processed by Next.js.
  // It reads the Caddy target URL that was determined and stored in the "run once" block.
  const caddyTargetForRewriteRule = process.env.INTERNAL_CADDY_REWRITE_TARGET;
  
  nextConfig.rewrites = async () => {
    if (!caddyTargetForRewriteRule) {
      // This condition should ideally not be met if the logic above is sound.
      // If it is, the proxy setup is critically flawed.
      console.error("next.config.js: CRITICAL - INTERNAL_CADDY_REWRITE_TARGET is not set. Proxy will not be configured.");
      return []; // Return no rewrites to prevent errors.
    }
    return [
      {
        source: '/rest/:path*',
        destination: `${caddyTargetForRewriteRule}/rest/:path*`,
      },
    ];
  };
}

module.exports = nextConfig;
