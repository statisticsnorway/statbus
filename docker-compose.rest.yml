# PostgREST API service configuration
services:
  rest:
    container_name: ${COMPOSE_INSTANCE_NAME:-statbus}-rest
    image: postgrest/postgrest:v12.2.0
    depends_on:
      db:
        condition: service_healthy
    restart: unless-stopped
    environment:
      PGRST_DB_URI: postgres://authenticator:${POSTGRES_AUTHENTICATOR_PASSWORD:?POSTGRES_AUTHENTICATOR_PASSWORD must be set in the generated .env}@db:5432/statbus_${NEXT_PUBLIC_DEPLOYMENT_SLOT_CODE:-dev}
      PGRST_DB_SCHEMAS: ${PGRST_DB_SCHEMAS:-public}
      PGRST_DB_ANON_ROLE: anon
      PGRST_DB_USE_LEGACY_GUCS: "false"
      PGRST_JWT_SECRET: ${JWT_SECRET:?JWT_SECRET must be set in the generated .env}
      PGRST_APP_SETTINGS_JWT_SECRET: ${JWT_SECRET:?JWT_SECRET must be set in the generated .env}
      # Access and refresh tokens use the same secret (PGRST_APP_SETTINGS_JWT_SECRET)
      # JWT expiration time in seconds: 3600 = 1 hour
      PGRST_APP_SETTINGS_ACCESS_JWT_EXP: ${ACCESS_JWT_EXPIRY:?ACCESS_JWT_EXPIRY must be set in the generated .env}
      # Refresh token expiration time in seconds: 2592000 = 30 days
      PGRST_APP_SETTINGS_REFRESH_JWT_EXP: ${REFRESH_JWT_EXPIRY:?REFRESH_JWT_EXPIRY must be set in the generated .env}
      # Enable group by counting for getting the available filter values with counts
      PGRST_DB_AGGREGATES_ENABLED: "true"
      # JWT claims available in current_setting('request.jwt.claims')
      PGRST_JWT_AUD: "statbus"
      # Pass deployment slot code to database for cookie naming
      PGRST_DB_CONFIG: app.settings.deployment_slot_code=${NEXT_PUBLIC_DEPLOYMENT_SLOT_CODE:-dev}
    ports:
      - "${REST_PORT:-3000}:3000"
    profiles:
      - "all"
      - "all_except_app"
    command: "postgrest"
