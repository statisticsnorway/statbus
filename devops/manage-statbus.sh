#!/bin/bash
#
set -e # Exit on any failure for any command

if test -n "$DEBUG"; then
  set -x # Print all commands before running them - for easy debugging.
fi

WORKSPACE="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && cd .. && pwd )"
cd $WORKSPACE

#### TODO: Replace this with a proper .env generator.
# if ! test -f $WORKSPACE/supabase_docker/.env; then
#   cp -f $WORKSPACE/.supabase-docker-local-development-env $WORKSPACE/supabase_docker/.env
# fi
# if ! test -f $WORKSPACE/.env; then
#     # TODO: Improve generato
#   cat > $WORKSPACE/.env <<EOS
# COMPOSE_FILE=docker-compose.app.yml
# COMPOSE_INSTANCE_NAME=statbus-dev
# PUBLIC_PORT=127.0.0.1:3000
# SUPABASE_ANON_KEY=...
# SUPABASE_URL=...
# EOS
#   echo "Edit .env and adjust the variables as required."
# fi

action=$1
shift || true # move away $1 from $@
case "$action" in
    'start' )
        VERSION=$(git describe --always)
        ./devops/dotenv --file .env set VERSION=$VERSION
        docker compose up --detach
      ;;
    'stop' )
        docker compose down
      ;;
    'logs' )
        docker compose logs --follow
      ;;
    'ps' )
        docker compose ps
      ;;
    'create-db-structure' )
        ./devops/psql-development.sh < dbseed/create-db-structure.sql 2>&1
      ;;
    'delete-db-structure' )
        ./devops/psql-development.sh < dbseed/delete-db-structure.sql 2>&1
      ;;
    'recreate-database' )
        ./devops/recreate-database.sh
      ;;
    'delete-db' )
        rm -rf $WORKSPACE/supabase_docker/volumes/db/data/*
      ;;
     'upgrade_supabase' )
        git reset supabase_docker
        if test ! -d ../supabase; then
            pushd ..
            git clone https://github.com/supabase/supabase
            popd
        fi
        pushd ../supabase
        git pull
        rsync -av docker/ ../statbus/supabase_docker
        popd
        git add supabase_docker
        ./devops/manage-statbus.sh generate-docker-compose-adjustments
        git add docker-compose.supabase_docker.*
        git commit -m 'Upgraded Supabase Docker'
      ;;
     'generate-config' )
        if ! test -f .users.yml; then
            echo "Copy .users.example to .users.yml and add your admin users"
        fi

        CREDENTIALS_FILE=".env.credentials"
        echo Using credentials from $CREDENTIALS_FILE
        POSTGRES_PASSWORD=$(./devops/dotenv --file $CREDENTIALS_FILE generate POSTGRES_PASSWORD pwgen 20)
        JWT_SECRET=$(./devops/dotenv --file $CREDENTIALS_FILE generate JWT_SECRET pwgen 32)
        DASHBOARD_USERNAME=$(./devops/dotenv --file $CREDENTIALS_FILE generate DASHBOARD_USERNAME echo admin)
        DASHBOARD_PASSWORD=$(./devops/dotenv --file $CREDENTIALS_FILE generate DASHBOARD_PASSWORD pwgen 20)

        CONFIG_FILE=".env.config"
        echo Using config from $CONFIG_FILE
        # The name displayed on the web
        DEPLOYMENT_SLOT_NAME=$(./devops/dotenv --file $CONFIG_FILE generate DEPLOYMENT_SLOT_NAME echo "Development")
        # Unique code used on the server for distinct docker namespaces
        DEPLOYMENT_SLOT_CODE=$(./devops/dotenv --file $CONFIG_FILE generate DEPLOYMENT_SLOT_CODE echo "dev")
        # Offset to calculate ports exposed by docker compose
        DEPLOYMENT_SLOT_PORT_OFFSET=$(./devops/dotenv --file $CONFIG_FILE generate DEPLOYMENT_SLOT_PORT_OFFSET echo "0")
        # Urls configured in Caddy and DNS.
        STATBUS_URL=$(./devops/dotenv --file $CONFIG_FILE generate STATBUS_URL echo "http://localhost:4080")
        SUPABASE_URL=$(./devops/dotenv --file $CONFIG_FILE generate SUPABASE_URL echo "http://localhost:4090")
        # Logging server
        SEQ_SERVER_URL=$(./devops/dotenv --file $CONFIG_FILE generate SEQ_SERVER_URL echo "https://log.statbus.org")
        SEQ_API_KEY=$(./devops/dotenv --file $CONFIG_FILE generate SEQ_API_KEY echo "secret")

        # Prepare a new environment file
        # Check if the original file exists
        if test -f .env; then
            # Use the current date as the base for the backup suffix
            backup_base=$(date -u +%Y-%m-%d)
            backup_suffix="backup.$backup_base"
            counter=1

            # Loop to find a unique backup file name
            while test -f ".env.$backup_suffix"; do
                # If a file with the current suffix exists, increment the counter and append it to the suffix
                backup_suffix="backup.${backup_base}_$counter"
                ((counter++))
            done

            # Inform the user about the replacement and backup process
            echo "Replacing .env - the old version is backed up as .env.$backup_suffix"

            # Move the original file to its backup location with the unique suffix
            mv .env ".env.$backup_suffix"
        fi

        cat > .env <<'EOS'
################################################################
# Statbus Environment Variables
# Generated by `./devops/manage-statbus.sh generate-config`
# Used by docker compose, both for statbus containers
# and for the included supabase containers.
# The files:
#   `.env.credentials` generated if missing, with stable credentials.
#   `.env.config` generated if missing, configuration for installation.
#   `.env` generated with input from `.env.credentials` and `.env.config`
# The `.env` file contains settings used both by
# the statbus app (Backend/frontend) and by the Supabase Docker
# containers.
# The top level `docker-compose.yml` file includes all configuration
# required for all statbus docker containers, but must be managed
# by `./devops/manage-statbus.sh` that also sets the VERSION
# required for precise logging by the statbus app.
################################################################

EOS

        cat >> .env <<'EOS'

################################################################
# Statbus Container Configuration
################################################################

# The name displayed on the web
DEPLOYMENT_SLOT_NAME=Example
# Urls configured in Caddy and DNS.
STATBUS_URL=https://www.ex.statbus.org
SUPABASE_URL=https://api.ex.statbus.org
# Logging server
SEQ_SERVER_URL=https://log.statbus.org
SEQ_API_KEY=secret_api_key
# The prefix used for all container names in docker
COMPOSE_INSTANCE_NAME=statbus
# The host address connected to the STATBUS app
APP_BIND_ADDRESS=127.0.0.1:3080
# The host address connected to Supabase
SUPABASE_BIND_ADDRESS=127.0.0.1:3080
# The publicly exposed address of PostgreSQL inside Supabase
DB_PUBLIC_LOCALHOST_PORT=3432
# Users to create on system setup.
# Read from `.users.yml` see `.users.example` for syntax.
STATBUS_USERS_JSON='[]'
# Updated by manage-statbus.sh start
VERSION=commit_sha_or_version_of_deployed_commit
EOS

        cat >> .env <<'EOS'

################################################################
## Supabase Container Configuation
# Adapted from supabase_docker/.env.example
################################################################


EOS
        cat supabase_docker/.env.example >> .env

        echo "Setting Statbus Container Configuration"
        ./devops/dotenv --file .env set DEPLOYMENT_SLOT_NAME=Development
        ./devops/dotenv --file .env set COMPOSE_INSTANCE_NAME="statbus-$DEPLOYMENT_SLOT_CODE"
        ./devops/dotenv --file .env set STATBUS_URL=$STATBUS_URL
        ./devops/dotenv --file .env set SUPABASE_URL=$SUPABASE_URL
        ./devops/dotenv --file .env set SEQ_SERVER_URL=$SEQ_SERVER_URL
        ./devops/dotenv --file .env set SEQ_API_KEY=$SEQ_API_KEY

        APP_BIND_ADDRESS="127.0.0.1:$(( 3000+$DEPLOYMENT_SLOT_PORT_OFFSET*10 ))"
        ./devops/dotenv --file .env set APP_BIND_ADDRESS=$APP_BIND_ADDRESS

        SUPABASE_BIND_ADDRESS="127.0.0.1:$(( 3000+$DEPLOYMENT_SLOT_PORT_OFFSET*10+1 ))"
        ./devops/dotenv --file .env set SUPABASE_BIND_ADDRESS=$SUPABASE_BIND_ADDRESS

        DB_PUBLIC_LOCALHOST_PORT="127.0.0.1:$(( 3000+$DEPLOYMENT_SLOT_PORT_OFFSET*10+2 ))"
        ./devops/dotenv --file .env set DB_PUBLIC_LOCALHOST_PORT=$DB_PUBLIC_LOCALHOST_PORT

        export STATBUS_USERS_JSON=$(yq --output-format json --indent 0 --input-format yaml .users.yml)
        ./devops/dotenv --file .env set STATBUS_USERS_JSON=$STATBUS_USERS_JSON

        echo "Setting Supabase Container Configuration"

        ./devops/dotenv --file .env set POSTGRES_PASSWORD=$POSTGRES_PASSWORD
        ./devops/dotenv --file .env set JWT_SECRET=$JWT_SECRET
        ./devops/dotenv --file .env set DASHBOARD_USERNAME=$DASHBOARD_USERNAME
        ./devops/dotenv --file .env set DASHBOARD_PASSWORD=$DASHBOARD_PASSWORD

        ./devops/dotenv --file .env set SITE_URL=$STATBUS_URL
        ./devops/dotenv --file .env set API_EXTERNAL_URL=$SUPABASE_URL
        ./devops/dotenv --file .env set SUPABASE_PUBLIC_URL=$SUPABASE_URL
        # Maps to GOTRUE_EXTERNAL_EMAIL_ENABLED to allow authentication with Email at all.
        # So SIGNUP really means SIGNIN
        ./devops/dotenv --file .env set ENABLE_EMAIL_SIGNUP=true
        # Allow creating users and setting the email as verified,
        # rather than sending an actual email where the user must
        # click the link.
        ./devops/dotenv --file .env set ENABLE_EMAIL_AUTOCONFIRM=true
        # Disables signup with EMAIL, when ENABLE_EMAIL_SIGNUP=true
        ./devops/dotenv --file .env set DISABLE_SIGNUP=true



        # Issued At Time: Current timestamp in seconds since the Unix epoch
        iat=$(date +%s)
        # Number of seconds in 5 years (5 years * 365 days/year * 24 hours/day * 60 minutes/hour * 60 seconds/minute)
        seconds_in_5_years=$((5 * 365 * 24 * 60 * 60))
        # Expiration Time: Calculate exp as iat plus the seconds in 5 years
        exp=$((iat + seconds_in_5_years))
        jwt_anon_payload=$(cat <<EOF
{
  "role": "anon",
  "iss": "supabase",
  "iat": $iat,
  "exp": $exp
}
EOF
)
        jwt_service_role_payload=$(cat <<EOF
{
  "role": "service_role",
  "iss": "supabase",
  "iat": $iat,
  "exp": $exp
}
EOF
)
        # brew install mike-engel/jwt-cli/jwt-cli
        export ANON_KEY=$(jwt encode --secret "$JWT_SECRET" "$jwt_anon_payload")
        ./devops/dotenv --file .env set ANON_KEY=$ANON_KEY

        export SERVICE_ROLE_KEY=$(jwt encode --secret "$JWT_SECRET" "$jwt_service_role_payload")
        ./devops/dotenv --file .env set SERVICE_ROLE_KEY=$SERVICE_ROLE_KEY

        ;;
     'postgres-variables' )
        DB_PUBLIC_LOCALHOST_PORT=$(./devops/dotenv --file .env get DB_PUBLIC_LOCALHOST_PORT)
        # Extract the host part (before the colon) and set it to PGHOST
        PGHOST=$(echo $DB_PUBLIC_LOCALHOST_PORT | cut -d':' -f1)
        # Extract the port part (after the colon) and set it to PGPORT
        PGPORT=$(echo $DB_PUBLIC_LOCALHOST_PORT | cut -d':' -f2)
        PGDATABASE=$(./devops/dotenv --file .env get POSTGRES_DB)
        PGUSER=postgres
        PGPASSWORD=$(./devops/dotenv --file .env get POSTGRES_PASSWORD)
        cat <<EOS
export PGHOST=$PGHOST PGPORT=$PGPORT PGDATABASE=$PGDATABASE PGUSER=$PGUSER PGPASSWORD=$PGPASSWORD
EOS
      ;;
     'psql' )
        DB_PUBLIC_LOCALHOST_PORT=$(./devops/dotenv --file .env get DB_PUBLIC_LOCALHOST_PORT)
        # Extract the host part (before the colon) and set it to PGHOST
        export PGHOST=$(echo $DB_PUBLIC_LOCALHOST_PORT | cut -d':' -f1)
        # Extract the port part (after the colon) and set it to PGPORT
        export PGPORT=$(echo $DB_PUBLIC_LOCALHOST_PORT | cut -d':' -f2)
        export PGDATABASE=$(./devops/dotenv --file .env get POSTGRES_DB)
        export PGUSER=postgres
        export PGPASSWORD=$(./devops/dotenv --file .env get POSTGRES_PASSWORD)
        if $(which psql > /dev/null); then
          psql "$@"
        else
          # When using scripted input, such as "< some.sql" then interactive TTY is required.
          args="-i"
          if test -t 0; then
            # Enable the TTY in docker,with -t
            # as required for an interactive psql promp
            args="-ti"
          fi
          docker exec $args $(docker ps  | awk '/statbus-db/{print $1}') psql -U $PGUSER $PGDATABASE "$@"
        fi
      ;;
     'generate-types' )
        pushd $WORKSPACE/app
        #nvm doesn' work in a script!
        #if which fnm; then
        #    fnm use
        #else
        #    nvm use
        #fi
        eval $($WORKSPACE/devops/manage-statbus.sh postgres-variables)
        db_url="postgresql://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/$PGDATABASE?sslmode=disable"
        # Run interactively and say 'y' for installing the latest package
        ~/.nvm/nvm-exec npx supabase@beta gen types typescript --db-url "$db_url"
        # Update the types from the database.
        ~/.nvm/nvm-exec npx supabase@beta gen types typescript --db-url "$db_url" > src/lib/database.types.ts
      ;;
     'generate-docker-compose-adjustments' )
        echo Generating docker-compose.supabase_docker.customize-container_name.yml
        yq '(
          .. | # recurse through all the nodes
          select(has("container_name")) |
          .container_name = "${COMPOSE_INSTANCE_NAME:-statbus}-" + key |
          (.container_name)
        ) as $i ireduce({};  # using that set of nodes, create a new result map
          setpath($i | path; $i) # and put in each node, using its original path
        ) ' supabase_docker/docker-compose.yml > docker-compose.supabase_docker.customize-container_name.yml

        echo Generating docker-compose.supabase_docker.erase-ports.yml
        yq '(
          .. | # recurse through all the nodes
          select(has("ports")) | # match parents that have volume
          (.ports) | # select those children
          select(.) # filter out nulls
          | . |= "!reset []"
        ) as $i ireduce({};  # using that set of nodes, create a new result map
          setpath($i | path; $i) # and put in each node, using its original path
        ) ' supabase_docker/docker-compose.yml | tr -d "'" > docker-compose.supabase_docker.erase-ports.yml

      ;;
     * )
      echo "Unknown action '$action', select one of"
      awk -F "'" '/^ +''(..+)'' \)$/{print $2}' devops/manage-statbus.sh
      exit 1
      ;;
esac
